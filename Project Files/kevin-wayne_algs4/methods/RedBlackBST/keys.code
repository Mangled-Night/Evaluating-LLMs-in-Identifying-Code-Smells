/** 
 * Returns all keys in the symbol table in ascending order as an  {@code Iterable}. To iterate over all of the keys in the symbol table named  {@code st}, use the foreach notation:  {@code for (Key key : st.keys())}.
 * @return all keys in the symbol table in ascending order
 */
public Iterable<Key> keys(){
  if (isEmpty())   return new Queue<Key>();
  return keys(min(),max());
}
/** 
 * Returns all keys in the symbol table in the given range in ascending order, as an  {@code Iterable}.
 * @param lo minimum endpoint
 * @param hi maximum endpoint
 * @return all keys in the symbol table between {@code lo}(inclusive) and  {@code hi} (inclusive) in ascending order
 * @throws IllegalArgumentException if either {@code lo} or {@code hi}is  {@code null}
 */
public Iterable<Key> keys(Key lo,Key hi){
  if (lo == null)   throw new IllegalArgumentException("first argument to keys() is null");
  if (hi == null)   throw new IllegalArgumentException("second argument to keys() is null");
  Queue<Key> queue=new Queue<Key>();
  keys(root,queue,lo,hi);
  return queue;
}
private void keys(Node x,Queue<Key> queue,Key lo,Key hi){
  if (x == null)   return;
  int cmplo=lo.compareTo(x.key);
  int cmphi=hi.compareTo(x.key);
  if (cmplo < 0)   keys(x.left,queue,lo,hi);
  if (cmplo <= 0 && cmphi >= 0)   queue.enqueue(x.key);
  if (cmphi > 0)   keys(x.right,queue,lo,hi);
}
