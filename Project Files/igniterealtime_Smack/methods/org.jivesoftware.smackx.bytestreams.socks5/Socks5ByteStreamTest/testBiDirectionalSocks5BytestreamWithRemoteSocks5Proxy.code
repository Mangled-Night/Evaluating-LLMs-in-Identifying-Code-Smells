/** 
 * Socks5 bytestream should be successfully established using a Socks5 proxy provided by the XMPP server. The established connection should transfer data bidirectional if the Socks5 proxy supports it. <p> Support for bidirectional Socks5 bytestream: <ul> <li>Openfire (3.6.4 and below) - no</li> <li>ejabberd (2.0.5 and higher) - yes</li> </ul> <p> This test will fail if the XMPP server doesn't provide any Socks5 proxies or the Socks5 proxy only allows Socks5 bytestreams in the context of a file transfer (like Openfire in default configuration, see xmpp.proxy.transfer.required flag).
 * @throws Exception if no Socks5 proxies found or proxy is unwilling to activate Socks5bytestream
 */
public void testBiDirectionalSocks5BytestreamWithRemoteSocks5Proxy() throws Exception {
  XMPPConnection initiatorConnection=getConnection(0);
  SmackConfiguration.setLocalSocks5ProxyEnabled(false);
  Socks5Proxy.getSocks5Proxy().stop();
  assertFalse(Socks5Proxy.getSocks5Proxy().isRunning());
  XMPPConnection targetConnection=getConnection(1);
  final byte[] data=new byte[]{1,2,3};
  final SynchronousQueue<byte[]> queue=new SynchronousQueue<byte[]>();
  Socks5BytestreamManager targetByteStreamManager=Socks5BytestreamManager.getBytestreamManager(targetConnection);
  Socks5BytestreamListener incomingByteStreamListener=new Socks5BytestreamListener(){
    public void incomingBytestreamRequest(    Socks5BytestreamRequest request){
      try {
        Socks5BytestreamSession session=request.accept();
        OutputStream outputStream=session.getOutputStream();
        outputStream.write(data);
        outputStream.flush();
        InputStream inputStream=session.getInputStream();
        byte[] receivedData=new byte[3];
        inputStream.read(receivedData);
        queue.put(receivedData);
        session.close();
      }
 catch (      Exception e) {
        fail(e.getMessage());
      }
    }
  }
;
  targetByteStreamManager.addIncomingBytestreamListener(incomingByteStreamListener);
  Socks5BytestreamManager initiatorByteStreamManager=Socks5BytestreamManager.getBytestreamManager(initiatorConnection);
  Socks5BytestreamSession session=initiatorByteStreamManager.establishSession(targetConnection.getUser());
  assertTrue(session.isMediated());
  final byte[] receivedData=new byte[3];
  final InputStream inputStream=session.getInputStream();
  FutureTask<Integer> futureTask=new FutureTask<Integer>(new Callable<Integer>(){
    public Integer call() throws Exception {
      return inputStream.read(receivedData);
    }
  }
);
  Thread executor=new Thread(futureTask);
  executor.start();
  try {
    futureTask.get(2000,TimeUnit.MILLISECONDS);
  }
 catch (  TimeoutException e) {
    SmackConfiguration.setLocalSocks5ProxyEnabled(true);
    Socks5Proxy.getSocks5Proxy().start();
    fail("Couldn't send data from target to inititator");
  }
  assertEquals("sent data not equal to received data",data,receivedData);
  OutputStream outputStream=session.getOutputStream();
  outputStream.write(data);
  outputStream.flush();
  outputStream.close();
  assertEquals("received data not equal to sent data",data,queue.take());
  session.close();
  SmackConfiguration.setLocalSocks5ProxyEnabled(true);
  Socks5Proxy.getSocks5Proxy().start();
}
