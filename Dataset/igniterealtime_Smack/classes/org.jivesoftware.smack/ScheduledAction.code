public class ScheduledAction implements Delayed {
  enum Kind {  NonBlocking,   Blocking}
  private final Runnable action;
  final Date releaseTime;
  final SmackReactor smackReactor;
  final Kind kind;
  ScheduledAction(  Runnable action,  Date releaseTime,  SmackReactor smackReactor,  Kind kind){
    this.action=action;
    this.releaseTime=releaseTime;
    this.smackReactor=smackReactor;
    this.kind=kind;
  }
  /** 
 * Cancels this scheduled action.
 * @return <code>true</code> if the scheduled action was still pending and got removed, <code>false</code> otherwise.
 */
  public boolean cancel(){
    return smackReactor.cancel(this);
  }
  public boolean isDue(){
    Date now=new Date();
    return now.after(releaseTime);
  }
  public long getTimeToDueMillis(){
    long now=System.currentTimeMillis();
    return releaseTime.getTime() - now;
  }
  @Override public int compareTo(  Delayed otherDelayed){
    if (this == otherDelayed) {
      return 0;
    }
    long thisDelay=getDelay(TimeUnit.MILLISECONDS);
    long otherDelay=otherDelayed.getDelay(TimeUnit.MILLISECONDS);
    return Long.compare(thisDelay,otherDelay);
  }
  @Override public long getDelay(  TimeUnit unit){
    long delayInMillis=getTimeToDueMillis();
    return unit.convert(delayInMillis,TimeUnit.MILLISECONDS);
  }
  void run(){
switch (kind) {
case NonBlocking:
      action.run();
    break;
case Blocking:
  Async.go(() -> action.run());
break;
}
}
}
