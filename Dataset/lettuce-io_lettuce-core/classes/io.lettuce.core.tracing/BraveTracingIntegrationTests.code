/** 
 * Integration tests for  {@link BraveTracing}.
 * @author Mark Paluch
 * @author Daniel Albuquerque
 * @author Anuraag Agrawal
 */
@EnabledOnCommand("HELLO") class BraveTracingIntegrationTests extends TestSupport {
  private static ClientResources clientResources;
  private static RedisClient client;
  private static Tracing clientTracing;
  private static Queue<Span> spans=new LinkedBlockingQueue<>();
  @BeforeAll static void beforeClass(){
    clientTracing=Tracing.newBuilder().localServiceName("client").currentTraceContext(CurrentTraceContext.Default.create()).spanReporter(spans::add).build();
    clientResources=DefaultClientResources.builder().tracing(BraveTracing.create(clientTracing)).build();
    client=RedisClient.create(clientResources,RedisURI.Builder.redis(host,port).build());
  }
  @BeforeEach void before(){
    Tracer tracer=clientTracing.tracer();
    if (tracer.currentSpan() != null) {
      clientTracing.tracer().currentSpan().abandon();
    }
    spans.clear();
  }
  @AfterAll static void afterClass(){
    clientTracing.close();
    clientResources.shutdown(0,0,TimeUnit.MILLISECONDS);
  }
  @Test void pingWithTrace(){
    ScopedSpan foo=clientTracing.tracer().startScopedSpan("foo");
    StatefulRedisConnection<String,String> connect=client.connect();
    connect.sync().ping();
    Wait.untilNotEquals(true,spans::isEmpty).waitOrTimeout();
    foo.finish();
    List<Span> spans=new ArrayList<>(BraveTracingIntegrationTests.spans);
    assertThat(spans.get(0).name()).isEqualTo("hello");
    assertThat(spans.get(0).remoteEndpoint()).isNotNull();
    assertThat(spans.get(1).name()).isEqualTo("ping");
    assertThat(spans.get(1).remoteEndpoint().port()).isEqualTo(port);
  }
  @Test void pingWithTraceShouldCatchErrors(){
    ScopedSpan foo=clientTracing.tracer().startScopedSpan("foo");
    StatefulRedisConnection<String,String> connect=client.connect();
    connect.sync().set("foo","bar");
    try {
      connect.sync().hgetall("foo");
    }
 catch (    Exception e) {
    }
    Wait.untilTrue(() -> spans.size() > 2).waitOrTimeout();
    foo.finish();
    List<Span> spans=new ArrayList<>(BraveTracingIntegrationTests.spans);
    assertThat(spans.get(1).name()).isEqualTo("set");
    assertThat(spans.get(2).name()).isEqualTo("hgetall");
    assertThat(spans.get(2).tags()).containsEntry("error","WRONGTYPE Operation against a key holding the wrong kind of value");
    assertThat(spans.get(3).name()).isEqualTo("foo");
  }
  @Test void getAndSetWithTraceWithCommandArgsExcludedFromTags(){
    ClientResources clientResources=ClientResources.builder().tracing(BraveTracing.builder().tracing(clientTracing).excludeCommandArgsFromSpanTags().build()).build();
    RedisClient client=RedisClient.create(clientResources,RedisURI.Builder.redis(host,port).build());
    ScopedSpan trace=clientTracing.tracer().startScopedSpan("foo");
    StatefulRedisConnection<String,String> connect=client.connect();
    connect.sync().set("foo","bar");
    connect.sync().get("foo");
    Wait.untilTrue(() -> spans.size() > 2).waitOrTimeout();
    trace.finish();
    List<Span> spans=new ArrayList<>(BraveTracingIntegrationTests.spans);
    assertThat(spans.get(1).name()).isEqualTo("set");
    assertThat(spans.get(1).tags()).doesNotContainKey("redis.args");
    assertThat(spans.get(2).name()).isEqualTo("get");
    assertThat(spans.get(2).tags()).doesNotContainKey("redis.args");
    assertThat(spans.get(3).name()).isEqualTo("foo");
    FastShutdown.shutdown(client);
    FastShutdown.shutdown(clientResources);
  }
  @Test void reactivePing(){
    StatefulRedisConnection<String,String> connect=client.connect();
    connect.reactive().ping().as(StepVerifier::create).expectNext("PONG").verifyComplete();
    Wait.untilNotEquals(true,spans::isEmpty).waitOrTimeout();
    assertThat(spans).isNotEmpty();
  }
  @Test void reactivePingWithTrace(){
    ScopedSpan trace=clientTracing.tracer().startScopedSpan("foo");
    StatefulRedisConnection<String,String> connect=client.connect();
    connect.reactive().ping().contextWrite(it -> it.put(TraceContext.class,trace.context())).as(StepVerifier::create).expectNext("PONG").verifyComplete();
    Wait.untilNotEquals(true,spans::isEmpty).waitOrTimeout();
    trace.finish();
    List<Span> spans=new ArrayList<>(BraveTracingIntegrationTests.spans);
    assertThat(spans.get(1).name()).isEqualTo("ping");
    assertThat(spans.get(2).name()).isEqualTo("foo");
  }
  @Test void reactiveGetAndSetWithTrace(){
    ScopedSpan trace=clientTracing.tracer().startScopedSpan("foo");
    StatefulRedisConnection<String,String> connect=client.connect();
    connect.reactive().set("foo","bar").then(connect.reactive().get("foo")).contextWrite(it -> it.put(TraceContext.class,trace.context())).as(StepVerifier::create).expectNext("bar").verifyComplete();
    Wait.untilTrue(() -> spans.size() > 2).waitOrTimeout();
    trace.finish();
    List<Span> spans=new ArrayList<>(BraveTracingIntegrationTests.spans);
    assertThat(spans.get(1).name()).isEqualTo("set");
    assertThat(spans.get(1).tags()).containsEntry("redis.args","key<foo> value<bar>");
    assertThat(spans.get(2).name()).isEqualTo("get");
    assertThat(spans.get(2).tags()).containsEntry("redis.args","key<foo>");
    assertThat(spans.get(3).name()).isEqualTo("foo");
  }
  @Test void reactiveGetAndSetWithTraceProvider(){
    brave.Span trace=clientTracing.tracer().newTrace();
    StatefulRedisConnection<String,String> connect=client.connect();
    connect.reactive().set("foo","bar").then(connect.reactive().get("foo")).contextWrite(io.lettuce.core.tracing.Tracing.withTraceContextProvider(() -> BraveTracing.BraveTraceContext.create(trace.context()))).as(StepVerifier::create).expectNext("bar").verifyComplete();
    Wait.untilTrue(() -> spans.size() > 2).waitOrTimeout();
    trace.finish();
    List<Span> spans=new ArrayList<>(BraveTracingIntegrationTests.spans);
    assertThat(spans.get(1).name()).isEqualTo("set");
    assertThat(spans.get(2).name()).isEqualTo("get");
  }
}
