/** 
 * Returns a List of the offline <code>Messages</code> whose stamp matches the specified request. The request will include the list of stamps that uniquely identifies the offline messages to retrieve. The returned offline messages will not be deleted from the server. Use  {@link #deleteMessages(java.util.List)} to delete the messages.
 * @param nodes the list of stamps that uniquely identifies offline message.
 * @return a List with the offline <code>Messages</code> that were received as part ofthis request.
 * @throws XMPPErrorException If the user is not allowed to make this request or the server doesnot support offline message retrieval.
 * @throws NoResponseException if there was no response from the server.
 * @throws NotConnectedException if the XMPP connection is not connected.
 * @throws InterruptedException if the calling thread was interrupted.
 */
public List<Message> getMessages(final List<String> nodes) throws NoResponseException, XMPPErrorException, NotConnectedException, InterruptedException {
  List<Message> messages=new ArrayList<>(nodes.size());
  OfflineMessageRequest request=new OfflineMessageRequest();
  for (  String node : nodes) {
    OfflineMessageRequest.Item item=new OfflineMessageRequest.Item(node);
    item.setAction("view");
    request.addItem(item);
  }
  StanzaFilter messageFilter=new AndFilter(PACKET_FILTER,new StanzaFilter(){
    @Override public boolean accept(    Stanza packet){
      OfflineMessageInfo info=packet.getExtension(OfflineMessageInfo.class);
      return nodes.contains(info.getNode());
    }
  }
);
  int pendingNodes=nodes.size();
  try (StanzaCollector messageCollector=connection().createStanzaCollector(messageFilter)){
    connection().sendIqRequestAndWaitForResponse(request);
    Message message;
    do {
      message=messageCollector.nextResult();
      if (message != null) {
        messages.add(message);
        pendingNodes--;
      }
 else       if (message == null && pendingNodes > 0) {
        LOGGER.log(Level.WARNING,"Did not receive all expected offline messages. " + pendingNodes + " are missing.");
      }
    }
 while (message != null && pendingNodes > 0);
  }
   return messages;
}
/** 
 * Returns a List of Messages with all the offline <code>Messages</code> of the user. The returned offline messages will not be deleted from the server. Use  {@link #deleteMessages(java.util.List)}to delete the messages.
 * @return a List with all the offline <code>Messages</code> of the user.
 * @throws XMPPErrorException If the user is not allowed to make this request or the server doesnot support offline message retrieval.
 * @throws NoResponseException if there was no response from the server.
 * @throws NotConnectedException if the XMPP connection is not connected.
 * @throws InterruptedException if the calling thread was interrupted.
 */
public List<Message> getMessages() throws NoResponseException, XMPPErrorException, NotConnectedException, InterruptedException {
  OfflineMessageRequest request=new OfflineMessageRequest();
  request.setFetch(true);
  StanzaCollector resultCollector=connection().createStanzaCollectorAndSend(request);
  StanzaCollector.Configuration messageCollectorConfiguration=StanzaCollector.newConfiguration().setStanzaFilter(PACKET_FILTER).setCollectorToReset(resultCollector);
  List<Message> messages;
  try (StanzaCollector messageCollector=connection().createStanzaCollector(messageCollectorConfiguration)){
    resultCollector.nextResultOrThrow();
    messageCollector.cancel();
    messages=new ArrayList<>(messageCollector.getCollectedCount());
    Message message;
    while ((message=messageCollector.pollResult()) != null) {
      messages.add(message);
    }
  }
   return messages;
}
