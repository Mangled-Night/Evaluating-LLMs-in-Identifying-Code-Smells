/** 
 * Determines whether the digraph  {@code G} has a topological order and, if so,finds such a topological order.
 * @param G the digraph
 */
public TopologicalX(Digraph G){
  int[] indegree=new int[G.V()];
  for (int v=0; v < G.V(); v++) {
    indegree[v]=G.indegree(v);
  }
  ranks=new int[G.V()];
  order=new Queue<Integer>();
  int count=0;
  Queue<Integer> queue=new Queue<Integer>();
  for (int v=0; v < G.V(); v++)   if (indegree[v] == 0)   queue.enqueue(v);
  while (!queue.isEmpty()) {
    int v=queue.dequeue();
    order.enqueue(v);
    ranks[v]=count++;
    for (    int w : G.adj(v)) {
      indegree[w]--;
      if (indegree[w] == 0)       queue.enqueue(w);
    }
  }
  if (count != G.V()) {
    order=null;
  }
  assert check(G);
}
/** 
 * Determines whether the edge-weighted digraph  {@code G} has atopological order and, if so, finds such a topological order.
 * @param G the digraph
 */
public TopologicalX(EdgeWeightedDigraph G){
  int[] indegree=new int[G.V()];
  for (int v=0; v < G.V(); v++) {
    indegree[v]=G.indegree(v);
  }
  ranks=new int[G.V()];
  order=new Queue<Integer>();
  int count=0;
  Queue<Integer> queue=new Queue<Integer>();
  for (int v=0; v < G.V(); v++)   if (indegree[v] == 0)   queue.enqueue(v);
  while (!queue.isEmpty()) {
    int v=queue.dequeue();
    order.enqueue(v);
    ranks[v]=count++;
    for (    DirectedEdge e : G.adj(v)) {
      int w=e.to();
      indegree[w]--;
      if (indegree[w] == 0)       queue.enqueue(w);
    }
  }
  if (count != G.V()) {
    order=null;
  }
  assert check(G);
}
