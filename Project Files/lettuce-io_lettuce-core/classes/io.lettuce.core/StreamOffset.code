/** 
 * Value object representing a Stream with its offset.
 */
public static class StreamOffset<K> {
  final K name;
  final String offset;
  private StreamOffset(  K name,  String offset){
    this.name=name;
    this.offset=offset;
  }
  /** 
 * Read all new arriving elements from the stream identified by  {@code name}.
 * @param name must not be {@code null}.
 * @return the {@link StreamOffset} object without a specific offset.
 */
  public static <K>StreamOffset<K> latest(  K name){
    LettuceAssert.notNull(name,"Stream must not be null");
    return new StreamOffset<>(name,"$");
  }
  /** 
 * Read all new arriving elements from the stream identified by  {@code name} with ids greater than the last one consumedby the consumer group.
 * @param name must not be {@code null}.
 * @return the {@link StreamOffset} object without a specific offset.
 */
  public static <K>StreamOffset<K> lastConsumed(  K name){
    LettuceAssert.notNull(name,"Stream must not be null");
    return new StreamOffset<>(name,">");
  }
  /** 
 * Read all arriving elements from the stream identified by  {@code name} starting at {@code offset}.
 * @param name must not be {@code null}.
 * @param offset the stream offset.
 * @return the {@link StreamOffset} object without a specific offset.
 */
  public static <K>StreamOffset<K> from(  K name,  String offset){
    LettuceAssert.notNull(name,"Stream must not be null");
    LettuceAssert.notEmpty(offset,"Offset must not be empty");
    return new StreamOffset<>(name,offset);
  }
  public K getName(){
    return name;
  }
  public String getOffset(){
    return offset;
  }
  @Override public String toString(){
    return String.format("%s:%s",name,offset);
  }
}
