/** 
 * Return an array of  {@link ResolvableType}s representing the generic parameters of this type. If no generics are available an empty array is returned. If you need to access a specific generic consider using the  {@link #getGeneric(int...)}method as it allows access to nested generics and protects against  {@code IndexOutOfBoundsExceptions}.
 * @return an array of {@link ResolvableType}s representing the generic parameters (never  {@code null})
 * @see #hasGenerics()
 * @see #getGeneric(int...)
 * @see #resolveGeneric(int...)
 * @see #resolveGenerics()
 */
public ResolvableType[] getGenerics(){
  if (this == NONE) {
    return EMPTY_TYPES_ARRAY;
  }
  if (this.generics == null) {
    if (this.type instanceof Class) {
      Class<?> typeClass=(Class<?>)this.type;
      this.generics=forTypes(TypeWrapper.forTypeParameters(typeClass),this.variableResolver);
    }
 else     if (this.type instanceof ParameterizedType) {
      Type[] actualTypeArguments=((ParameterizedType)this.type).getActualTypeArguments();
      ResolvableType[] generics=new ResolvableType[actualTypeArguments.length];
      for (int i=0; i < actualTypeArguments.length; i++) {
        generics[i]=forType(actualTypeArguments[i],this.variableResolver);
      }
      this.generics=generics;
    }
 else {
      this.generics=resolveType().getGenerics();
    }
  }
  return this.generics;
}
