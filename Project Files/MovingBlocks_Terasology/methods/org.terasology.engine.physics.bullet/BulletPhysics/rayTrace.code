@Override public HitResult rayTrace(Vector3f from,Vector3f direction,float distance,CollisionGroup... collisionGroups){
  Vector3f to=new Vector3f(direction);
  to.normalize();
  to.mul(distance);
  to.add(from);
  short filter=combineGroups(collisionGroups);
  ClosestRayResultCallback callback=new ClosestRayResultCallback(from,to);
  callback.setCollisionFilterGroup(StandardCollisionGroup.ALL.getFlag());
  callback.setCollisionFilterMask(filter);
  discreteDynamicsWorld.rayTest(from,to,callback);
  if (callback.hasHit()) {
    btCollisionObject collisionObject=callback.getCollisionObject();
    Vector3f hitPointWorld=new Vector3f();
    callback.getHitPointWorld(hitPointWorld);
    Vector3f hitNormalWorld=new Vector3f();
    callback.getHitNormalWorld(hitNormalWorld);
    if (callback.hasHit()) {
      callback.dispose();
      if (collisionObject.userData instanceof EntityRef) {
        return new HitResult((EntityRef)collisionObject.userData,hitPointWorld,hitNormalWorld);
      }
 else       if ((collisionObject.getCollisionFlags() & btCollisionObject.CollisionFlags.CF_VOXEL_OBJECT) > 0) {
        btVector3i pos=new btVector3i();
        collisionObject.getVoxelPosition(pos);
        Vector3i voxelPosition=new Vector3i(pos.getX(),pos.getY(),pos.getZ());
        final EntityRef entityAt=blockEntityRegistry.getEntityAt(voxelPosition);
        return new HitResult(entityAt,hitPointWorld,hitNormalWorld,voxelPosition);
      }
 else {
        logger.warn("Unidentified object was hit in the physics engine: {}",collisionObject.userData);
      }
    }
  }
 else {
    callback.dispose();
  }
  return new HitResult();
}
@Override public HitResult rayTrace(Vector3f from,Vector3f direction,float distance,Set<EntityRef> excludedEntities,CollisionGroup... collisionGroups){
  if (excludedEntities == null || excludedEntities.size() == 0) {
    return rayTrace(from,direction,distance,collisionGroups);
  }
  Vector3f to=new Vector3f(direction);
  to.normalize();
  to.mul(distance);
  to.add(from);
  short filter=combineGroups(collisionGroups);
  Set<Integer> excludedCollisionIds=Sets.newHashSet();
  for (  EntityRef excludedEntity : excludedEntities) {
    if (entityRigidBodies.containsKey(excludedEntity)) {
      excludedCollisionIds.add(entityRigidBodies.get(excludedEntity).rb.getBroadphaseHandle().getUid());
    }
    if (entityColliders.containsKey(excludedEntity)) {
      excludedCollisionIds.add(entityColliders.get(excludedEntity).collider.getBroadphaseHandle().getUid());
    }
    if (entityTriggers.containsKey(excludedEntity)) {
      excludedCollisionIds.add(entityTriggers.get(excludedEntity).getBroadphaseHandle().getUid());
    }
  }
  AllHitsRayResultCallback callback=new AllHitsRayResultCallback(from,to);
  callback.setCollisionFilterGroup(StandardCollisionGroup.ALL.getFlag());
  callback.setCollisionFilterMask(filter);
  discreteDynamicsWorld.rayTest(from,to,callback);
  if (callback.hasHit()) {
    btCollisionObjectConstArray collisionObjects=callback.getCollisionObjects();
    for (int x=0; x < collisionObjects.size(); x++) {
      btCollisionObject collisionObject=collisionObjects.atConst(x);
      if (!excludedCollisionIds.contains(collisionObject.getBroadphaseHandle().getUid())) {
        Vector3f hitPointWorld=callback.getHitPointWorld().at(x);
        Vector3f hitNormalWorld=callback.getHitNormalWorld().at(x);
        callback.dispose();
        if (collisionObject.userData instanceof EntityRef) {
          return new HitResult((EntityRef)collisionObject.userData,hitPointWorld,hitNormalWorld);
        }
 else         if ((collisionObject.getCollisionFlags() & btCollisionObject.CollisionFlags.CF_VOXEL_OBJECT) > 0) {
          btVector3i pos=new btVector3i();
          collisionObject.getVoxelPosition(pos);
          Vector3i voxelPosition=new Vector3i(pos.getX(),pos.getY(),pos.getZ());
          final EntityRef entityAt=blockEntityRegistry.getEntityAt(voxelPosition);
          return new HitResult(entityAt,hitPointWorld,hitNormalWorld,voxelPosition);
        }
 else {
          logger.warn("Unidentified object was hit in the physics engine: {}",collisionObject.userData);
        }
      }
    }
  }
 else {
    callback.dispose();
  }
  return new HitResult();
}
