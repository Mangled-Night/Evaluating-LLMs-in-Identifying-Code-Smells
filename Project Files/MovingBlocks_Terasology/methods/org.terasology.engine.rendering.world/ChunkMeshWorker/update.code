/** 
 * Queue all dirty items in our collection, in priority order.
 * @return the number of dirty chunks added to the queue
 */
public int update(){
  int statDirtyChunks=0;
  chunksInProximityOfCamera.sort(frontToBackComparator);
  for (  Chunk chunk : chunksInProximityOfCamera) {
    if (!chunk.isReady()) {
      continue;
    }
    if (!chunk.isDirty()) {
      continue;
    }
    statDirtyChunks++;
    Sinks.EmitResult result=chunkMeshPublisher.tryEmitNext(chunk);
    if (result.isFailure()) {
      logger.error("failed to process chunk {} : {}",chunk,result);
    }
  }
  return statDirtyChunks;
}
