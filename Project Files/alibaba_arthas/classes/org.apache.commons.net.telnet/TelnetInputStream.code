final class TelnetInputStream extends BufferedInputStream implements Runnable {
  /** 
 * End of file has been reached 
 */
  private static final int EOF=-1;
  /** 
 * Read would block 
 */
  private static final int WOULD_BLOCK=-2;
  static final int _STATE_DATA=0, _STATE_IAC=1, _STATE_WILL=2, _STATE_WONT=3, _STATE_DO=4, _STATE_DONT=5, _STATE_SB=6, _STATE_SE=7, _STATE_CR=8, _STATE_IAC_SB=9;
  private boolean __hasReachedEOF;
  private volatile boolean __isClosed;
  private boolean __readIsWaiting;
  private int __receiveState, __queueHead, __queueTail, __bytesAvailable;
  private final int[] __queue;
  private final TelnetClient __client;
  private final Thread __thread;
  private IOException __ioException;
  private final int __suboption[]=new int[512];
  private int __suboption_count=0;
  private volatile boolean __threaded;
  TelnetInputStream(  InputStream input,  TelnetClient client,  boolean readerThread){
    super(input);
    __client=client;
    __receiveState=_STATE_DATA;
    __isClosed=true;
    __hasReachedEOF=false;
    __queue=new int[2049];
    __queueHead=0;
    __queueTail=0;
    __bytesAvailable=0;
    __ioException=null;
    __readIsWaiting=false;
    __threaded=false;
    if (readerThread) {
      __thread=new Thread(this);
    }
 else {
      __thread=null;
    }
  }
  TelnetInputStream(  InputStream input,  TelnetClient client){
    this(input,client,true);
  }
  void _start(){
    if (__thread == null) {
      return;
    }
    int priority;
    __isClosed=false;
    priority=Thread.currentThread().getPriority() + 1;
    if (priority > Thread.MAX_PRIORITY) {
      priority=Thread.MAX_PRIORITY;
    }
    __thread.setPriority(priority);
    __thread.setDaemon(true);
    __thread.start();
    __threaded=true;
  }
  /** 
 * Get the next byte of data. IAC commands are processed internally and do not return data.
 * @param mayBlock true if method is allowed to block
 * @return the next byte of data,or -1 (EOF) if end of stread reached, or -2 (WOULD_BLOCK) if mayBlock is false and there is no data available
 */
  private int __read(  boolean mayBlock) throws IOException {
    int ch;
    while (true) {
      if (!mayBlock && super.available() == 0) {
        return WOULD_BLOCK;
      }
      if ((ch=super.read()) < 0) {
        return EOF;
      }
      ch=(ch & 0xff);
synchronized (__client) {
        __client._processAYTResponse();
      }
      __client._spyRead(ch);
switch (__receiveState) {
case _STATE_CR:
        if (ch == '\0') {
          continue;
        }
case _STATE_DATA:
      if (ch == TelnetCommand.IAC) {
        __receiveState=_STATE_IAC;
        continue;
      }
    if (ch == '\r') {
synchronized (__client) {
        if (__client._requestedDont(TelnetOption.BINARY)) {
          __receiveState=_STATE_CR;
        }
 else {
          __receiveState=_STATE_DATA;
        }
      }
    }
 else {
      __receiveState=_STATE_DATA;
    }
  break;
case _STATE_IAC:
switch (ch) {
case TelnetCommand.WILL:
  __receiveState=_STATE_WILL;
continue;
case TelnetCommand.WONT:
__receiveState=_STATE_WONT;
continue;
case TelnetCommand.DO:
__receiveState=_STATE_DO;
continue;
case TelnetCommand.DONT:
__receiveState=_STATE_DONT;
continue;
case TelnetCommand.SB:
__suboption_count=0;
__receiveState=_STATE_SB;
continue;
case TelnetCommand.IAC:
__receiveState=_STATE_DATA;
break;
case TelnetCommand.SE:
__receiveState=_STATE_DATA;
continue;
default :
__receiveState=_STATE_DATA;
__client._processCommand(ch);
continue;
}
break;
case _STATE_WILL:
synchronized (__client) {
__client._processWill(ch);
__client._flushOutputStream();
}
__receiveState=_STATE_DATA;
continue;
case _STATE_WONT:
synchronized (__client) {
__client._processWont(ch);
__client._flushOutputStream();
}
__receiveState=_STATE_DATA;
continue;
case _STATE_DO:
synchronized (__client) {
__client._processDo(ch);
__client._flushOutputStream();
}
__receiveState=_STATE_DATA;
continue;
case _STATE_DONT:
synchronized (__client) {
__client._processDont(ch);
__client._flushOutputStream();
}
__receiveState=_STATE_DATA;
continue;
case _STATE_SB:
switch (ch) {
case TelnetCommand.IAC:
__receiveState=_STATE_IAC_SB;
continue;
default :
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++]=ch;
}
break;
}
__receiveState=_STATE_SB;
continue;
case _STATE_IAC_SB:
switch (ch) {
case TelnetCommand.SE:
synchronized (__client) {
__client._processSuboption(__suboption,__suboption_count);
__client._flushOutputStream();
}
__receiveState=_STATE_DATA;
continue;
case TelnetCommand.IAC:
if (__suboption_count < __suboption.length) {
__suboption[__suboption_count++]=ch;
}
break;
default :
break;
}
__receiveState=_STATE_SB;
continue;
}
break;
}
return ch;
}
private boolean __processChar(int ch) throws InterruptedException {
boolean bufferWasEmpty;
synchronized (__queue) {
bufferWasEmpty=(__bytesAvailable == 0);
while (__bytesAvailable >= __queue.length - 1) {
if (__threaded) {
__queue.notify();
try {
__queue.wait();
}
 catch (InterruptedException e) {
throw e;
}
}
 else {
throw new IllegalStateException("Queue is full! Cannot process another character.");
}
}
if (__readIsWaiting && __threaded) {
__queue.notify();
}
__queue[__queueTail]=ch;
++__bytesAvailable;
if (++__queueTail >= __queue.length) {
__queueTail=0;
}
}
return bufferWasEmpty;
}
@Override public int read() throws IOException {
synchronized (__queue) {
while (true) {
if (__ioException != null) {
IOException e;
e=__ioException;
__ioException=null;
throw e;
}
if (__bytesAvailable == 0) {
if (__hasReachedEOF) {
return EOF;
}
if (__threaded) {
__queue.notify();
try {
__readIsWaiting=true;
__queue.wait();
__readIsWaiting=false;
}
 catch (InterruptedException e) {
throw new InterruptedIOException("Fatal thread interruption during read.");
}
}
 else {
__readIsWaiting=true;
int ch;
boolean mayBlock=true;
do {
try {
if ((ch=__read(mayBlock)) < 0) {
if (ch != WOULD_BLOCK) {
return (ch);
}
}
}
 catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException=e;
__queue.notifyAll();
try {
__queue.wait(100);
}
 catch (InterruptedException interrupted) {
}
}
return EOF;
}
try {
if (ch != WOULD_BLOCK) {
__processChar(ch);
}
}
 catch (InterruptedException e) {
if (__isClosed) {
return EOF;
}
}
mayBlock=false;
}
 while (super.available() > 0 && __bytesAvailable < __queue.length - 1);
__readIsWaiting=false;
}
continue;
}
 else {
int ch;
ch=__queue[__queueHead];
if (++__queueHead >= __queue.length) {
__queueHead=0;
}
--__bytesAvailable;
if (__bytesAvailable == 0 && __threaded) {
__queue.notify();
}
return ch;
}
}
}
}
/** 
 * Reads the next number of bytes from the stream into an array and returns the number of bytes read.  Returns -1 if the end of the stream has been reached. <p>
 * @param buffer  The byte array in which to store the data.
 * @return The number of bytes read. Returns -1 if theend of the message has been reached.
 * @exception IOException If an error occurs in reading the underlyingstream.
 */
@Override public int read(byte buffer[]) throws IOException {
return read(buffer,0,buffer.length);
}
/** 
 * Reads the next number of bytes from the stream into an array and returns the number of bytes read.  Returns -1 if the end of the message has been reached.  The characters are stored in the array starting from the given offset and up to the length specified. <p>
 * @param buffer The byte array in which to store the data.
 * @param offset  The offset into the array at which to start storing data.
 * @param length   The number of bytes to read.
 * @return The number of bytes read. Returns -1 if theend of the stream has been reached.
 * @exception IOException If an error occurs while reading the underlyingstream.
 */
@Override public int read(byte buffer[],int offset,int length) throws IOException {
int ch, off;
if (length < 1) {
return 0;
}
synchronized (__queue) {
if (length > __bytesAvailable) {
length=__bytesAvailable;
}
}
if ((ch=read()) == EOF) {
return EOF;
}
off=offset;
do {
buffer[offset++]=(byte)ch;
}
 while (--length > 0 && (ch=read()) != EOF);
return (offset - off);
}
/** 
 * Returns false.  Mark is not supported. 
 */
@Override public boolean markSupported(){
return false;
}
@Override public int available() throws IOException {
synchronized (__queue) {
if (__threaded) {
return __bytesAvailable;
}
 else {
return __bytesAvailable + super.available();
}
}
}
@Override public void close() throws IOException {
super.close();
synchronized (__queue) {
__hasReachedEOF=true;
__isClosed=true;
if (__thread != null && __thread.isAlive()) {
__thread.interrupt();
}
__queue.notifyAll();
}
}
@Override public void run(){
int ch;
try {
_outerLoop: while (!__isClosed) {
try {
if ((ch=__read(true)) < 0) {
break;
}
}
 catch (InterruptedIOException e) {
synchronized (__queue) {
__ioException=e;
__queue.notifyAll();
try {
__queue.wait(100);
}
 catch (InterruptedException interrupted) {
if (__isClosed) {
break _outerLoop;
}
}
continue;
}
}
catch (RuntimeException re) {
super.close();
break _outerLoop;
}
boolean notify=false;
try {
notify=__processChar(ch);
}
 catch (InterruptedException e) {
if (__isClosed) {
break _outerLoop;
}
}
if (notify) {
__client.notifyInputListener();
}
}
}
 catch (IOException ioe) {
synchronized (__queue) {
__ioException=ioe;
}
__client.notifyInputListener();
}
synchronized (__queue) {
__isClosed=true;
__hasReachedEOF=true;
__queue.notify();
}
__threaded=false;
}
}
