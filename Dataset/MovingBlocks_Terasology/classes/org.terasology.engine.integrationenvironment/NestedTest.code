/** 
 * Test the behavior of  {@code @Nested} tests.<p> This uses the default  {@code PER_METHOD} lifecycle.<p> ðŸš§ Combining nested tests with a  {@code PER_CLASS} lifecycle complicates thingssignificantly, as there's no longer just one class. It may even be possible to use different lifecycles for inner and outer classes. <p> ðŸš§ If do need that functionality, please contribute test cases.
 * @see <a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-nested"
 *     >JUnit User Guide: Nested Tests</a>
 */
@IntegrationEnvironment public class NestedTest {
  @In public Engines outerEngines;
  @In public EntityManager outerManager;
  @Test public void outerTestHasFieldInjection(){
    assertThat(outerEngines).isNotNull();
    assertThat(outerManager).isNotNull();
  }
@Nested class NestedTestClass {
    @In Engines innerEngines;
    @In EntityManager innerManager;
    @Test public void outerFieldsInjectedForInnerTest(){
      assertThat(outerEngines).isNotNull();
      assertThat(outerManager).isNotNull();
    }
    @Test public void innerFieldsInjectedSameAsOuterFields(){
      assertThat(innerManager).isSameInstanceAs(outerManager);
      assertThat(innerEngines).isSameInstanceAs(outerEngines);
    }
  }
}
