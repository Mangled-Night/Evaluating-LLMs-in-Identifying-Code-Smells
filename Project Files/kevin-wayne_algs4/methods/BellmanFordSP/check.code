private boolean check(EdgeWeightedDigraph G,int s){
  if (hasNegativeCycle()) {
    double weight=0.0;
    for (    DirectedEdge e : negativeCycle()) {
      weight+=e.weight();
    }
    if (weight >= 0.0) {
      System.err.println("error: weight of negative cycle = " + weight);
      return false;
    }
  }
 else {
    if (distTo[s] != 0.0 || edgeTo[s] != null) {
      System.err.println("distanceTo[s] and edgeTo[s] inconsistent");
      return false;
    }
    for (int v=0; v < G.V(); v++) {
      if (v == s)       continue;
      if (edgeTo[v] == null && distTo[v] != Double.POSITIVE_INFINITY) {
        System.err.println("distTo[] and edgeTo[] inconsistent");
        return false;
      }
    }
    for (int v=0; v < G.V(); v++) {
      for (      DirectedEdge e : G.adj(v)) {
        int w=e.to();
        if (distTo[v] + e.weight() < distTo[w]) {
          System.err.println("edge " + e + " not relaxed");
          return false;
        }
      }
    }
    for (int w=0; w < G.V(); w++) {
      if (edgeTo[w] == null)       continue;
      DirectedEdge e=edgeTo[w];
      int v=e.from();
      if (w != e.to())       return false;
      if (distTo[v] + e.weight() != distTo[w]) {
        System.err.println("edge " + e + " on shortest path not tight");
        return false;
      }
    }
  }
  StdOut.println("Satisfies optimality conditions");
  StdOut.println();
  return true;
}
