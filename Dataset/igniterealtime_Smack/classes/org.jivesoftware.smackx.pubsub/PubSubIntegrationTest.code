public class PubSubIntegrationTest extends AbstractSmackIntegrationTest {
  private final PubSubManager pubSubManagerOne;
  public PubSubIntegrationTest(  SmackIntegrationTestEnvironment environment) throws TestNotPossibleException, NoResponseException, XMPPErrorException, NotConnectedException, InterruptedException {
    super(environment);
    DomainBareJid pubSubService=PubSubManager.getPubSubService(conOne);
    if (pubSubService == null) {
      throw new TestNotPossibleException("No PubSub service found");
    }
    pubSubManagerOne=PubSubManager.getInstanceFor(conOne,pubSubService);
    if (!pubSubManagerOne.canCreateNodesAndPublishItems()) {
      throw new TestNotPossibleException("PubSub service does not allow node creation");
    }
  }
  /** 
 * Asserts that an event notification (publication without item) can be published to a node that is both 'notification-only' as well as 'transient'.
 * @throws NoResponseException if there was no response from the remote entity.
 * @throws XMPPErrorException if there was an XMPP error returned.
 * @throws NotConnectedException if the XMPP connection is not connected.
 * @throws InterruptedException if the calling thread was interrupted.
 */
  @SmackIntegrationTest public void transientNotificationOnlyNodeWithoutItemTest() throws NoResponseException, XMPPErrorException, NotConnectedException, InterruptedException {
    final String nodename="sinttest-transient-notificationonly-withoutitem-nodename-" + testRunId;
    ConfigureForm defaultConfiguration=pubSubManagerOne.getDefaultConfiguration();
    FillableConfigureForm config=defaultConfiguration.getFillableForm();
    config.setDeliverPayloads(false);
    config.setPersistentItems(false);
    Node node=pubSubManagerOne.createNode(nodename,config);
    try {
      LeafNode leafNode=(LeafNode)node;
      leafNode.publish();
    }
  finally {
      pubSubManagerOne.deleteNode(nodename);
    }
  }
  /** 
 * Asserts that an error is returned when a publish request to a node that is both 'notification-only' as well as 'transient' contains an item element. <p>From XEP-0060 ยง 7.1.3.6:</p> <blockquote> If the event type is notification + transient and the publisher provides an item, the service MUST bounce the publication request with a &lt;bad-request/&gt; error and a pubsub-specific error condition of &lt;item-forbidden/&gt;. </blockquote>
 * @throws NoResponseException if there was no response from the remote entity.
 * @throws XMPPErrorException if there was an XMPP error returned.
 * @throws NotConnectedException if the XMPP connection is not connected.
 * @throws InterruptedException if the calling thread was interrupted.
 * @see <a href="https://xmpp.org/extensions/xep-0060.html#publisher-publish-error-badrequest">
     *     7.1.3.6 Request Does Not Match Configuration</a>
 */
  @SmackIntegrationTest public void transientNotificationOnlyNodeWithItemTest() throws NoResponseException, XMPPErrorException, NotConnectedException, InterruptedException {
    final String nodename="sinttest-transient-notificationonly-withitem-nodename-" + testRunId;
    final String itemId="sinttest-transient-notificationonly-withitem-itemid-" + testRunId;
    ConfigureForm defaultConfiguration=pubSubManagerOne.getDefaultConfiguration();
    FillableConfigureForm config=defaultConfiguration.getFillableForm();
    config.setDeliverPayloads(false);
    config.setPersistentItems(false);
    Node node=pubSubManagerOne.createNode(nodename,config);
    final StandardExtensionElement dummyPayload=StandardExtensionElement.builder("dummy-payload",SmackConfiguration.SMACK_URL_STRING).setText(testRunId).build();
    try {
      XMPPErrorException e=assertThrows(XMPPErrorException.class,() -> {
        LeafNode leafNode=(LeafNode)node;
        Item item=new PayloadItem<>(itemId,dummyPayload);
        leafNode.publish(item);
      }
);
      assertEquals(StanzaError.Type.MODIFY,e.getStanzaError().getType());
      assertNotNull(e.getStanzaError().getExtension("item-forbidden","http://jabber.org/protocol/pubsub#errors"));
    }
  finally {
      pubSubManagerOne.deleteNode(nodename);
    }
  }
}
