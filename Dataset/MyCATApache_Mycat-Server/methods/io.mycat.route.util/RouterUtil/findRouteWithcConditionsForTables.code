/** 
 * 处理分库表路由
 */
public static void findRouteWithcConditionsForTables(SchemaConfig schema,RouteResultset rrs,Map<String,Map<String,Set<ColumnRoutePair>>> tablesAndConditions,Map<String,Set<String>> tablesRouteMap,String sql,LayerCachePool cachePool,boolean isSelect) throws SQLNonTransientException {
  for (  Map.Entry<String,Map<String,Set<ColumnRoutePair>>> entry : tablesAndConditions.entrySet()) {
    String tableName=entry.getKey().toUpperCase();
    TableConfig tableConfig=schema.getTables().get(tableName);
    if (tableConfig == null) {
      String msg="can't find table define in schema " + tableName + " schema:"+ schema.getName();
      LOGGER.warn(msg);
      throw new SQLNonTransientException(msg);
    }
    if (tableConfig.getDistTables() != null && tableConfig.getDistTables().size() > 0) {
      routeToDistTableNode(schema,rrs,sql,tablesAndConditions,cachePool,isSelect,entry);
    }
    if (tableConfig.isGlobalTable() || schema.getTables().get(tableName).getDataNodes().size() == 1) {
      continue;
    }
 else {
      Map<String,Set<ColumnRoutePair>> columnsMap=entry.getValue();
      String joinKey=tableConfig.getJoinKey();
      String partionCol=tableConfig.getPartitionColumn();
      String primaryKey=tableConfig.getPrimaryKey();
      boolean isFoundPartitionValue=partionCol != null && entry.getValue().get(partionCol) != null;
      boolean isLoadData=false;
      if (LOGGER.isDebugEnabled() && sql.startsWith(LoadData.loadDataHint) || rrs.isLoadData()) {
        isLoadData=true;
      }
      if (entry.getValue().get(primaryKey) != null && entry.getValue().size() == 1 && !isLoadData) {
        Set<ColumnRoutePair> primaryKeyPairs=entry.getValue().get(primaryKey);
        if (primaryKeyPairs != null) {
          if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("try to find cache by primary key ");
          }
          String tableKey=schema.getName() + '_' + tableName;
          tableKey=tableKey.toUpperCase();
          boolean allFound=true;
          for (          ColumnRoutePair pair : primaryKeyPairs) {
            String cacheKey=pair.colValue;
            String dataNode=(String)cachePool.get(tableKey,cacheKey);
            if (dataNode == null) {
              allFound=false;
              continue;
            }
 else {
              if (tablesRouteMap.get(tableName) == null) {
                tablesRouteMap.put(tableName,new HashSet<String>());
              }
              tablesRouteMap.get(tableName).add(dataNode);
              continue;
            }
          }
          if (!allFound) {
            if (isSelect && tableConfig.getPrimaryKey() != null) {
              rrs.setPrimaryKey(tableKey + '.' + tableConfig.getPrimaryKey());
            }
          }
 else {
            continue;
          }
        }
      }
      if (isFoundPartitionValue) {
        tablesRouteMap.clear();
        Set<ColumnRoutePair> partitionValue=columnsMap.get(partionCol);
        if (partitionValue == null || partitionValue.size() == 0) {
          if (tablesRouteMap.get(tableName) == null) {
            tablesRouteMap.put(tableName,new HashSet<String>());
          }
          tablesRouteMap.get(tableName).addAll(tableConfig.getDataNodes());
        }
 else {
          for (          ColumnRoutePair pair : partitionValue) {
            AbstractPartitionAlgorithm algorithm=tableConfig.getRule().getRuleAlgorithm();
            if (pair.colValue != null) {
              Integer nodeIndex=algorithm.calculate(StringUtil.removeBackquote(pair.colValue));
              if (nodeIndex == null) {
                String msg="can't find any valid datanode :" + tableConfig.getName() + " -> "+ tableConfig.getPartitionColumn()+ " -> "+ pair.colValue;
                LOGGER.warn(msg);
                throw new SQLNonTransientException(msg);
              }
              ArrayList<String> dataNodes=tableConfig.getDataNodes();
              String node;
              if (nodeIndex >= 0 && nodeIndex < dataNodes.size()) {
                node=dataNodes.get(nodeIndex);
              }
 else {
                node=null;
                String msg="Can't find a valid data node for specified node index :" + tableConfig.getName() + " -> "+ tableConfig.getPartitionColumn()+ " -> "+ pair.colValue+ " -> "+ "Index : "+ nodeIndex;
                LOGGER.warn(msg);
                throw new SQLNonTransientException(msg);
              }
              if (node != null) {
                if (tablesRouteMap.get(tableName) == null) {
                  tablesRouteMap.put(tableName,new HashSet<String>());
                }
                if (algorithm instanceof SlotFunction) {
                  rrs.getDataNodeSlotMap().put(node,((SlotFunction)algorithm).slotValue());
                }
                tablesRouteMap.get(tableName).add(node);
              }
            }
            if (pair.rangeValue != null) {
              Integer[] nodeIndexs=algorithm.calculateRange(pair.rangeValue.beginValue.toString(),pair.rangeValue.endValue.toString());
              ArrayList<String> dataNodes=tableConfig.getDataNodes();
              String node;
              for (              Integer idx : nodeIndexs) {
                if (idx >= 0 && idx < dataNodes.size()) {
                  node=dataNodes.get(idx);
                }
 else {
                  String msg="Can't find valid data node(s) for some of specified node indexes :" + tableConfig.getName() + " -> "+ tableConfig.getPartitionColumn();
                  LOGGER.warn(msg);
                  throw new SQLNonTransientException(msg);
                }
                if (node != null) {
                  if (tablesRouteMap.get(tableName) == null) {
                    tablesRouteMap.put(tableName,new HashSet<String>());
                  }
                  if (algorithm instanceof SlotFunction) {
                    rrs.getDataNodeSlotMap().put(node,((SlotFunction)algorithm).slotValue());
                  }
                  tablesRouteMap.get(tableName).add(node);
                }
              }
            }
          }
        }
      }
 else       if (joinKey != null && columnsMap.get(joinKey) != null && columnsMap.get(joinKey).size() != 0) {
        Set<ColumnRoutePair> joinKeyValue=columnsMap.get(joinKey);
        Set<String> dataNodeSet=ruleByJoinValueCalculate(rrs,tableConfig,joinKeyValue);
        if (dataNodeSet.isEmpty()) {
          throw new SQLNonTransientException("parent key can't find any valid datanode ");
        }
        if (LOGGER.isDebugEnabled()) {
          LOGGER.debug("found partion nodes (using parent partion rule directly) for child table to update  " + Arrays.toString(dataNodeSet.toArray()) + " sql :"+ sql);
        }
        if (dataNodeSet.size() > 1) {
          routeToMultiNode(rrs.isCacheAble(),rrs,dataNodeSet,sql);
          rrs.setFinishedRoute(true);
          return;
        }
 else {
          rrs.setCacheAble(true);
          routeToSingleNode(rrs,dataNodeSet.iterator().next(),sql);
          return;
        }
      }
 else {
        if (tablesRouteMap.get(tableName) == null) {
          tablesRouteMap.put(tableName,new HashSet<String>());
        }
        boolean isSlotFunction=tableConfig.getRule() != null && tableConfig.getRule().getRuleAlgorithm() instanceof SlotFunction;
        if (isSlotFunction) {
          for (          String dn : tableConfig.getDataNodes()) {
            rrs.getDataNodeSlotMap().put(dn,-1);
          }
        }
        tablesRouteMap.get(tableName).addAll(tableConfig.getDataNodes());
      }
    }
  }
}
