/** 
 * Return the bytes of RSA encryption or decryption.
 * @param data           The data.
 * @param key            The key.
 * @param keySize        The size of key, e.g. 1024, 2048...
 * @param transformation The name of the transformation, e.g., <i>DES/CBC/PKCS1Padding</i>.
 * @param isEncrypt      True to encrypt, false otherwise.
 * @return the bytes of RSA encryption or decryption
 */
private static byte[] rsaTemplate(final byte[] data,final byte[] key,final int keySize,final String transformation,final boolean isEncrypt){
  if (data == null || data.length == 0 || key == null || key.length == 0) {
    return null;
  }
  try {
    Key rsaKey;
    KeyFactory keyFactory;
    if (Build.VERSION.SDK_INT < 28) {
      keyFactory=KeyFactory.getInstance("RSA","BC");
    }
 else {
      keyFactory=KeyFactory.getInstance("RSA");
    }
    if (isEncrypt) {
      X509EncodedKeySpec keySpec=new X509EncodedKeySpec(key);
      rsaKey=keyFactory.generatePublic(keySpec);
    }
 else {
      PKCS8EncodedKeySpec keySpec=new PKCS8EncodedKeySpec(key);
      rsaKey=keyFactory.generatePrivate(keySpec);
    }
    if (rsaKey == null)     return null;
    Cipher cipher=Cipher.getInstance(transformation);
    cipher.init(isEncrypt ? Cipher.ENCRYPT_MODE : Cipher.DECRYPT_MODE,rsaKey);
    int len=data.length;
    int maxLen=keySize / 8;
    if (isEncrypt) {
      String lowerTrans=transformation.toLowerCase();
      if (lowerTrans.endsWith("pkcs1padding")) {
        maxLen-=11;
      }
    }
    int count=len / maxLen;
    if (count > 0) {
      byte[] ret=new byte[0];
      byte[] buff=new byte[maxLen];
      int index=0;
      for (int i=0; i < count; i++) {
        System.arraycopy(data,index,buff,0,maxLen);
        ret=joins(ret,cipher.doFinal(buff));
        index+=maxLen;
      }
      if (index != len) {
        int restLen=len - index;
        buff=new byte[restLen];
        System.arraycopy(data,index,buff,0,restLen);
        ret=joins(ret,cipher.doFinal(buff));
      }
      return ret;
    }
 else {
      return cipher.doFinal(data);
    }
  }
 catch (  Exception e) {
    e.printStackTrace();
  }
  return null;
}
