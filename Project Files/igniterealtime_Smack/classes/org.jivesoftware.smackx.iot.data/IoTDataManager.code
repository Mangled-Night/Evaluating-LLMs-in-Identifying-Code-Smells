/** 
 * A manager for XEP-0323: Internet of Things - Sensor Data.
 * @author Florian Schmaus {@literal <flo@geekplace.eu>}
 * @see <a href="http://xmpp.org/extensions/xep-0323.html">XEP-0323: Internet of Things - Sensor Data</a>
 */
public final class IoTDataManager extends IoTManager {
  private static final Logger LOGGER=Logger.getLogger(IoTDataManager.class.getName());
  private static final Map<XMPPConnection,IoTDataManager> INSTANCES=new WeakHashMap<>();
static {
    XMPPConnectionRegistry.addConnectionCreationListener(new ConnectionCreationListener(){
      @Override public void connectionCreated(      XMPPConnection connection){
        if (!isAutoEnableActive())         return;
        getInstanceFor(connection);
      }
    }
);
  }
  /** 
 * Get the manger instance responsible for the given connection.
 * @param connection the XMPP connection.
 * @return a manager instance.
 */
  public static synchronized IoTDataManager getInstanceFor(  XMPPConnection connection){
    IoTDataManager manager=INSTANCES.get(connection);
    if (manager == null) {
      manager=new IoTDataManager(connection);
      INSTANCES.put(connection,manager);
    }
    return manager;
  }
  private final AtomicInteger nextSeqNr=new AtomicInteger();
  private final Map<NodeInfo,Thing> things=new ConcurrentHashMap<>();
  private IoTDataManager(  XMPPConnection connection){
    super(connection);
    connection.registerIQRequestHandler(new IoTIqRequestHandler(IoTDataRequest.ELEMENT,IoTDataRequest.NAMESPACE,IQ.Type.get,Mode.async){
      @Override public IQ handleIoTIqRequest(      IQ iqRequest){
        final IoTDataRequest dataRequest=(IoTDataRequest)iqRequest;
        if (!dataRequest.isMomentary()) {
          return null;
        }
        final Thing thing=things.get(NodeInfo.EMPTY);
        if (thing == null) {
          return null;
        }
        ThingMomentaryReadOutRequest readOutRequest=thing.getMomentaryReadOutRequestHandler();
        if (readOutRequest == null) {
          return null;
        }
        readOutRequest.momentaryReadOutRequest(new ThingMomentaryReadOutResult(){
          @Override public void momentaryReadOut(          List<? extends IoTDataField> results){
            IoTFieldsExtension iotFieldsExtension=IoTFieldsExtension.buildFor(dataRequest.getSequenceNr(),true,thing.getNodeInfo(),results);
            XMPPConnection connection=connection();
            Message message=connection.getStanzaFactory().buildMessageStanza().to(dataRequest.getFrom()).addExtension(iotFieldsExtension).build();
            try {
              connection.sendStanza(message);
            }
 catch (            NotConnectedException|InterruptedException e) {
              LOGGER.log(Level.SEVERE,"Could not send read-out response " + message,e);
            }
          }
        }
);
        return new IoTDataReadOutAccepted(dataRequest);
      }
    }
);
  }
  /** 
 * Install a thing in the manager. Activates data read out functionality (if provided by the thing).
 * @param thing the thing to install.
 */
  public void installThing(  Thing thing){
    things.put(thing.getNodeInfo(),thing);
  }
  public Thing uninstallThing(  Thing thing){
    return uninstallThing(thing.getNodeInfo());
  }
  public Thing uninstallThing(  NodeInfo nodeInfo){
    return things.remove(nodeInfo);
  }
  /** 
 * Try to read out a things momentary values.
 * @param jid the full JID of the thing to read data from.
 * @return a list with the read out data.
 * @throws NoResponseException if there was no response from the remote entity.
 * @throws XMPPErrorException if there was an XMPP error returned.
 * @throws NotConnectedException if the XMPP connection is not connected.
 * @throws InterruptedException if the calling thread was interrupted.
 */
  public List<IoTFieldsExtension> requestMomentaryValuesReadOut(  EntityFullJid jid) throws NoResponseException, XMPPErrorException, NotConnectedException, InterruptedException {
    final XMPPConnection connection=connection();
    final int seqNr=nextSeqNr.incrementAndGet();
    IoTDataRequest iotDataRequest=new IoTDataRequest(seqNr,true);
    iotDataRequest.setTo(jid);
    StanzaFilter doneFilter=new IoTFieldsExtensionFilter(seqNr,true);
    StanzaFilter dataFilter=new IoTFieldsExtensionFilter(seqNr,false);
    StanzaCollector doneCollector=connection.createStanzaCollector(doneFilter);
    StanzaCollector.Configuration dataCollectorConfiguration=StanzaCollector.newConfiguration().setStanzaFilter(dataFilter).setCollectorToReset(doneCollector);
    StanzaCollector dataCollector=connection.createStanzaCollector(dataCollectorConfiguration);
    try {
      connection.sendIqRequestAndWaitForResponse(iotDataRequest);
      doneCollector.nextResult();
    }
  finally {
      dataCollector.cancel();
    }
    int collectedCount=dataCollector.getCollectedCount();
    List<IoTFieldsExtension> res=new ArrayList<>(collectedCount);
    for (int i=0; i < collectedCount; i++) {
      Message message=dataCollector.pollResult();
      IoTFieldsExtension iotFieldsExtension=IoTFieldsExtension.from(message);
      res.add(iotFieldsExtension);
    }
    return res;
  }
}
