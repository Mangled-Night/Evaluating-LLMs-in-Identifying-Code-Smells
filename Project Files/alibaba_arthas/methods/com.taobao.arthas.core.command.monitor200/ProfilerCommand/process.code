@Override public void process(final CommandProcess process){
  try {
    ProfilerAction profilerAction=ProfilerAction.valueOf(action);
    if (ProfilerAction.actions.equals(profilerAction)) {
      process.appendResult(new ProfilerModel(actions()));
      process.end();
      return;
    }
    final AsyncProfiler asyncProfiler=this.profilerInstance();
    if (ProfilerAction.execute.equals(profilerAction)) {
      if (actionArg == null) {
        process.end(1,"actionArg can not be empty.");
        return;
      }
      String result=execute(asyncProfiler,this.actionArg);
      appendExecuteResult(process,result);
    }
 else     if (ProfilerAction.start.equals(profilerAction)) {
      if (this.file == null && "jfr".equals(format)) {
        this.file=outputFile();
      }
      String executeArgs=executeArgs(ProfilerAction.start);
      String result=execute(asyncProfiler,executeArgs);
      ProfilerModel profilerModel=createProfilerModel(result);
      if (this.duration != null) {
        final String outputFile=outputFile();
        profilerModel.setOutputFile(outputFile);
        profilerModel.setDuration(duration);
        ArthasBootstrap.getInstance().getScheduledExecutorService().schedule(new Runnable(){
          @Override public void run(){
            try {
              logger.info("stopping profiler ...");
              ProfilerModel model=processStop(asyncProfiler);
              logger.info("profiler output file: " + model.getOutputFile());
              logger.info("stop profiler successfully.");
            }
 catch (            Throwable e) {
              logger.error("stop profiler failure",e);
            }
          }
        }
,this.duration,TimeUnit.SECONDS);
      }
      process.appendResult(profilerModel);
    }
 else     if (ProfilerAction.stop.equals(profilerAction)) {
      ProfilerModel profilerModel=processStop(asyncProfiler);
      process.appendResult(profilerModel);
    }
 else     if (ProfilerAction.resume.equals(profilerAction)) {
      String executeArgs=executeArgs(ProfilerAction.resume);
      String result=execute(asyncProfiler,executeArgs);
      appendExecuteResult(process,result);
    }
 else     if (ProfilerAction.list.equals(profilerAction)) {
      String result=asyncProfiler.execute("list");
      appendExecuteResult(process,result);
    }
 else     if (ProfilerAction.version.equals(profilerAction)) {
      String result=asyncProfiler.execute("version");
      appendExecuteResult(process,result);
    }
 else     if (ProfilerAction.status.equals(profilerAction)) {
      String result=asyncProfiler.execute("status");
      appendExecuteResult(process,result);
    }
 else     if (ProfilerAction.dumpCollapsed.equals(profilerAction)) {
      if (actionArg == null) {
        actionArg="TOTAL";
      }
      actionArg=actionArg.toUpperCase();
      if ("TOTAL".equals(actionArg) || "SAMPLES".equals(actionArg)) {
        String result=asyncProfiler.dumpCollapsed(Counter.valueOf(actionArg));
        appendExecuteResult(process,result);
      }
 else {
        process.end(1,"ERROR: dumpCollapsed argumment should be TOTAL or SAMPLES. ");
        return;
      }
    }
 else     if (ProfilerAction.dumpFlat.equals(profilerAction)) {
      int maxMethods=0;
      if (actionArg != null) {
        maxMethods=Integer.valueOf(actionArg);
      }
      String result=asyncProfiler.dumpFlat(maxMethods);
      appendExecuteResult(process,result);
    }
 else     if (ProfilerAction.dumpTraces.equals(profilerAction)) {
      int maxTraces=0;
      if (actionArg != null) {
        maxTraces=Integer.valueOf(actionArg);
      }
      String result=asyncProfiler.dumpTraces(maxTraces);
      appendExecuteResult(process,result);
    }
 else     if (ProfilerAction.getSamples.equals(profilerAction)) {
      String result="" + asyncProfiler.getSamples() + "\n";
      appendExecuteResult(process,result);
    }
    process.end();
  }
 catch (  Throwable e) {
    logger.error("AsyncProfiler error",e);
    process.end(1,"AsyncProfiler error: " + e.getMessage());
  }
}
