/** 
 * Arthas Session Manager
 * @author gongdewei 2020-03-20
 */
public class SessionManagerImpl implements SessionManager {
  private static final Logger logger=LoggerFactory.getLogger(SessionManagerImpl.class);
  private final InternalCommandManager commandManager;
  private final Instrumentation instrumentation;
  private final JobController jobController;
  private final long sessionTimeoutMillis;
  private final int consumerTimeoutMillis;
  private final long reaperInterval;
  private final Map<String,Session> sessions;
  private final long pid;
  private boolean closed=false;
  private ScheduledExecutorService scheduledExecutorService;
  public SessionManagerImpl(  ShellServerOptions options,  InternalCommandManager commandManager,  JobController jobController){
    this.commandManager=commandManager;
    this.jobController=jobController;
    this.sessions=new ConcurrentHashMap<String,Session>();
    this.sessionTimeoutMillis=options.getSessionTimeout();
    this.consumerTimeoutMillis=5 * 60 * 1000;
    this.reaperInterval=options.getReaperInterval();
    this.instrumentation=options.getInstrumentation();
    this.pid=options.getPid();
    this.setEvictTimer();
  }
  @Override public Session createSession(){
    Session session=new SessionImpl();
    session.put(Session.COMMAND_MANAGER,commandManager);
    session.put(Session.INSTRUMENTATION,instrumentation);
    session.put(Session.PID,pid);
    String sessionId=UUID.randomUUID().toString();
    session.put(Session.ID,sessionId);
    sessions.put(sessionId,session);
    return session;
  }
  @Override public Session getSession(  String sessionId){
    return sessions.get(sessionId);
  }
  @Override public Session removeSession(  String sessionId){
    Session session=sessions.get(sessionId);
    if (session == null) {
      return null;
    }
    Job job=session.getForegroundJob();
    if (job != null) {
      job.interrupt();
    }
    SharingResultDistributor resultDistributor=session.getResultDistributor();
    if (resultDistributor != null) {
      resultDistributor.close();
    }
    return sessions.remove(sessionId);
  }
  @Override public void updateAccessTime(  Session session){
    session.setLastAccessTime(System.currentTimeMillis());
  }
  @Override public void close(){
    closed=true;
    if (scheduledExecutorService != null) {
      scheduledExecutorService.shutdownNow();
    }
    ArrayList<Session> sessions=new ArrayList<Session>(this.sessions.values());
    for (    Session session : sessions) {
      SharingResultDistributor resultDistributor=session.getResultDistributor();
      if (resultDistributor != null) {
        resultDistributor.appendResult(new MessageModel("arthas server is going to shutdown."));
      }
      logger.info("Removing session before shutdown: {}, last access time: {}",session.getSessionId(),session.getLastAccessTime());
      this.removeSession(session.getSessionId());
    }
    jobController.close();
  }
  private synchronized void setEvictTimer(){
    if (!closed && reaperInterval > 0) {
      scheduledExecutorService=Executors.newSingleThreadScheduledExecutor(new ThreadFactory(){
        @Override public Thread newThread(        Runnable r){
          final Thread t=new Thread(r,"arthas-session-manager");
          t.setDaemon(true);
          return t;
        }
      }
);
      scheduledExecutorService.scheduleAtFixedRate(new Runnable(){
        @Override public void run(){
          evictSessions();
        }
      }
,0,reaperInterval,TimeUnit.MILLISECONDS);
    }
  }
  /** 
 * Check and remove inactive session
 */
  public void evictSessions(){
    long now=System.currentTimeMillis();
    List<Session> toClose=new ArrayList<Session>();
    for (    Session session : sessions.values()) {
      if (now - session.getLastAccessTime() > sessionTimeoutMillis && session.getForegroundJob() == null) {
        toClose.add(session);
      }
      evictConsumers(session);
    }
    for (    Session session : toClose) {
      Job job=session.getForegroundJob();
      if (job != null) {
        job.interrupt();
      }
      long timeOutInMinutes=sessionTimeoutMillis / 1000 / 60;
      String reason="session is inactive for " + timeOutInMinutes + " min(s).";
      SharingResultDistributor resultDistributor=session.getResultDistributor();
      if (resultDistributor != null) {
        resultDistributor.appendResult(new MessageModel(reason));
      }
      this.removeSession(session.getSessionId());
      logger.info("Removing inactive session: {}, last access time: {}",session.getSessionId(),session.getLastAccessTime());
    }
  }
  /** 
 * Check and remove inactive consumer
 */
  public void evictConsumers(  Session session){
    SharingResultDistributor distributor=session.getResultDistributor();
    if (distributor != null) {
      List<ResultConsumer> consumers=distributor.getConsumers();
      long now=System.currentTimeMillis();
      for (      ResultConsumer consumer : consumers) {
        long inactiveTime=now - consumer.getLastAccessTime();
        if (inactiveTime > consumerTimeoutMillis) {
          logger.info("Removing inactive consumer from session, sessionId: {}, consumerId: {}, inactive duration: {}",session.getSessionId(),consumer.getConsumerId(),inactiveTime);
          consumer.appendResult(new MessageModel("consumer is inactive for a while, please refresh the page."));
          distributor.removeConsumer(consumer);
        }
      }
    }
  }
  @Override public InternalCommandManager getCommandManager(){
    return commandManager;
  }
  @Override public Instrumentation getInstrumentation(){
    return instrumentation;
  }
  @Override public JobController getJobController(){
    return jobController;
  }
}
