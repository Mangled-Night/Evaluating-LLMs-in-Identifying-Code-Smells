/** 
 * An asynchronous and thread-safe API for a Redis pub/sub connection.
 * @param < K > Key type.
 * @param < V > Value type.
 * @author Will Glozer
 * @author Mark Paluch
 */
public class RedisPubSubAsyncCommandsImpl<K,V> extends RedisAsyncCommandsImpl<K,V> implements RedisPubSubAsyncCommands<K,V> {
  private final PubSubCommandBuilder<K,V> commandBuilder;
  /** 
 * Initialize a new connection.
 * @param connection the connection .
 * @param codec Codec used to encode/decode keys and values.
 */
  public RedisPubSubAsyncCommandsImpl(  StatefulRedisPubSubConnection<K,V> connection,  RedisCodec<K,V> codec){
    super(connection,codec);
    this.commandBuilder=new PubSubCommandBuilder<>(codec);
  }
  @Override @SuppressWarnings("unchecked") public RedisFuture<Void> psubscribe(  K... patterns){
    return (RedisFuture<Void>)dispatch(commandBuilder.psubscribe(patterns));
  }
  @Override @SuppressWarnings("unchecked") public RedisFuture<Void> punsubscribe(  K... patterns){
    return (RedisFuture<Void>)dispatch(commandBuilder.punsubscribe(patterns));
  }
  @Override @SuppressWarnings("unchecked") public RedisFuture<Void> subscribe(  K... channels){
    return (RedisFuture<Void>)dispatch(commandBuilder.subscribe(channels));
  }
  @Override @SuppressWarnings("unchecked") public RedisFuture<Void> unsubscribe(  K... channels){
    return (RedisFuture<Void>)dispatch(commandBuilder.unsubscribe(channels));
  }
  @Override public RedisFuture<Long> publish(  K channel,  V message){
    return dispatch(commandBuilder.publish(channel,message));
  }
  @Override public RedisFuture<List<K>> pubsubChannels(  K channel){
    return dispatch(commandBuilder.pubsubChannels(channel));
  }
  @Override public RedisFuture<Map<K,Long>> pubsubNumsub(  K... channels){
    return dispatch(commandBuilder.pubsubNumsub(channels));
  }
  @Override @SuppressWarnings("unchecked") public StatefulRedisPubSubConnection<K,V> getStatefulConnection(){
    return (StatefulRedisPubSubConnection<K,V>)super.getStatefulConnection();
  }
}
