private Map<?,Field> buildMap(Class<?> cls,boolean tupleKeyed){
  final String clsName=cls.getName();
  if (!nameCache.containsKey(clsName)) {
synchronized (keyCache) {
      if (!nameCache.containsKey(clsName)) {
        final Map<String,Field> keyedByFieldName=new HashMap<String,Field>();
        final Map<FieldKey,Field> keyedByFieldKey=new OrderRetainingMap<FieldKey,Field>();
        while (!Object.class.equals(cls)) {
          Field[] fields=cls.getDeclaredFields();
          if (JVMInfo.reverseFieldDefinition()) {
            for (int i=fields.length >> 1; i-- > 0; ) {
              final int idx=fields.length - i - 1;
              final Field field=fields[i];
              fields[i]=fields[idx];
              fields[idx]=field;
            }
          }
          for (int i=0; i < fields.length; i++) {
            Field field=fields[i];
            field.setAccessible(true);
            if (!keyedByFieldName.containsKey(field.getName())) {
              keyedByFieldName.put(field.getName(),field);
            }
            keyedByFieldKey.put(new FieldKey(field.getName(),field.getDeclaringClass(),i),field);
          }
          cls=cls.getSuperclass();
        }
        nameCache.put(clsName,keyedByFieldName);
        keyCache.put(clsName,keyedByFieldKey);
      }
    }
  }
  return tupleKeyed ? keyCache.get(clsName) : nameCache.get(clsName);
}
