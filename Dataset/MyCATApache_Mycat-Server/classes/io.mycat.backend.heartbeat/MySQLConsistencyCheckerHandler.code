/** 
 * @author zwy
 */
public class MySQLConsistencyCheckerHandler extends MySQLConsistencyChecker {
  private final ConsistenCollectHandler handler;
  private volatile int sqlSeq=1;
  private final PhysicalDBNode dbNode;
  public MySQLConsistencyCheckerHandler(  PhysicalDBNode dbNode,  MySQLDataSource source,  String tableName,  ConsistenCollectHandler handler){
    super(source,tableName);
    this.handler=handler;
    this.dbNode=dbNode;
  }
  public void checkRecordCout(){
    this.jobCount.set(0);
    beginTime=new Date().getTime();
    String dbName=dbNode.getDatabase();
    MySQLConsistencyHelper detector=new MySQLConsistencyHelper(this,null);
    OneRawSQLQueryResultHandler resultHandler=new OneRawSQLQueryResultHandler(new String[]{GlobalTableUtil.COUNT_COLUMN},detector);
    SQLJob sqlJob=new SQLJob(this.getCountSQL(),dbName,resultHandler,source);
    detector.setSqlJob(sqlJob);
    this.jobCount.incrementAndGet();
    sqlJob.run();
  }
  public void checkMaxTimeStamp(){
    this.jobCount.set(0);
    beginTime=new Date().getTime();
    String dbName=dbNode.getDatabase();
    MySQLConsistencyHelper detector=new MySQLConsistencyHelper(this,null,0);
    OneRawSQLQueryResultHandler resultHandler=new OneRawSQLQueryResultHandler(new String[]{GlobalTableUtil.MAX_COLUMN},detector);
    SQLJob sqlJob=new SQLJob(this.getMaxSQL(),dbName,resultHandler,source);
    detector.setSqlJob(sqlJob);
    this.jobCount.incrementAndGet();
    sqlJob.run();
  }
  /** 
 * check inner column exist or not
 */
  public void checkInnerColumnExist(){
    this.jobCount.set(0);
    beginTime=new Date().getTime();
    String dbName=dbNode.getDatabase();
    MySQLConsistencyHelper detector=new MySQLConsistencyHelper(this,null,1);
    OneRawSQLQueryResultHandler resultHandler=new OneRawSQLQueryResultHandler(new String[]{GlobalTableUtil.INNER_COLUMN},detector);
    String db=" and table_schema='" + dbName + "'";
    SQLJob sqlJob=new SQLJob(this.columnExistSQL + db,dbName,resultHandler,source);
    detector.setSqlJob(sqlJob);
    this.jobCount.incrementAndGet();
    sqlJob.run();
  }
  public volatile boolean isStop=false;
  volatile SQLQueryResult<Map<String,String>> resultMap=null;
  public void setResult(  SQLQueryResult<Map<String,String>> result){
    if (isStop) {
      return;
    }
    if (result != null && result.isSuccess()) {
      jobCount.decrementAndGet();
      String dataNode=result.getDataNode();
      result.setTableName(this.getTableName());
      if (resultMap == null) {
        resultMap=result;
      }
 else {
        SQLQueryResult<Map<String,String>> r=resultMap;
        Map<String,String> metaData=result.getResult();
        for (        String key : metaData.keySet()) {
          r.getResult().put(key,metaData.get(key));
        }
        resultMap=r;
      }
    }
 else {
      if (result != null && result.getResult() != null) {
        String sql=null;
        final int seq=sqlSeq;
        if (seq == 0) {
          sql=this.getColumnExistSQL();
        }
 else         if (seq == 1) {
          sql=this.getMaxSQL();
        }
 else         if (seq == 2) {
          sql=this.getCountSQL();
        }
 else {
          sql=result.getErrMsg();
        }
        String errMsg=sql + " execute failed in db: " + result.getDataNode()+ " during global table consistency check task.";
        LOGGER.warn(errMsg);
        handler.onError(errMsg);
      }
    }
    if (jobCount.get() == 0) {
      final int seq=++sqlSeq;
      if (seq == 1) {
        this.checkMaxTimeStamp();
      }
 else       if (seq == 2) {
        this.checkRecordCout();
      }
 else {
        handler.onSuccess(resultMap);
        isStop=true;
      }
    }
 else     if (isTimeOut()) {
      String execSql="";
      final int seq=sqlSeq;
      if (seq == 0) {
        execSql=this.getColumnExistSQL();
      }
 else       if (seq == 1) {
        execSql=this.getMaxSQL();
      }
 else       if (seq == 2) {
        execSql=this.getCountSQL();
      }
      isStop=true;
      handler.onError(String.format("sql %s time out",execSql));
    }
  }
}
