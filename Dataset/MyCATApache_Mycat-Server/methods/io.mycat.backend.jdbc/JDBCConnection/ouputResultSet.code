private void ouputResultSet(ServerConnection sc,String sql) throws SQLException {
  ResultSet rs=null;
  Statement stmt=null;
  try {
    stmt=con.createStatement();
    if (sc.getSqlSelectLimit() > 0) {
      stmt.setMaxRows(sc.getSqlSelectLimit());
    }
    rs=stmt.executeQuery(sql);
    List<FieldPacket> fieldPks=new LinkedList<FieldPacket>();
    ResultSetUtil.resultSetToFieldPacket(sc.getCharset(),fieldPks,rs,this.isSpark);
    int colunmCount=fieldPks.size();
    ByteBuffer byteBuf=sc.allocate();
    ResultSetHeaderPacket headerPkg=new ResultSetHeaderPacket();
    headerPkg.fieldCount=fieldPks.size();
    headerPkg.packetId=++packetId;
    byteBuf=headerPkg.write(byteBuf,sc,true);
    byteBuf.flip();
    byte[] header=new byte[byteBuf.limit()];
    byteBuf.get(header);
    byteBuf.clear();
    List<byte[]> fields=new ArrayList<byte[]>(fieldPks.size());
    Iterator<FieldPacket> itor=fieldPks.iterator();
    while (itor.hasNext()) {
      FieldPacket curField=itor.next();
      curField.packetId=++packetId;
      byteBuf=curField.write(byteBuf,sc,false);
      byteBuf.flip();
      byte[] field=new byte[byteBuf.limit()];
      byteBuf.get(field);
      byteBuf.clear();
      fields.add(field);
    }
    EOFPacket eofPckg=new EOFPacket();
    eofPckg.packetId=++packetId;
    byteBuf=eofPckg.write(byteBuf,sc,false);
    byteBuf.flip();
    byte[] eof=new byte[byteBuf.limit()];
    byteBuf.get(eof);
    byteBuf.clear();
    this.respHandler.fieldEofResponse(header,fields,eof,this);
    while (rs.next()) {
      RowDataPacket curRow=new RowDataPacket(colunmCount);
      for (int i=0; i < colunmCount; i++) {
        int j=i + 1;
        if (MysqlDefs.isBianry((byte)fieldPks.get(i).type)) {
          curRow.add(rs.getBytes(j));
        }
 else         if (fieldPks.get(i).type == MysqlDefs.FIELD_TYPE_DECIMAL || fieldPks.get(i).type == (MysqlDefs.FIELD_TYPE_NEW_DECIMAL - 256)) {
          BigDecimal val=rs.getBigDecimal(j);
          curRow.add(StringUtil.encode(val != null ? val.toPlainString() : null,sc.getCharset()));
        }
 else {
          curRow.add(StringUtil.encode(rs.getString(j),sc.getCharset()));
        }
      }
      curRow.packetId=++packetId;
      byteBuf=curRow.write(byteBuf,sc,false);
      byteBuf.flip();
      byte[] row=new byte[byteBuf.limit()];
      byteBuf.get(row);
      byteBuf.clear();
      this.respHandler.rowResponse(row,this);
    }
    fieldPks.clear();
    eofPckg=new EOFPacket();
    eofPckg.packetId=++packetId;
    byteBuf=eofPckg.write(byteBuf,sc,false);
    byteBuf.flip();
    eof=new byte[byteBuf.limit()];
    byteBuf.get(eof);
    sc.recycle(byteBuf);
    this.respHandler.rowEofResponse(eof,this);
  }
  finally {
    if (rs != null) {
      try {
        rs.close();
      }
 catch (      SQLException e) {
      }
    }
    if (stmt != null) {
      try {
        stmt.close();
      }
 catch (      SQLException e) {
      }
    }
  }
}
