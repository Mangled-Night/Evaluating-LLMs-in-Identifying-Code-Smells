/** 
 * 反射工具类 Created by vlinux on 15/5/18.
 */
public class ArthasReflectUtils {
  /** 
 * 从包package中获取所有的Class
 * @param packname 包名称
 * @return 包路径下所有类集合<p> 代码摘抄自 http://www.oschina.net/code/snippet_129830_8767</p>
 */
  public static Set<Class<?>> getClasses(  final ClassLoader loader,  final String packname){
    Set<Class<?>> classes=new LinkedHashSet<Class<?>>();
    String packageName=packname;
    String packageDirName=packageName.replace('.','/');
    Enumeration<URL> dirs;
    try {
      dirs=loader.getResources(packageDirName);
      while (dirs.hasMoreElements()) {
        URL url=dirs.nextElement();
        String protocol=url.getProtocol();
        if ("file".equals(protocol)) {
          String filePath=URLDecoder.decode(url.getFile(),"UTF-8");
          findAndAddClassesInPackageByFile(packageName,filePath,true,classes);
        }
 else         if ("jar".equals(protocol)) {
          JarFile jar;
          try {
            jar=((JarURLConnection)url.openConnection()).getJarFile();
            Enumeration<JarEntry> entries=jar.entries();
            while (entries.hasMoreElements()) {
              JarEntry entry=entries.nextElement();
              String name=entry.getName();
              if (name.charAt(0) == '/') {
                name=name.substring(1);
              }
              if (name.startsWith(packageDirName)) {
                int idx=name.lastIndexOf('/');
                if (idx != -1) {
                  packageName=name.substring(0,idx).replace('/','.');
                }
                if (name.endsWith(".class") && !entry.isDirectory()) {
                  String className=name.substring(packageName.length() + 1,name.length() - 6);
                  try {
                    classes.add(Class.forName(packageName + '.' + className));
                  }
 catch (                  ClassNotFoundException e) {
                  }
                }
              }
            }
          }
 catch (          IOException e) {
          }
        }
      }
    }
 catch (    IOException e) {
    }
    return classes;
  }
  /** 
 * 以文件的形式来获取包下的所有Class <p/> <p> 代码摘抄自 http://www.oschina.net/code/snippet_129830_8767</p>
 */
  private static void findAndAddClassesInPackageByFile(  String packageName,  String packagePath,  final boolean recursive,  Set<Class<?>> classes){
    File dir=new File(packagePath);
    if (!dir.exists() || !dir.isDirectory()) {
      return;
    }
    File[] dirfiles=dir.listFiles(new FileFilter(){
      @Override public boolean accept(      File file){
        return (recursive && file.isDirectory()) || (file.getName().endsWith(".class"));
      }
    }
);
    if (dirfiles != null) {
      for (      File file : dirfiles) {
        if (file.isDirectory()) {
          findAndAddClassesInPackageByFile(packageName + "." + file.getName(),file.getAbsolutePath(),recursive,classes);
        }
 else {
          String className=file.getName().substring(0,file.getName().length() - 6);
          try {
            classes.add(Thread.currentThread().getContextClassLoader().loadClass(packageName + '.' + className));
          }
 catch (          ClassNotFoundException e) {
          }
        }
      }
    }
  }
  /** 
 * 设置对象某个成员的值
 * @param field  属性对象
 * @param value  属性值
 * @param target 目标对象
 * @throws IllegalArgumentException 非法参数
 * @throws IllegalAccessException   非法进入
 */
  public static void set(  Field field,  Object value,  Object target) throws IllegalArgumentException, IllegalAccessException {
    final boolean isAccessible=field.isAccessible();
    try {
      field.setAccessible(true);
      field.set(target,value);
    }
  finally {
      field.setAccessible(isAccessible);
    }
  }
  /** 
 * 获取一个类下的所有成员(包括父类、私有成员)
 * @param clazz 目标类
 * @return 类下所有属性
 */
  public static Set<Field> getFields(  Class<?> clazz){
    final Set<Field> fields=new LinkedHashSet<Field>();
    final Class<?> parentClazz=clazz.getSuperclass();
    Collections.addAll(fields,clazz.getDeclaredFields());
    if (null != parentClazz) {
      fields.addAll(getFields(parentClazz));
    }
    return fields;
  }
  /** 
 * 获取一个类下的指定成员
 * @param clazz 目标类
 * @param name  属性名
 * @return 属性
 */
  public static Field getField(  Class<?> clazz,  String name){
    for (    Field field : getFields(clazz)) {
      if (ArthasCheckUtils.isEquals(field.getName(),name)) {
        return field;
      }
    }
    return null;
  }
  /** 
 * 获取对象某个成员的值
 * @param < T >
 * @param target 目标对象
 * @param field  目标属性
 * @return 目标属性值
 * @throws IllegalArgumentException 非法参数
 * @throws IllegalAccessException   非法进入
 */
  public static <T>T getFieldValueByField(  Object target,  Field field) throws IllegalArgumentException, IllegalAccessException {
    final boolean isAccessible=field.isAccessible();
    try {
      field.setAccessible(true);
      return (T)field.get(target);
    }
  finally {
      field.setAccessible(isAccessible);
    }
  }
  /** 
 * 将字符串转换为指定类型，目前只支持9种类型：8种基本类型（包括其包装类）以及字符串
 * @param t     目标对象类型
 * @param value 目标值
 * @return 类型转换后的值
 */
  @SuppressWarnings("unchecked") public static <T>T valueOf(  Class<T> t,  String value){
    if (ArthasCheckUtils.isIn(t,int.class,Integer.class)) {
      return (T)Integer.valueOf(value);
    }
 else     if (ArthasCheckUtils.isIn(t,long.class,Long.class)) {
      return (T)Long.valueOf(value);
    }
 else     if (ArthasCheckUtils.isIn(t,double.class,Double.class)) {
      return (T)Double.valueOf(value);
    }
 else     if (ArthasCheckUtils.isIn(t,float.class,Float.class)) {
      return (T)Float.valueOf(value);
    }
 else     if (ArthasCheckUtils.isIn(t,char.class,Character.class)) {
      return (T)Character.valueOf(value.charAt(0));
    }
 else     if (ArthasCheckUtils.isIn(t,byte.class,Byte.class)) {
      return (T)Byte.valueOf(value);
    }
 else     if (ArthasCheckUtils.isIn(t,boolean.class,Boolean.class)) {
      return (T)Boolean.valueOf(value);
    }
 else     if (ArthasCheckUtils.isIn(t,short.class,Short.class)) {
      return (T)Short.valueOf(value);
    }
 else     if (ArthasCheckUtils.isIn(t,String.class)) {
      return (T)value;
    }
 else {
      return null;
    }
  }
  /** 
 * 定义类
 * @param targetClassLoader 目标classloader
 * @param className         类名称
 * @param classByteArray    类字节码数组
 * @return 定义的类
 * @throws NoSuchMethodException
 * @throws InvocationTargetException
 * @throws IllegalAccessException
 */
  public static Class<?> defineClass(  final ClassLoader targetClassLoader,  final String className,  final byte[] classByteArray) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
    final Method defineClassMethod=ClassLoader.class.getDeclaredMethod("defineClass",String.class,byte[].class,int.class,int.class);
synchronized (defineClassMethod) {
      final boolean acc=defineClassMethod.isAccessible();
      try {
        defineClassMethod.setAccessible(true);
        return (Class<?>)defineClassMethod.invoke(targetClassLoader,className,classByteArray,0,classByteArray.length);
      }
  finally {
        defineClassMethod.setAccessible(acc);
      }
    }
  }
}
