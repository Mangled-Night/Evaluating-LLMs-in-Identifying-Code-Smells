/** 
 * Return a  {@link ResolvableType} representing the generic parameter for the given indexes. Indexes are zero based; forexample given the type  {@code Map<Integer, List<String>>},  {@code getGeneric(0)} will access the {@code Integer}. Nested generics can be accessed by specifying multiple indexes; for example  {@code getGeneric(1, 0)} will access the{@code String} from the nested {@code List}. For convenience, if no indexes are specified the first generic is returned. <p> If no generic is available at the specified indexes  {@link #NONE} is returned.
 * @param indexes the indexes that refer to the generic parameter (may be omitted to return the first generic)
 * @return a {@link ResolvableType} for the specified generic or {@link #NONE}
 * @see #hasGenerics()
 * @see #getGenerics()
 * @see #resolveGeneric(int...)
 * @see #resolveGenerics()
 */
public ResolvableType getGeneric(int... indexes){
  try {
    if (indexes == null || indexes.length == 0) {
      return getGenerics()[0];
    }
    ResolvableType generic=this;
    for (    int index : indexes) {
      generic=generic.getGenerics()[index];
    }
    return generic;
  }
 catch (  IndexOutOfBoundsException ex) {
    return NONE;
  }
}
