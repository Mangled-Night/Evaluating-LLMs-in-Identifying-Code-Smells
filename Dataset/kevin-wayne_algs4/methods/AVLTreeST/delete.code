/** 
 * Removes the specified key and its associated value from the symbol table (if the key is in the symbol table).
 * @param key the key
 * @throws IllegalArgumentException if {@code key} is {@code null}
 */
public void delete(Key key){
  if (key == null)   throw new IllegalArgumentException("argument to delete() is null");
  if (!contains(key))   return;
  root=delete(root,key);
  assert check();
}
/** 
 * Removes the specified key and its associated value from the given subtree.
 * @param x the subtree
 * @param key the key
 * @return the updated subtree
 */
private Node delete(Node x,Key key){
  int cmp=key.compareTo(x.key);
  if (cmp < 0) {
    x.left=delete(x.left,key);
  }
 else   if (cmp > 0) {
    x.right=delete(x.right,key);
  }
 else {
    if (x.left == null) {
      return x.right;
    }
 else     if (x.right == null) {
      return x.left;
    }
 else {
      Node y=x;
      x=min(y.right);
      x.right=deleteMin(y.right);
      x.left=y.left;
    }
  }
  x.size=1 + size(x.left) + size(x.right);
  x.height=1 + Math.max(height(x.left),height(x.right));
  return balance(x);
}
