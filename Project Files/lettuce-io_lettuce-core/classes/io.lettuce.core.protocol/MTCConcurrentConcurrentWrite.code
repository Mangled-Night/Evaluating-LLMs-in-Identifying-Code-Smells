/** 
 * Test of concurrent access to locks. Two concurrent writes.
 */
static class MTCConcurrentConcurrentWrite {
  private final Command<String,String,String> command;
  private final TestableEndpoint handler;
  private final CountDownLatch phase1=new CountDownLatch(2);
  private final CountDownLatch phase2=new CountDownLatch(2);
  private final CountDownLatch phase3=new CountDownLatch(2);
  MTCConcurrentConcurrentWrite(  Command<String,String,String> command,  ClientResources clientResources){
    this.command=command;
    handler=new TestableEndpoint(ClientOptions.create(),clientResources){
      @Override protected <C extends RedisCommand<?,?,T>,T>void writeToBuffer(      C command){
        waitAndProgress(phase2);
        Object sharedLock=ReflectionTestUtils.getField(this,"sharedLock");
        AtomicLong writers=ReflectionTestUtils.getField(sharedLock,"writers");
        assertThat(writers.get()).isEqualTo(2);
        waitAndProgress(phase3);
        super.writeToBuffer(command);
      }
    }
;
  }
  public void thread1(){
    waitAndProgress(phase1);
    handler.write(command);
  }
  public void thread2(){
    waitAndProgress(phase1);
    handler.write(command);
  }
  private void waitAndProgress(  CountDownLatch latch){
    latch.countDown();
    try {
      latch.await(2,TimeUnit.SECONDS);
    }
 catch (    InterruptedException e) {
      throw new IllegalStateException(e);
    }
  }
}
