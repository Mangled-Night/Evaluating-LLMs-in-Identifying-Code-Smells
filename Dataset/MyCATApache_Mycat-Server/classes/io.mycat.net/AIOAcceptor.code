/** 
 * @author mycat
 */
public final class AIOAcceptor implements SocketAcceptor, CompletionHandler<AsynchronousSocketChannel,Long> {
  private static final Logger LOGGER=LoggerFactory.getLogger(AIOAcceptor.class);
  private static final AcceptIdGenerator ID_GENERATOR=new AcceptIdGenerator();
  private final int port;
  private final AsynchronousServerSocketChannel serverChannel;
  private final FrontendConnectionFactory factory;
  private long acceptCount;
  private final String name;
  public AIOAcceptor(  String name,  String ip,  int port,  int backlog,  FrontendConnectionFactory factory,  AsynchronousChannelGroup group) throws IOException {
    this.name=name;
    this.port=port;
    this.factory=factory;
    serverChannel=AsynchronousServerSocketChannel.open(group);
    serverChannel.setOption(StandardSocketOptions.SO_REUSEADDR,true);
    serverChannel.setOption(StandardSocketOptions.SO_RCVBUF,1024 * 16 * 2);
    serverChannel.bind(new InetSocketAddress(ip,port),backlog);
  }
  public String getName(){
    return name;
  }
  public void start(){
    this.pendingAccept();
  }
  public int getPort(){
    return port;
  }
  public long getAcceptCount(){
    return acceptCount;
  }
  private void accept(  NetworkChannel channel,  Long id){
    try {
      FrontendConnection c=factory.make(channel);
      c.setAccepted(true);
      c.setId(id);
      NIOProcessor processor=MycatServer.getInstance().nextProcessor();
      c.setProcessor(processor);
      c.register();
    }
 catch (    Exception e) {
      LOGGER.error("AioAcceptorError",e);
      closeChannel(channel);
    }
  }
  private void pendingAccept(){
    if (serverChannel.isOpen()) {
      serverChannel.accept(ID_GENERATOR.getId(),this);
    }
 else {
      throw new IllegalStateException("MyCAT Server Channel has been closed");
    }
  }
  @Override public void completed(  AsynchronousSocketChannel result,  Long id){
    accept(result,id);
    pendingAccept();
  }
  @Override public void failed(  Throwable exc,  Long id){
    LOGGER.info("acception connect failed:" + exc);
    pendingAccept();
  }
  private static void closeChannel(  NetworkChannel channel){
    if (channel == null) {
      return;
    }
    try {
      channel.close();
    }
 catch (    IOException e) {
      LOGGER.error("AioAcceptorError",e);
    }
  }
  /** 
 * 前端连接ID生成器
 * @author mycat
 */
private static class AcceptIdGenerator {
    private static final long MAX_VALUE=0xffffffffL;
    private AtomicLong acceptId=new AtomicLong();
    private final Object lock=new Object();
    private long getId(){
      long newValue=acceptId.getAndIncrement();
      if (newValue >= MAX_VALUE) {
synchronized (lock) {
          newValue=acceptId.getAndIncrement();
          if (newValue >= MAX_VALUE) {
            acceptId.set(0);
          }
        }
        return acceptId.getAndDecrement();
      }
 else {
        return newValue;
      }
    }
  }
}
