/** 
 * Returns an iterator over the keys and values in this map. This uses destructive iterator of BytesToBytesMap. So it is illegal to call any other method on this map after `iterator()` has been called. For efficiency, each call returns the same object.
 */
public KVIterator<UnsafeRow,UnsafeRow> iterator(){
  return new KVIterator<UnsafeRow,UnsafeRow>(){
    private final BytesToBytesMap.MapIterator mapLocationIterator=map.iterator();
    private final UnsafeRow key=new UnsafeRow(groupingKeySchema.length());
    private final UnsafeRow value=new UnsafeRow(aggregationBufferSchema.length());
    @Override public boolean next(){
      if (mapLocationIterator.hasNext()) {
        final BytesToBytesMap.Location loc=mapLocationIterator.next();
        if (loc == null)         return false;
        key.pointTo(loc.getKeyBase(),loc.getKeyOffset(),loc.getKeyLength());
        value.pointTo(loc.getValueBase(),loc.getValueOffset(),loc.getValueLength());
        return true;
      }
 else {
        return false;
      }
    }
    @Override public UnsafeRow getKey(){
      return key;
    }
    @Override public UnsafeRow getValue(){
      return value;
    }
    @Override public void close(){
    }
  }
;
}
