/** 
 * Delay that increases exponentially on every attempt. <p> Considering retry attempts start at 1, attempt 0 would be the initial call and will always yield 0 (or the lower bound). Then each retry step will by default yield  {@code 2 ^ (attemptNumber-1)}. By default this gives us 0 (initial attempt), 1, 2, 4, 8, 16, 32, ... <p> {@link ExponentialDelay} can also apply different {@code powersBy}, such as power of 10 that would apply {@code 10 ^ (attemptNumber-1)} which would give 0, 10, 100, 1000, ...<p> Each of the resulting values that is below the  {@code lowerBound} will be replaced by the lower bound, and each value overthe  {@code upperBound} will be replaced by the upper bound.
 * @author Mark Paluch
 * @author Jongyeol Choi
 * @since 4.1
 */
class ExponentialDelay extends Delay {
  private final Duration lower;
  private final Duration upper;
  private final int powersOf;
  private final TimeUnit targetTimeUnit;
  ExponentialDelay(  Duration lower,  Duration upper,  int powersOf,  TimeUnit targetTimeUnit){
    this.lower=lower;
    this.upper=upper;
    this.powersOf=powersOf;
    this.targetTimeUnit=targetTimeUnit;
  }
  @Override public Duration createDelay(  long attempt){
    long delay;
    if (attempt <= 0) {
      delay=0;
    }
 else     if (powersOf == 2) {
      delay=calculatePowerOfTwo(attempt);
    }
 else {
      delay=calculateAlternatePower(attempt);
    }
    return applyBounds(Duration.ofNanos(targetTimeUnit.toNanos(delay)));
  }
  /** 
 * Apply bounds to the given  {@code delay}.
 * @param delay the delay
 * @return the delay normalized to its lower and upper bounds.
 */
  protected Duration applyBounds(  Duration delay){
    return applyBounds(delay,lower,upper);
  }
  private long calculateAlternatePower(  long attempt){
    double step=Math.pow(powersOf,attempt - 1);
    return Math.round(step);
  }
  protected static long calculatePowerOfTwo(  long attempt){
    if (attempt <= 0) {
      return 0L;
    }
 else     if (attempt >= 63) {
      return Long.MAX_VALUE - 1;
    }
 else {
      return 1L << (attempt - 1);
    }
  }
}
