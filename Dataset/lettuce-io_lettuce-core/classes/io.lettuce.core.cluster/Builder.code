/** 
 * Builder for  {@link ClusterClientOptions}.
 */
public static class Builder extends ClientOptions.Builder {
  private boolean closeStaleConnections=DEFAULT_CLOSE_STALE_CONNECTIONS;
  private int maxRedirects=DEFAULT_MAX_REDIRECTS;
  private boolean validateClusterNodeMembership=DEFAULT_VALIDATE_CLUSTER_MEMBERSHIP;
  private Predicate<RedisClusterNode> nodeFilter=DEFAULT_NODE_FILTER;
  private ClusterTopologyRefreshOptions topologyRefreshOptions=null;
  protected Builder(){
  }
  @Override public Builder autoReconnect(  boolean autoReconnect){
    super.autoReconnect(autoReconnect);
    return this;
  }
  /** 
 * @param bufferUsageRatio the buffer usage ratio. Must be between {@code 0} and {@code 2^31-1}, typically a value between 1 and 10 representing 50% to 90%.
 * @return {@code this}
 * @deprecated since 6.0 in favor of {@link DecodeBufferPolicy}.
 */
  @Override @Deprecated public Builder bufferUsageRatio(  int bufferUsageRatio){
    super.bufferUsageRatio(bufferUsageRatio);
    return this;
  }
  /** 
 * @param cancelCommandsOnReconnectFailure true/false
 * @return
 * @deprecated since 6.2, to be removed with 7.0. This feature is unsafe and may cause protocol offsets if true (i.e.Redis commands are completed with previous command values).
 */
  @Override @Deprecated public Builder cancelCommandsOnReconnectFailure(  boolean cancelCommandsOnReconnectFailure){
    super.cancelCommandsOnReconnectFailure(cancelCommandsOnReconnectFailure);
    return this;
  }
  @Override public Builder decodeBufferPolicy(  DecodeBufferPolicy decodeBufferPolicy){
    super.decodeBufferPolicy(decodeBufferPolicy);
    return this;
  }
  @Override public Builder disconnectedBehavior(  DisconnectedBehavior disconnectedBehavior){
    super.disconnectedBehavior(disconnectedBehavior);
    return this;
  }
  /** 
 * Number of maximal cluster redirects ( {@literal -MOVED} and {@literal -ASK}) to follow in case a key was moved from one node to another node. Defaults to  {@literal 5}. See  {@link ClusterClientOptions#DEFAULT_MAX_REDIRECTS}.
 * @param maxRedirects the limit of maximal cluster redirects
 * @return {@code this}
 */
  public Builder maxRedirects(  int maxRedirects){
    this.maxRedirects=maxRedirects;
    return this;
  }
  @Override public Builder pingBeforeActivateConnection(  boolean pingBeforeActivateConnection){
    super.pingBeforeActivateConnection(pingBeforeActivateConnection);
    return this;
  }
  @Override public Builder protocolVersion(  ProtocolVersion protocolVersion){
    super.protocolVersion(protocolVersion);
    return this;
  }
  @Override public Builder suspendReconnectOnProtocolFailure(  boolean suspendReconnectOnProtocolFailure){
    super.suspendReconnectOnProtocolFailure(suspendReconnectOnProtocolFailure);
    return this;
  }
  @Override public Builder publishOnScheduler(  boolean publishOnScheduler){
    super.publishOnScheduler(publishOnScheduler);
    return this;
  }
  @Override public Builder requestQueueSize(  int requestQueueSize){
    super.requestQueueSize(requestQueueSize);
    return this;
  }
  @Override public Builder scriptCharset(  Charset scriptCharset){
    super.scriptCharset(scriptCharset);
    return this;
  }
  @Override public Builder socketOptions(  SocketOptions socketOptions){
    super.socketOptions(socketOptions);
    return this;
  }
  @Override public Builder sslOptions(  SslOptions sslOptions){
    super.sslOptions(sslOptions);
    return this;
  }
  @Override public Builder timeoutOptions(  TimeoutOptions timeoutOptions){
    super.timeoutOptions(timeoutOptions);
    return this;
  }
  /** 
 * Sets the  {@link ClusterTopologyRefreshOptions} for detailed control of topology updates.
 * @param topologyRefreshOptions the {@link ClusterTopologyRefreshOptions}
 * @return {@code this}
 */
  public Builder topologyRefreshOptions(  ClusterTopologyRefreshOptions topologyRefreshOptions){
    this.topologyRefreshOptions=topologyRefreshOptions;
    return this;
  }
  /** 
 * Validate the cluster node membership before allowing connections to a cluster node. Defaults to  {@code true}. See {@link ClusterClientOptions#DEFAULT_VALIDATE_CLUSTER_MEMBERSHIP}.
 * @param validateClusterNodeMembership {@code true} if validation is enabled.
 * @return {@code this}
 */
  public Builder validateClusterNodeMembership(  boolean validateClusterNodeMembership){
    this.validateClusterNodeMembership=validateClusterNodeMembership;
    return this;
  }
  /** 
 * Provide a  {@link Predicate node filter} to filter cluster nodes from{@link io.lettuce.core.cluster.models.partitions.Partitions}.
 * @param nodeFilter must not be {@code null}.
 * @return {@code this}
 * @since 6.1.6
 */
  public Builder nodeFilter(  Predicate<RedisClusterNode> nodeFilter){
    LettuceAssert.notNull(nodeFilter,"NodeFilter must not be null");
    this.nodeFilter=nodeFilter;
    return this;
  }
  /** 
 * Create a new instance of  {@link ClusterClientOptions}
 * @return new instance of {@link ClusterClientOptions}
 */
  public ClusterClientOptions build(){
    return new ClusterClientOptions(this);
  }
}
/** 
 * Builder for  {@link ClusterTopologyRefreshOptions}.
 */
public static class Builder {
  private final Set<RefreshTrigger> adaptiveRefreshTriggers=new HashSet<>(DEFAULT_ADAPTIVE_REFRESH_TRIGGERS);
  private Duration adaptiveRefreshTimeout=DEFAULT_ADAPTIVE_REFRESH_TIMEOUT_DURATION;
  private boolean closeStaleConnections=DEFAULT_CLOSE_STALE_CONNECTIONS;
  private boolean dynamicRefreshSources=DEFAULT_DYNAMIC_REFRESH_SOURCES;
  private boolean periodicRefreshEnabled=DEFAULT_PERIODIC_REFRESH_ENABLED;
  private Duration refreshPeriod=DEFAULT_REFRESH_PERIOD_DURATION;
  private int refreshTriggersReconnectAttempts=DEFAULT_REFRESH_TRIGGERS_RECONNECT_ATTEMPTS;
  private Builder(){
  }
  /** 
 * Enables adaptive topology refreshing using one or more  {@link RefreshTrigger triggers}. Adaptive refresh triggers initiate topology view updates based on events happened during Redis Cluster operations. Adaptive triggers lead to an immediate topology refresh. Adaptive triggered refreshes are rate-limited using a timeout since events can happen on a large scale. Adaptive refresh triggers are disabled by default. See also {@link #adaptiveRefreshTriggersTimeout(long,TimeUnit)} and {@link RefreshTrigger}.
 * @param refreshTrigger one or more {@link RefreshTrigger} to enabled
 * @return {@code this}
 */
  public Builder enableAdaptiveRefreshTrigger(  RefreshTrigger... refreshTrigger){
    LettuceAssert.notNull(refreshTrigger,"RefreshTriggers must not be null");
    LettuceAssert.noNullElements(refreshTrigger,"RefreshTriggers must not contain null elements");
    adaptiveRefreshTriggers.addAll(Arrays.asList(refreshTrigger));
    return this;
  }
  /** 
 * Enables adaptive topology refreshing using all  {@link RefreshTrigger triggers}. Adaptive refresh triggers initiate topology view updates based on events happened during Redis Cluster operations. Adaptive triggers lead to an immediate topology refresh. Adaptive triggered refreshes are rate-limited using a timeout since events can happen on a large scale. Adaptive refresh triggers are disabled by default. See also {@link #adaptiveRefreshTriggersTimeout(long,TimeUnit)} and {@link RefreshTrigger}.
 * @return {@code this}
 */
  public Builder enableAllAdaptiveRefreshTriggers(){
    adaptiveRefreshTriggers.addAll(EnumSet.allOf(RefreshTrigger.class));
    return this;
  }
  /** 
 * Set the timeout for adaptive topology updates. This timeout is to rate-limit topology updates initiated by refresh triggers to one topology refresh per timeout. Defaults to  {@literal 30 SECONDS}. See  {@link #DEFAULT_REFRESH_PERIOD}and  {@link #DEFAULT_REFRESH_PERIOD_UNIT}.
 * @param timeout timeout for rate-limit adaptive topology updates, must be greater than {@literal 0}.
 * @return {@code this}
 * @since 5.0
 */
  public Builder adaptiveRefreshTriggersTimeout(  Duration timeout){
    LettuceAssert.notNull(refreshPeriod,"Adaptive refresh triggers timeout must not be null");
    LettuceAssert.isTrue(refreshPeriod.toNanos() > 0,"Adaptive refresh triggers timeout must be greater 0");
    this.adaptiveRefreshTimeout=timeout;
    return this;
  }
  /** 
 * Set the timeout for adaptive topology updates. This timeout is to rate-limit topology updates initiated by refresh triggers to one topology refresh per timeout. Defaults to  {@literal 30 SECONDS}. See  {@link #DEFAULT_REFRESH_PERIOD}and  {@link #DEFAULT_REFRESH_PERIOD_UNIT}.
 * @param timeout timeout for rate-limit adaptive topology updates
 * @param unit unit for {@code timeout}
 * @return {@code this}
 * @deprecated since 5.0, use {@link #adaptiveRefreshTriggersTimeout(Duration)}.
 */
  @Deprecated public Builder adaptiveRefreshTriggersTimeout(  long timeout,  TimeUnit unit){
    LettuceAssert.isTrue(timeout > 0,"Triggers timeout must be greater 0");
    LettuceAssert.notNull(unit,"TimeUnit must not be null");
    return adaptiveRefreshTriggersTimeout(Duration.ofNanos(unit.toNanos(timeout)));
  }
  /** 
 * Flag, whether to close stale connections when refreshing the cluster topology. Defaults to  {@code true}. Comes only into effect if  {@link #isPeriodicRefreshEnabled()} is {@code true}. See {@link ClusterTopologyRefreshOptions#DEFAULT_CLOSE_STALE_CONNECTIONS}.
 * @param closeStaleConnections {@code true} if stale connections are cleaned up after cluster topology updates
 * @return {@code this}
 */
  public Builder closeStaleConnections(  boolean closeStaleConnections){
    this.closeStaleConnections=closeStaleConnections;
    return this;
  }
  /** 
 * Discover cluster nodes from topology and use the discovered nodes as source for the cluster topology. Using dynamic refresh will query all discovered nodes for the cluster topology and calculate the number of clients for each node. If set to  {@code false}, only the initial seed nodes will be used as sources for topology discovery and the number of clients including response latency will be obtained only for the initial seed nodes. This can be useful when using Redis Cluster with many nodes. Defaults to  {@code true}. See {@link ClusterTopologyRefreshOptions#DEFAULT_DYNAMIC_REFRESH_SOURCES}.
 * @param dynamicRefreshSources {@code true} to discover and query all cluster nodes for obtaining the cluster topology
 * @return {@code this}
 */
  public Builder dynamicRefreshSources(  boolean dynamicRefreshSources){
    this.dynamicRefreshSources=dynamicRefreshSources;
    return this;
  }
  /** 
 * Enables periodic cluster topology updates. The client starts updating the cluster topology in the intervals of {@link Builder#refreshPeriod}. Defaults to  {@code false}. See  {@link #DEFAULT_PERIODIC_REFRESH_ENABLED}.
 * @return {@code this}
 */
  public Builder enablePeriodicRefresh(){
    return enablePeriodicRefresh(true);
  }
  /** 
 * Enable regular cluster topology updates. The client starts updating the cluster topology in the intervals of {@link Builder#refreshPeriod}. Defaults to  {@code false}. See  {@link #DEFAULT_PERIODIC_REFRESH_ENABLED}.
 * @param enabled {@code true} enable regular cluster topology updates or {@code false} to disable auto-updating
 * @return {@code this}
 */
  public Builder enablePeriodicRefresh(  boolean enabled){
    this.periodicRefreshEnabled=enabled;
    return this;
  }
  /** 
 * Enables periodic refresh and sets the refresh period. Defaults to  {@literal 60 SECONDS}. See {@link #DEFAULT_REFRESH_PERIOD} and {@link #DEFAULT_REFRESH_PERIOD_UNIT}. This method is a shortcut for {@link #refreshPeriod(long,TimeUnit)} and {@link #enablePeriodicRefresh()}.
 * @param refreshPeriod period for triggering topology updates, must be greater {@literal 0}
 * @return {@code this}
 * @since 5.0
 */
  public Builder enablePeriodicRefresh(  Duration refreshPeriod){
    return refreshPeriod(refreshPeriod).enablePeriodicRefresh();
  }
  /** 
 * Enables periodic refresh and sets the refresh period. Defaults to  {@literal 60 SECONDS}. See {@link #DEFAULT_REFRESH_PERIOD} and {@link #DEFAULT_REFRESH_PERIOD_UNIT}. This method is a shortcut for {@link #refreshPeriod(long,TimeUnit)} and {@link #enablePeriodicRefresh()}.
 * @param refreshPeriod period for triggering topology updates, must be greater {@literal 0}
 * @param refreshPeriodUnit unit for {@code refreshPeriod}, must not be  {@code null}
 * @return {@code this}
 * @deprecated since 5.0, use {@link #enablePeriodicRefresh(Duration)}.
 */
  @Deprecated public Builder enablePeriodicRefresh(  long refreshPeriod,  TimeUnit refreshPeriodUnit){
    return refreshPeriod(refreshPeriod,refreshPeriodUnit).enablePeriodicRefresh();
  }
  /** 
 * Set the refresh period. Defaults to  {@literal 60 SECONDS}. See  {@link #DEFAULT_REFRESH_PERIOD} and{@link #DEFAULT_REFRESH_PERIOD_UNIT}.
 * @param refreshPeriod period for triggering topology updates, must be greater {@literal 0}
 * @return {@code this}
 * @since 5.0
 */
  public Builder refreshPeriod(  Duration refreshPeriod){
    LettuceAssert.notNull(refreshPeriod,"RefreshPeriod duration must not be null");
    LettuceAssert.isTrue(refreshPeriod.toNanos() > 0,"RefreshPeriod must be greater 0");
    this.refreshPeriod=refreshPeriod;
    return this;
  }
  /** 
 * Set the refresh period. Defaults to  {@literal 60 SECONDS}. See  {@link #DEFAULT_REFRESH_PERIOD} and{@link #DEFAULT_REFRESH_PERIOD_UNIT}.
 * @param refreshPeriod period for triggering topology updates, must be greater {@literal 0}
 * @param refreshPeriodUnit unit for {@code refreshPeriod}, must not be  {@code null}
 * @return {@code this}
 * @deprecated since 5.0, use {@link #refreshPeriod(Duration)}.
 */
  @Deprecated public Builder refreshPeriod(  long refreshPeriod,  TimeUnit refreshPeriodUnit){
    LettuceAssert.isTrue(refreshPeriod > 0,"RefreshPeriod must be greater 0");
    LettuceAssert.notNull(refreshPeriodUnit,"TimeUnit must not be null");
    return refreshPeriod(Duration.ofNanos(refreshPeriodUnit.toNanos(refreshPeriod)));
  }
  /** 
 * Set the threshold for the  {@link RefreshTrigger#PERSISTENT_RECONNECTS}. Topology updates based on persistent reconnects lead only to a refresh if the reconnect process tries at least  {@code refreshTriggersReconnectAttempts}. See  {@link #DEFAULT_REFRESH_TRIGGERS_RECONNECT_ATTEMPTS}.
 * @param refreshTriggersReconnectAttempts number of reconnect attempts for a connection before a n adaptive topologyrefresh is triggered
 * @return {@code this}
 */
  public Builder refreshTriggersReconnectAttempts(  int refreshTriggersReconnectAttempts){
    this.refreshTriggersReconnectAttempts=refreshTriggersReconnectAttempts;
    return this;
  }
  /** 
 * Create a new instance of  {@link ClusterTopologyRefreshOptions}
 * @return new instance of {@link ClusterTopologyRefreshOptions}
 */
  public ClusterTopologyRefreshOptions build(){
    return new ClusterTopologyRefreshOptions(this);
  }
}
