private static void sort(Comparable[] src,Comparable[] dst,int lo,int hi){
  if (hi <= lo + CUTOFF) {
    insertionSort(dst,lo,hi);
    return;
  }
  int mid=lo + (hi - lo) / 2;
  sort(dst,src,lo,mid);
  sort(dst,src,mid + 1,hi);
  if (!less(src[mid + 1],src[mid])) {
    System.arraycopy(src,lo,dst,lo,hi - lo + 1);
    return;
  }
  merge(src,dst,lo,mid,hi);
}
/** 
 * Rearranges the array in ascending order, using the natural order.
 * @param a the array to be sorted
 */
public static void sort(Comparable[] a){
  Comparable[] aux=a.clone();
  sort(aux,a,0,a.length - 1);
  assert isSorted(a);
}
/** 
 * Rearranges the array in ascending order, using the provided order.
 * @param a the array to be sorted
 * @param comparator the comparator that defines the total order
 */
public static void sort(Object[] a,Comparator comparator){
  Object[] aux=a.clone();
  sort(aux,a,0,a.length - 1,comparator);
  assert isSorted(a,comparator);
}
private static void sort(Object[] src,Object[] dst,int lo,int hi,Comparator comparator){
  if (hi <= lo + CUTOFF) {
    insertionSort(dst,lo,hi,comparator);
    return;
  }
  int mid=lo + (hi - lo) / 2;
  sort(dst,src,lo,mid,comparator);
  sort(dst,src,mid + 1,hi,comparator);
  if (!less(src[mid + 1],src[mid],comparator)) {
    System.arraycopy(src,lo,dst,lo,hi - lo + 1);
    return;
  }
  merge(src,dst,lo,mid,hi,comparator);
}
