@SuppressWarnings({"Finally"}) private void runTests(Set<Class<? extends AbstractSmackIntTest>> classes) throws InterruptedException, InstantiationException, IllegalAccessException, IllegalArgumentException, SmackException, IOException, XMPPException {
  List<PreparedTest> tests=new ArrayList<>(classes.size());
  int numberOfAvailableTests=0;
  for (  Class<? extends AbstractSmackIntTest> testClass : classes) {
    final String testClassName=testClass.getName();
    if (!SINTTEST_UNIT_TEST && testClassName.startsWith("org.igniterealtime.smack.inttest.unittest")) {
      LOGGER.warning("Skipping integration test '" + testClassName + "' from src/test classpath (should not be in classpath)");
      continue;
    }
    if (!config.isClassEnabled(testClass)) {
      DisabledTestClass disabledTestClass=new DisabledTestClass(testClass,"Skipping test class " + testClassName + " because it is not enabled");
      testRunResult.disabledTestClasses.add(disabledTestClass);
      continue;
    }
    if (config.isClassDisabled(testClass)) {
      DisabledTestClass disabledTestClass=new DisabledTestClass(testClass,"Skipping test class " + testClassName + " because it is disalbed");
      testRunResult.disabledTestClasses.add(disabledTestClass);
      continue;
    }
    final Constructor<? extends AbstractSmackIntTest> cons;
    try {
      cons=testClass.getConstructor(SmackIntegrationTestEnvironment.class);
    }
 catch (    NoSuchMethodException|SecurityException e) {
      throw new IllegalArgumentException("Smack Integration Test class does not declare the correct constructor. Is a public Constructor(SmackIntegrationTestEnvironment) missing?",e);
    }
    final List<Method> smackIntegrationTestMethods;
{
      Method[] testClassMethods=testClass.getMethods();
      smackIntegrationTestMethods=new ArrayList<>(testClassMethods.length);
      for (      Method method : testClassMethods) {
        if (!method.isAnnotationPresent(SmackIntegrationTest.class)) {
          continue;
        }
        smackIntegrationTestMethods.add(method);
      }
    }
    if (smackIntegrationTestMethods.isEmpty()) {
      LOGGER.warning("No Smack integration test methods found in " + testClass);
      continue;
    }
    final AbstractSmackIntTest test;
    try {
      test=cons.newInstance(environment);
    }
 catch (    InvocationTargetException e) {
      Throwable cause=e.getCause();
      throwFatalException(cause);
      testRunResult.impossibleTestClasses.put(testClass,cause);
      continue;
    }
    XmppConnectionDescriptor<?,?,?> specificLowLevelConnectionDescriptor=null;
    final TestType testType;
    if (test instanceof AbstractSmackSpecificLowLevelIntegrationTest) {
      AbstractSmackSpecificLowLevelIntegrationTest<?> specificLowLevelTest=(AbstractSmackSpecificLowLevelIntegrationTest<?>)test;
      specificLowLevelConnectionDescriptor=specificLowLevelTest.getConnectionDescriptor();
      testType=TestType.SpecificLowLevel;
    }
 else     if (test instanceof AbstractSmackLowLevelIntegrationTest) {
      testType=TestType.LowLevel;
    }
 else     if (test instanceof AbstractSmackIntegrationTest) {
      testType=TestType.Normal;
    }
 else {
      throw new AssertionError();
    }
    for (    Method method : smackIntegrationTestMethods) {
      Class<?> retClass=method.getReturnType();
      if (!retClass.equals(Void.TYPE)) {
        throw new IllegalStateException("SmackIntegrationTest annotation on" + method + " that does not return void");
      }
switch (testType) {
case Normal:
        final Class<?>[] parameterTypes=method.getParameterTypes();
      if (parameterTypes.length > 0) {
        throw new IllegalStateException("SmackIntegrationTest annotaton on " + method + " that takes arguments ");
      }
    break;
case LowLevel:
  verifyLowLevelTestMethod(method,AbstractXMPPConnection.class);
break;
case SpecificLowLevel:
Class<? extends AbstractXMPPConnection> specificLowLevelConnectionClass=specificLowLevelConnectionDescriptor.getConnectionClass();
verifyLowLevelTestMethod(method,specificLowLevelConnectionClass);
break;
}
}
Iterator<Method> it=smackIntegrationTestMethods.iterator();
while (it.hasNext()) {
final Method method=it.next();
final String methodName=method.getName();
if (!config.isMethodEnabled(method)) {
DisabledTest disabledTest=new DisabledTest(method,"Skipping test method " + methodName + " because it is not enabled");
testRunResult.disabledTests.add(disabledTest);
it.remove();
continue;
}
if (config.isMethodDisabled(method)) {
DisabledTest disabledTest=new DisabledTest(method,"Skipping test method " + methodName + " because it is disabled");
testRunResult.disabledTests.add(disabledTest);
it.remove();
continue;
}
}
if (smackIntegrationTestMethods.isEmpty()) {
LOGGER.info("All tests in " + testClassName + " are disabled");
continue;
}
List<ConcreteTest> concreteTests=new ArrayList<>(smackIntegrationTestMethods.size());
for (Method testMethod : smackIntegrationTestMethods) {
switch (testType) {
case Normal:
{
ConcreteTest.Executor concreteTestExecutor=() -> testMethod.invoke(test);
ConcreteTest concreteTest=new ConcreteTest(testType,testMethod,concreteTestExecutor);
concreteTests.add(concreteTest);
}
break;
case LowLevel:
case SpecificLowLevel:
LowLevelTestMethod lowLevelTestMethod=new LowLevelTestMethod(testMethod);
switch (testType) {
case LowLevel:
List<ConcreteTest> concreteLowLevelTests=invokeLowLevel(lowLevelTestMethod,(AbstractSmackLowLevelIntegrationTest)test);
concreteTests.addAll(concreteLowLevelTests);
break;
case SpecificLowLevel:
{
ConcreteTest.Executor concreteTestExecutor=() -> invokeSpecificLowLevel(lowLevelTestMethod,(AbstractSmackSpecificLowLevelIntegrationTest<?>)test);
ConcreteTest concreteTest=new ConcreteTest(testType,testMethod,concreteTestExecutor);
concreteTests.add(concreteTest);
break;
}
default :
throw new AssertionError();
}
break;
}
}
PreparedTest preparedTest=new PreparedTest(test,concreteTests);
tests.add(preparedTest);
numberOfAvailableTests+=concreteTests.size();
}
StringBuilder sb=new StringBuilder(1024);
sb.append("Smack Integration Test Framework\n");
sb.append("################################\n");
if (config.verbose) {
sb.append('\n');
if (!testRunResult.disabledTestClasses.isEmpty()) {
sb.append("The following test classes are disabled:\n");
for (DisabledTestClass disabledTestClass : testRunResult.disabledTestClasses) {
disabledTestClass.appendTo(sb).append('\n');
}
}
if (!testRunResult.disabledTests.isEmpty()) {
sb.append("The following tests are disabled:\n");
for (DisabledTest disabledTest : testRunResult.disabledTests) {
disabledTest.appendTo(sb).append('\n');
}
}
sb.append('\n');
}
sb.append("Available tests: ").append(numberOfAvailableTests);
if (!testRunResult.disabledTestClasses.isEmpty() || !testRunResult.disabledTests.isEmpty()) {
sb.append(" (Disabled ").append(testRunResult.disabledTestClasses.size()).append(" classes").append(" and ").append(testRunResult.disabledTests.size()).append(" tests)");
}
sb.append('\n');
LOGGER.info(sb.toString());
for (PreparedTest test : tests) {
test.run();
}
assert numberOfAvailableTests == testRunResult.getNumberOfAvailableTests();
}
