public class DruidUpdateParser extends DefaultDruidParser {
  @Override public void statementParse(  SchemaConfig schema,  RouteResultset rrs,  SQLStatement stmt) throws SQLNonTransientException {
    if (ctx.getTables() != null && getUpdateTableCount() > 1 && !schema.isNoSharding()) {
      String msg="multi table related update not supported,tables:" + ctx.getTables();
      LOGGER.warn(msg);
      throw new SQLNonTransientException(msg);
    }
    MySqlUpdateStatement update=(MySqlUpdateStatement)stmt;
    String tableName=StringUtil.removeBackquote(update.getTableName().getSimpleName().toUpperCase());
    TableConfig tc=schema.getTables().get(tableName);
    if (RouterUtil.isNoSharding(schema,tableName)) {
      RouterUtil.routeForTableMeta(rrs,schema,tableName,rrs.getStatement());
      rrs.setFinishedRoute(true);
      return;
    }
    String partitionColumn=tc.getPartitionColumn();
    String joinKey=tc.getJoinKey();
    if (tc.isGlobalTable() || (partitionColumn == null && joinKey == null)) {
      RouterUtil.routeToMultiNode(false,rrs,tc.getDataNodes(),rrs.getStatement(),tc.isGlobalTable());
      rrs.setFinishedRoute(true);
      return;
    }
    confirmShardColumnNotUpdated(update,schema,tableName,partitionColumn,joinKey,rrs);
    if (schema.getTables().get(tableName).isGlobalTable() && ctx.getRouteCalculateUnit().getTablesAndConditions().size() > 1) {
      throw new SQLNonTransientException("global table is not supported in multi table related update " + tableName);
    }
    TableConfig tableConfig=schema.getTables().get(tableName);
    if (tableConfig != null && !tableConfig.primaryKeyIsPartionKey()) {
      String cacheName=schema.getName() + "_" + tableName;
      cacheName=cacheName.toUpperCase();
      for (      CachePool value : MycatServer.getInstance().getCacheService().getAllCachePools().values()) {
        value.clearCache(cacheName);
        value.getCacheStatic().reset();
      }
    }
  }
  /** 
 * 获取更新的表数
 * @author lian
 * @date 2016年11月2日
 * @return
 */
  private int getUpdateTableCount(){
    Map<Name,TableStat> tableMap=this.ctx.getVisitor().getTables();
    int updateTableCount=0;
    for (    Name _name : tableMap.keySet()) {
      TableStat ts=tableMap.get(_name);
      updateTableCount+=ts.getUpdateCount();
    }
    return updateTableCount;
  }
  private static boolean columnInExpr(  SQLExpr sqlExpr,  String colName) throws SQLNonTransientException {
    String column;
    if (sqlExpr instanceof SQLIdentifierExpr) {
      column=StringUtil.removeBackquote(((SQLIdentifierExpr)sqlExpr).getName()).toUpperCase();
    }
 else     if (sqlExpr instanceof SQLPropertyExpr) {
      column=StringUtil.removeBackquote(((SQLPropertyExpr)sqlExpr).getName()).toUpperCase();
    }
 else {
      throw new SQLNonTransientException("Unhandled SQL AST node type encountered: " + sqlExpr.getClass());
    }
    return column.equals(colName.toUpperCase());
  }
  private static boolean isSubQueryClause(  SQLExpr sqlExpr) throws SQLNonTransientException {
    return (sqlExpr instanceof SQLInSubQueryExpr || sqlExpr instanceof SQLAnyExpr || sqlExpr instanceof SQLAllExpr|| sqlExpr instanceof SQLQueryExpr|| sqlExpr instanceof SQLExistsExpr);
  }
  private boolean shardColCanBeUpdated(  SQLExpr whereClauseExpr,  String column,  SQLExpr value,  boolean hasOR) throws SQLNonTransientException {
    boolean canUpdate=false;
    boolean parentHasOR=false;
    if (whereClauseExpr == null)     return false;
    if (whereClauseExpr instanceof SQLBinaryOpExpr) {
      SQLBinaryOpExpr nodeOpExpr=(SQLBinaryOpExpr)whereClauseExpr;
      if ((nodeOpExpr.getOperator() == SQLBinaryOperator.BooleanOr) || (nodeOpExpr.getOperator() == SQLBinaryOperator.BooleanXor)) {
        parentHasOR=true;
      }
      if (nodeOpExpr.getOperator() == SQLBinaryOperator.Equality) {
        boolean foundCol;
        SQLExpr leftExpr=nodeOpExpr.getLeft();
        SQLExpr rightExpr=nodeOpExpr.getRight();
        foundCol=columnInExpr(leftExpr,column);
        if (foundCol) {
          if (rightExpr.getClass() != value.getClass()) {
            throw new SQLNonTransientException("SQL AST nodes type mismatch!");
          }
          canUpdate=rightExpr.toString().equals(value.toString()) && (!hasOR) && (!parentHasOR);
        }
      }
 else       if (nodeOpExpr.getOperator().isLogical()) {
        if (nodeOpExpr.getLeft() != null) {
          if (nodeOpExpr.getLeft() instanceof SQLBinaryOpExpr) {
            canUpdate=shardColCanBeUpdated(nodeOpExpr.getLeft(),column,value,parentHasOR);
          }
        }
        if ((!canUpdate) && nodeOpExpr.getRight() != null) {
          if (nodeOpExpr.getRight() instanceof SQLBinaryOpExpr) {
            canUpdate=shardColCanBeUpdated(nodeOpExpr.getRight(),column,value,parentHasOR);
          }
        }
      }
 else       if (isSubQueryClause(nodeOpExpr)) {
        return false;
      }
    }
    return canUpdate;
  }
  private void confirmShardColumnNotUpdated(  SQLUpdateStatement update,  SchemaConfig schema,  String tableName,  String partitionColumn,  String joinKey,  RouteResultset rrs) throws SQLNonTransientException {
    List<SQLUpdateSetItem> updateSetItem=update.getItems();
    if (updateSetItem != null && updateSetItem.size() > 0) {
      boolean hasParent=(schema.getTables().get(tableName).getParentTC() != null);
      for (      SQLUpdateSetItem item : updateSetItem) {
        String column=StringUtil.removeBackquote(item.getColumn().toString().toUpperCase());
        if (column.contains(StringUtil.TABLE_COLUMN_SEPARATOR)) {
          column=column.substring(column.indexOf(".") + 1).trim().toUpperCase();
        }
        if (partitionColumn != null && partitionColumn.equals(column)) {
          boolean canUpdate;
          canUpdate=((update.getWhere() != null) && shardColCanBeUpdated(update.getWhere(),partitionColumn,item.getValue(),false));
          if (!canUpdate) {
            String msg="Sharding column can't be updated " + tableName + "->"+ partitionColumn;
            LOGGER.warn(msg);
            throw new SQLNonTransientException(msg);
          }
        }
        if (hasParent) {
          if (column.equals(joinKey)) {
            String msg="Parent relevant column can't be updated " + tableName + "->"+ joinKey;
            LOGGER.warn(msg);
            throw new SQLNonTransientException(msg);
          }
          rrs.setCacheAble(true);
        }
      }
    }
  }
}
