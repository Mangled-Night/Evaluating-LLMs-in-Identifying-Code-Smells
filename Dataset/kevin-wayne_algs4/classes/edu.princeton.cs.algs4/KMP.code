/** 
 * The  {@code KMP} class finds the first occurrence of a pattern stringin a text string. <p> This implementation uses a version of the Knuth-Morris-Pratt substring search algorithm. The version takes time proportional to <em>n</em> + <em>m R</em> in the worst case, where <em>n</em> is the length of the text string, <em>m</em> is the length of the pattern, and <em>R</em> is the alphabet size. It uses extra space proportional to <em>m R</em>. <p> For additional documentation, see <a href="https://algs4.cs.princeton.edu/53substring">Section 5.3</a> of <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
 */
public class KMP {
  private final int R;
  private final int m;
  private int[][] dfa;
  /** 
 * Preprocesses the pattern string.
 * @param pat the pattern string
 */
  public KMP(  String pat){
    this.R=256;
    this.m=pat.length();
    dfa=new int[R][m];
    dfa[pat.charAt(0)][0]=1;
    for (int x=0, j=1; j < m; j++) {
      for (int c=0; c < R; c++)       dfa[c][j]=dfa[c][x];
      dfa[pat.charAt(j)][j]=j + 1;
      x=dfa[pat.charAt(j)][x];
    }
  }
  /** 
 * Preprocesses the pattern string.
 * @param pattern the pattern string
 * @param R the alphabet size
 */
  public KMP(  char[] pattern,  int R){
    this.R=R;
    this.m=pattern.length;
    int m=pattern.length;
    dfa=new int[R][m];
    dfa[pattern[0]][0]=1;
    for (int x=0, j=1; j < m; j++) {
      for (int c=0; c < R; c++)       dfa[c][j]=dfa[c][x];
      dfa[pattern[j]][j]=j + 1;
      x=dfa[pattern[j]][x];
    }
  }
  /** 
 * Returns the index of the first occurrence of the pattern string in the text string.
 * @param txt the text string
 * @return the index of the first occurrence of the pattern stringin the text string; N if no such match
 */
  public int search(  String txt){
    int n=txt.length();
    int i, j;
    for (i=0, j=0; i < n && j < m; i++) {
      j=dfa[txt.charAt(i)][j];
    }
    if (j == m)     return i - m;
    return n;
  }
  /** 
 * Returns the index of the first occurrence of the pattern string in the text string.
 * @param text the text string
 * @return the index of the first occurrence of the pattern stringin the text string; N if no such match
 */
  public int search(  char[] text){
    int n=text.length;
    int i, j;
    for (i=0, j=0; i < n && j < m; i++) {
      j=dfa[text[i]][j];
    }
    if (j == m)     return i - m;
    return n;
  }
  /** 
 * Takes a pattern string and an input string as command-line arguments; searches for the pattern string in the text string; and prints the first occurrence of the pattern string in the text string.
 * @param args the command-line arguments
 */
  public static void main(  String[] args){
    String pat=args[0];
    String txt=args[1];
    char[] pattern=pat.toCharArray();
    char[] text=txt.toCharArray();
    KMP kmp1=new KMP(pat);
    int offset1=kmp1.search(txt);
    KMP kmp2=new KMP(pattern,256);
    int offset2=kmp2.search(text);
    StdOut.println("text:    " + txt);
    StdOut.print("pattern: ");
    for (int i=0; i < offset1; i++)     StdOut.print(" ");
    StdOut.println(pat);
    StdOut.print("pattern: ");
    for (int i=0; i < offset2; i++)     StdOut.print(" ");
    StdOut.println(pat);
  }
}
