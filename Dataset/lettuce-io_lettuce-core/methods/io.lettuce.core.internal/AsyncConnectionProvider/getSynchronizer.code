/** 
 * Obtain a connection to a target given the connection  {@code key}.
 * @param key the connection {@code key}.
 * @return
 */
private Sync<K,T,F> getSynchronizer(K key){
  if (closed) {
    throw new IllegalStateException("ConnectionProvider is already closed");
  }
  Sync<K,T,F> sync=connections.get(key);
  if (sync != null) {
    return sync;
  }
  AtomicBoolean atomicBoolean=new AtomicBoolean();
  sync=connections.computeIfAbsent(key,connectionKey -> {
    Sync<K,T,F> createdSync=new Sync<>(key,connectionFactory.apply(key));
    if (closed) {
      createdSync.cancel();
    }
    return createdSync;
  }
);
  if (atomicBoolean.compareAndSet(false,true)) {
    sync.getConnection().whenComplete((c,t) -> {
      if (t != null) {
        connections.remove(key);
      }
    }
);
  }
  return sync;
}
