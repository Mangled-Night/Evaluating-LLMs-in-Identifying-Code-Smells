/** 
 * One element of the Redis pub/sub stream. May be a message or notification of subscription details.
 * @param < K > Key type.
 * @param < V > Value type.
 * @author Will Glozer
 * @author Mark Paluch
 */
public class PubSubOutput<K,V> extends CommandOutput<K,V,V> implements PubSubMessage<K,V> {
  public enum Type {  message,   pmessage,   psubscribe,   punsubscribe,   subscribe,   unsubscribe;   private final static Set<String> names=new HashSet<>();
static {
    for (    Type value : Type.values()) {
      names.add(value.name());
    }
  }
  public static boolean isPubSubType(  String name){
    return names.contains(name);
  }
}
  private Type type;
  private K channel;
  private K pattern;
  private long count;
  private boolean completed;
  public PubSubOutput(  RedisCodec<K,V> codec){
    super(codec,null);
  }
  public Type type(){
    return type;
  }
  public K channel(){
    return channel;
  }
  public K pattern(){
    return pattern;
  }
  public long count(){
    return count;
  }
  @Override @SuppressWarnings({"fallthrough","unchecked"}) public void set(  ByteBuffer bytes){
    if (bytes == null) {
      return;
    }
    if (type == null) {
      type=Type.valueOf(decodeAscii(bytes));
      return;
    }
    handleOutput(bytes);
  }
  @SuppressWarnings("unchecked") private void handleOutput(  ByteBuffer bytes){
switch (type) {
case pmessage:
      if (pattern == null) {
        pattern=codec.decodeKey(bytes);
        break;
      }
case message:
    if (channel == null) {
      channel=codec.decodeKey(bytes);
      break;
    }
  output=codec.decodeValue(bytes);
completed=true;
break;
case psubscribe:
case punsubscribe:
pattern=codec.decodeKey(bytes);
break;
case subscribe:
case unsubscribe:
channel=codec.decodeKey(bytes);
break;
default :
throw new UnsupportedOperationException("Operation " + type + " not supported");
}
}
@Override public void set(long integer){
count=integer;
completed=true;
}
boolean isCompleted(){
return completed;
}
@Override public V body(){
return output;
}
}
