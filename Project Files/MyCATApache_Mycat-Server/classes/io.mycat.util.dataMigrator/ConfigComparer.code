/** 
 * 数据迁移新旧配置文件加载、对比
 * @author haonan108
 */
public class ConfigComparer {
  private static final Logger LOGGER=LoggerFactory.getLogger(ConfigComparer.class);
  private final static String TABLES_FILE="/migrateTables.properties";
  private final static String NEW_SCHEMA="/newSchema.xml";
  private final static String NEW_RULE="/newRule.xml";
  private final static String DN_INDEX_FILE="/dnindex.properties";
  private SchemaLoader oldLoader;
  private SchemaLoader newLoader;
  private Map<String,DataHostConfig> oldDataHosts;
  private Map<String,DataNodeConfig> oldDataNodes;
  private Map<String,SchemaConfig> oldSchemas;
  private Map<String,DataHostConfig> newDataHosts;
  private Map<String,DataNodeConfig> newDataNodes;
  private Map<String,SchemaConfig> newSchemas;
  private boolean isAwaysUseMaster;
  private Properties dnIndexProps;
  private List<TableMigrateInfo> migratorTables=new ArrayList<TableMigrateInfo>();
  public ConfigComparer(  boolean isAwaysUseMaster) throws Exception {
    this.isAwaysUseMaster=isAwaysUseMaster;
    loadOldConfig();
    loadNewConfig();
    loadTablesFile();
  }
  public List<TableMigrateInfo> getMigratorTables(){
    return migratorTables;
  }
  private void loadOldConfig(){
    try {
      oldLoader=new XMLSchemaLoader();
      oldDataHosts=oldLoader.getDataHosts();
      oldDataNodes=oldLoader.getDataNodes();
      oldSchemas=oldLoader.getSchemas();
    }
 catch (    Exception e) {
      throw new ConfigException(" old config for migrate read fail!please check schema.xml or  rule.xml  " + e);
    }
  }
  private void loadNewConfig(){
    try {
      newLoader=new XMLSchemaLoader(NEW_SCHEMA,NEW_RULE);
      newDataHosts=newLoader.getDataHosts();
      newDataNodes=newLoader.getDataNodes();
      newSchemas=newLoader.getSchemas();
    }
 catch (    Exception e) {
      throw new ConfigException(" new config for migrate read fail!please check newSchema.xml or  newRule.xml  " + e);
    }
  }
  private void loadTablesFile() throws Exception {
    Properties pro=new Properties();
    if (!isAwaysUseMaster) {
      dnIndexProps=loadDnIndexProps();
    }
    try {
      pro.load(ConfigComparer.class.getResourceAsStream(TABLES_FILE));
    }
 catch (    Exception e) {
      throw new ConfigException("tablesFile.properties read fail!");
    }
    Iterator<Entry<Object,Object>> it=pro.entrySet().iterator();
    while (it.hasNext()) {
      Entry<Object,Object> entry=it.next();
      String schemaName=entry.getKey().toString();
      String tables=entry.getValue().toString();
      loadMigratorTables(schemaName,getTables(tables));
    }
  }
  private String[] getTables(  String tables){
    if (tables.equalsIgnoreCase("all") || tables.isEmpty()) {
      return new String[]{};
    }
 else {
      return tables.split(",");
    }
  }
  private void loadMigratorTables(  String schemaName,  String[] tables){
    if (!DataMigratorUtil.isKeyExistIgnoreCase(oldSchemas,schemaName)) {
      throw new ConfigException("oldSchema:" + schemaName + " is not exists!");
    }
    if (!DataMigratorUtil.isKeyExistIgnoreCase(newSchemas,schemaName)) {
      throw new ConfigException("newSchema:" + schemaName + " is not exists!");
    }
    Map<String,TableConfig> oldTables=DataMigratorUtil.getValueIgnoreCase(oldSchemas,schemaName).getTables();
    Map<String,TableConfig> newTables=DataMigratorUtil.getValueIgnoreCase(newSchemas,schemaName).getTables();
    if (tables.length > 0) {
      for (int i=0; i < tables.length; i++) {
        TableConfig oldTable=DataMigratorUtil.getValueIgnoreCase(oldTables,tables[i]);
        TableConfig newTable=DataMigratorUtil.getValueIgnoreCase(newTables,tables[i]);
        loadMigratorTable(oldTable,newTable,schemaName,tables[i]);
      }
    }
 else {
      Set<String> oldSet=oldTables.keySet();
      Set<String> newSet=newTables.keySet();
      if (!oldSet.equals(newSet)) {
        throw new ConfigException("new & old table config is not equal!");
      }
      for (      String tableName : oldSet) {
        TableConfig oldTable=oldTables.get(tableName);
        TableConfig newTable=newTables.get(tableName);
        loadMigratorTable(oldTable,newTable,schemaName,tableName);
      }
    }
  }
  private void loadMigratorTable(  TableConfig oldTable,  TableConfig newTable,  String schemaName,  String tableName){
    if (oldTable == null || newTable == null) {
      throw new ConfigException("please check tableFile.properties,make sure " + schemaName + ":"+ tableName+ " is sharding table ");
    }
    if (oldTable.isGlobalTable() || newTable.isGlobalTable()) {
      String message="global table: " + schemaName + ":"+ tableName+ " is ignore!";
      System.out.println("Warn: " + message);
      LOGGER.warn(message);
    }
 else {
      List<DataNode> oldDN=getDataNodes(oldTable,oldDataNodes,oldDataHosts);
      List<DataNode> newDN=getDataNodes(newTable,newDataNodes,newDataHosts);
      if (isNeedMigrate(oldDN,newDN)) {
        LOGGER.info("old table:{}",oldTable);
        LOGGER.info("new table:{}",newTable);
        if (oldTable.getRule() == null) {
          LOGGER.info("beacuse {} rule is null,skip it,check it is er child table",oldTable);
          return;
        }
        if (newTable.getRule() == null) {
          LOGGER.info("beacuse {} rule is null,skip it,check it is er child table.",newTable);
          return;
        }
        checkRuleConfig(oldTable.getRule(),newTable.getRule(),schemaName,tableName);
        RuleConfig newRC=newTable.getRule();
        TableMigrateInfo tmi=new TableMigrateInfo(schemaName,tableName,oldDN,newDN,newRC.getRuleAlgorithm(),newRC.getColumn());
        migratorTables.add(tmi);
      }
 else {
        String message=schemaName + ":" + tableName+ " is ignore,no need to migrate!";
        LOGGER.warn(message);
        System.out.println("Warn: " + message);
      }
    }
  }
  private boolean isNeedMigrate(  List<DataNode> oldDN,  List<DataNode> newDN){
    if (oldDN.size() != newDN.size()) {
      return true;
    }
    return false;
  }
  private List<DataNode> getDataNodes(  TableConfig tableConfig,  Map<String,DataNodeConfig> dnConfig,  Map<String,DataHostConfig> dhConfig){
    List<DataNode> dataNodes=new ArrayList<DataNode>();
    ArrayList<String> dataNodeNames=tableConfig.getDataNodes();
    int i=0;
    for (    String name : dataNodeNames) {
      DataNodeConfig config=dnConfig.get(name);
      String db=config.getDatabase();
      String dataHost=config.getDataHost();
      DataHostConfig dh=dhConfig.get(dataHost);
      String dbType=dh.getDbType();
      DBHostConfig[] writeHosts=dh.getWriteHosts();
      DBHostConfig currentWriteHost;
      if (isAwaysUseMaster) {
        currentWriteHost=writeHosts[0];
      }
 else {
        currentWriteHost=writeHosts[Integer.valueOf(dnIndexProps.getProperty(dh.getName()))];
      }
      DataNode dn=new DataNode(name,currentWriteHost.getIp(),currentWriteHost.getPort(),currentWriteHost.getUser(),currentWriteHost.getPassword(),db,dbType,i++);
      dataNodes.add(dn);
    }
    return dataNodes;
  }
  private void checkRuleConfig(  RuleConfig oldRC,  RuleConfig newRC,  String schemaName,  String tableName){
    if (!oldRC.getColumn().equalsIgnoreCase(newRC.getColumn())) {
      throw new ConfigException(schemaName + ":" + tableName+ " old & new partition column is not same!");
    }
    AbstractPartitionAlgorithm oldAlg=oldRC.getRuleAlgorithm();
    AbstractPartitionAlgorithm newAlg=newRC.getRuleAlgorithm();
    if (!oldAlg.getClass().isAssignableFrom(newAlg.getClass())) {
      throw new ConfigException(schemaName + ":" + tableName+ " old & new rule Algorithm is not same!");
    }
  }
  private Properties loadDnIndexProps(){
    Properties prop=new Properties();
    InputStream is=null;
    try {
      is=ConfigComparer.class.getResourceAsStream(DN_INDEX_FILE);
      prop.load(is);
    }
 catch (    Exception e) {
      throw new ConfigException("please check file \"dnindex.properties\" " + e.getMessage());
    }
 finally {
      try {
        if (is != null) {
          is.close();
        }
      }
 catch (      IOException e) {
        throw new ConfigException(e.getMessage());
      }
    }
    return prop;
  }
}
