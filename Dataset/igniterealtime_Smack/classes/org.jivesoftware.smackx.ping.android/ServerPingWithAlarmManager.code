/** 
 * Send automatic server pings with the help of  {@link AlarmManager}. <p> Smack's  {@link PingManager} uses a <code>ScheduledThreadPoolExecutor</code> to schedule theautomatic server pings, but on Android, those scheduled pings are not reliable. This is because the Android device may go into deep sleep where the system will not continue to run this causes <ul> <li>the system time to not move forward, which means that the time spent in deep sleep is not counted towards the scheduled delay time</li> <li>the scheduled Runnable is not run while the system is in deep sleep.</li> </ul> <p> That is the reason Android comes with an API to schedule those tasks: AlarmManager. Which this class uses to determine every 30 minutes if a server ping is necessary. The interval of 30 minutes is the ideal trade-off between reliability and low resource (battery) consumption. </p> <p> In order to use this class you need to call  {@link #onCreate(Context)} <b>once</b>, for examplein the <code>onCreate()</code> method of your Service holding the XMPPConnection. And to avoid leaking any resources, you should call  {@link #onDestroy()} when you no longer need any of itsfunctionality. </p>
 */
public final class ServerPingWithAlarmManager extends Manager {
  private static final Logger LOGGER=Logger.getLogger(ServerPingWithAlarmManager.class.getName());
  private static final String PING_ALARM_ACTION="org.igniterealtime.smackx.ping.ACTION";
  private static final Map<XMPPConnection,ServerPingWithAlarmManager> INSTANCES=new WeakHashMap<XMPPConnection,ServerPingWithAlarmManager>();
static {
    XMPPConnectionRegistry.addConnectionCreationListener(new ConnectionCreationListener(){
      @Override public void connectionCreated(      XMPPConnection connection){
        getInstanceFor(connection);
      }
    }
);
  }
  /** 
 * Get the instance of this manager for the given connection.
 * @param connection the connection.
 * @return the instance of this manager for the given connection.
 */
  public static synchronized ServerPingWithAlarmManager getInstanceFor(  XMPPConnection connection){
    ServerPingWithAlarmManager serverPingWithAlarmManager=INSTANCES.get(connection);
    if (serverPingWithAlarmManager == null) {
      serverPingWithAlarmManager=new ServerPingWithAlarmManager(connection);
      INSTANCES.put(connection,serverPingWithAlarmManager);
    }
    return serverPingWithAlarmManager;
  }
  private boolean mEnabled=true;
  private ServerPingWithAlarmManager(  XMPPConnection connection){
    super(connection);
  }
  /** 
 * If enabled, ServerPingWithAlarmManager will call  {@link PingManager#pingServerIfNecessary()}for the connection of this instance every half hour.
 * @param enabled whether or not this manager is should be enabled or not.
 */
  public void setEnabled(  boolean enabled){
    mEnabled=enabled;
  }
  /** 
 * Check if this manager is enabled.
 * @return <code>true</code> if this manager is enabled, <code>false</code> otherwise.
 */
  public boolean isEnabled(){
    return mEnabled;
  }
  private static final BroadcastReceiver ALARM_BROADCAST_RECEIVER=new BroadcastReceiver(){
    @Override public void onReceive(    Context context,    Intent intent){
      LOGGER.fine("Ping Alarm broadcast received");
      Set<Map.Entry<XMPPConnection,ServerPingWithAlarmManager>> managers;
synchronized (ServerPingWithAlarmManager.class) {
        managers=new HashSet<>(INSTANCES.entrySet());
      }
      for (      Map.Entry<XMPPConnection,ServerPingWithAlarmManager> entry : managers) {
        XMPPConnection connection=entry.getKey();
        if (entry.getValue().isEnabled()) {
          LOGGER.fine("Calling pingServerIfNecessary for connection " + connection);
          final PingManager pingManager=PingManager.getInstanceFor(connection);
          Async.go(new Runnable(){
            @Override public void run(){
              pingManager.pingServerIfNecessary();
            }
          }
,"PingServerIfNecessary (" + connection.getConnectionCounter() + ')');
        }
 else {
          LOGGER.fine("NOT calling pingServerIfNecessary (disabled) on connection " + connection.getConnectionCounter());
        }
      }
    }
  }
;
  private static Context sContext;
  private static PendingIntent sPendingIntent;
  private static AlarmManager sAlarmManager;
  /** 
 * Register a pending intent with the AlarmManager to be broadcasted every half hour and register the alarm broadcast receiver to receive this intent. The receiver will check all known questions if a ping is Necessary when invoked by the alarm intent.
 * @param context an Android context.
 */
  public static void onCreate(  Context context){
    sContext=context;
    context.registerReceiver(ALARM_BROADCAST_RECEIVER,new IntentFilter(PING_ALARM_ACTION));
    sAlarmManager=(AlarmManager)context.getSystemService(Context.ALARM_SERVICE);
    sPendingIntent=PendingIntent.getBroadcast(context,0,new Intent(PING_ALARM_ACTION),0);
    sAlarmManager.setInexactRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP,SystemClock.elapsedRealtime() + AlarmManager.INTERVAL_HALF_HOUR,AlarmManager.INTERVAL_HALF_HOUR,sPendingIntent);
  }
  /** 
 * Unregister the alarm broadcast receiver and cancel the alarm.
 */
  public static void onDestroy(){
    sContext.unregisterReceiver(ALARM_BROADCAST_RECEIVER);
    sAlarmManager.cancel(sPendingIntent);
  }
}
