/** 
 * Convert a byte array to a long value
 * @param buf
 * @return
 * @throws NumberFormatException
 */
public static long getLong(byte[] buf) throws NumberFormatException {
  return getLong(buf,0,buf.length);
}
public static long getLong(byte[] buf,int offset,int endpos) throws NumberFormatException {
  byte base=10;
  int s;
  for (s=offset; s < endpos && Character.isWhitespace((char)buf[s]); ++s) {
    ;
  }
  if (s == endpos) {
    throw new NumberFormatException(toString(buf));
  }
 else {
    boolean negative=false;
    if ((char)buf[s] == 45) {
      negative=true;
      ++s;
    }
 else     if ((char)buf[s] == 43) {
      ++s;
    }
    int save=s;
    long cutoff=9223372036854775807L / (long)base;
    long cutlim=(long)((int)(9223372036854775807L % (long)base));
    if (negative) {
      ++cutlim;
    }
    boolean overflow=false;
    long i;
    for (i=0L; s < endpos; ++s) {
      char c=(char)buf[s];
      if (Character.isDigit(c)) {
        c=(char)(c - 48);
      }
 else {
        if (!Character.isLetter(c)) {
          break;
        }
        c=(char)(Character.toUpperCase(c) - 65 + 10);
      }
      if (c >= base) {
        break;
      }
      if (i <= cutoff && (i != cutoff || (long)c <= cutlim)) {
        i*=(long)base;
        i+=(long)c;
      }
 else {
        overflow=true;
      }
    }
    if (s == save) {
      throw new NumberFormatException(toString(buf));
    }
 else     if (overflow) {
      throw new NumberFormatException(toString(buf));
    }
 else {
      return negative ? -i : i;
    }
  }
}
