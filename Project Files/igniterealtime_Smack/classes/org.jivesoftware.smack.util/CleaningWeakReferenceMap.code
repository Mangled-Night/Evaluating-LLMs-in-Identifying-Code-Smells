/** 
 * Extends a  {@link HashMap} with {@link WeakReference} values, so thatweak references which have been cleared are periodically removed from the map. The cleaning occurs as part of  {@link #put}, after a specific number ( {@link #cleanInterval}) of calls to  {@link #put}.
 * @param < K > The key type.
 * @param < V > The value type.
 * @author Boris Grozev
 */
public class CleaningWeakReferenceMap<K,V> extends HashMap<K,WeakReference<V>> {
  private static final long serialVersionUID=0L;
  /** 
 * The number of calls to  {@link #put} after which to clean this map(i.e. remove cleared  {@link WeakReference}s from it).
 */
  private final int cleanInterval;
  /** 
 * The number of times  {@link #put} has been called on this instancesince the last time it was  {@link #clean}ed.
 */
  private int numberOfInsertsSinceLastClean=0;
  /** 
 * Initializes a new  {@link CleaningWeakReferenceMap} instance with thedefault clean interval.
 */
  public CleaningWeakReferenceMap(){
    this(50);
  }
  /** 
 * Initializes a new  {@link CleaningWeakReferenceMap} instance with a givenclean interval.
 * @param cleanInterval the number of calls to {@link #put} after which themap will clean itself.
 */
  public CleaningWeakReferenceMap(  int cleanInterval){
    this.cleanInterval=cleanInterval;
  }
  @Override public WeakReference<V> put(  K key,  WeakReference<V> value){
    WeakReference<V> ret=super.put(key,value);
    if (numberOfInsertsSinceLastClean++ > cleanInterval) {
      numberOfInsertsSinceLastClean=0;
      clean();
    }
    return ret;
  }
  /** 
 * Removes all cleared entries from this map (i.e. entries whose value is a cleared  {@link WeakReference}).
 */
  private void clean(){
    Iterator<Entry<K,WeakReference<V>>> iter=entrySet().iterator();
    while (iter.hasNext()) {
      Entry<K,WeakReference<V>> e=iter.next();
      if (e != null && e.getValue() != null && e.getValue().get() == null) {
        iter.remove();
      }
    }
  }
}
