/** 
 * Invocation-handler to synchronize API calls which use Futures as backend. This class leverages the need to implement a full sync class which just delegates every request.
 * @author Mark Paluch
 * @author Tz Zhuo
 * @since 3.0
 */
class FutureSyncInvocationHandler extends AbstractInvocationHandler {
  private final StatefulConnection<?,?> connection;
  private final TimeoutProvider timeoutProvider;
  private final Object asyncApi;
  private final MethodTranslator translator;
  FutureSyncInvocationHandler(  StatefulConnection<?,?> connection,  Object asyncApi,  Class<?>[] interfaces){
    this.connection=connection;
    this.timeoutProvider=new TimeoutProvider(() -> connection.getOptions().getTimeoutOptions(),() -> connection.getTimeout().toNanos());
    this.asyncApi=asyncApi;
    this.translator=MethodTranslator.of(asyncApi.getClass(),interfaces);
  }
  @Override protected Object handleInvocation(  Object proxy,  Method method,  Object[] args) throws Throwable {
    try {
      Method targetMethod=this.translator.get(method);
      Object result=targetMethod.invoke(asyncApi,args);
      if (result instanceof RedisFuture<?>) {
        RedisFuture<?> command=(RedisFuture<?>)result;
        if (!isTxControlMethod(method.getName(),args) && isTransactionActive(connection)) {
          return null;
        }
        long timeout=getTimeoutNs(command);
        return Futures.awaitOrCancel(command,timeout,TimeUnit.NANOSECONDS);
      }
      return result;
    }
 catch (    InvocationTargetException e) {
      throw e.getTargetException();
    }
  }
  private long getTimeoutNs(  RedisFuture<?> command){
    if (command instanceof RedisCommand) {
      return timeoutProvider.getTimeoutNs((RedisCommand)command);
    }
    return connection.getTimeout().toNanos();
  }
  private static boolean isTransactionActive(  StatefulConnection<?,?> connection){
    return connection instanceof StatefulRedisConnection && ((StatefulRedisConnection)connection).isMulti();
  }
  private static boolean isTxControlMethod(  String methodName,  Object[] args){
    if (methodName.equals("exec") || methodName.equals("multi") || methodName.equals("discard")) {
      return true;
    }
    if (methodName.equals("dispatch") && args.length > 0 && args[0] instanceof ProtocolKeyword) {
      ProtocolKeyword keyword=(ProtocolKeyword)args[0];
      if (keyword.name().equals(CommandType.MULTI.name()) || keyword.name().equals(CommandType.EXEC.name()) || keyword.name().equals(CommandType.DISCARD.name())) {
        return true;
      }
    }
    return false;
  }
}
