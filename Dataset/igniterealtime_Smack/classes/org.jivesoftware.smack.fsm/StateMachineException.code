public abstract class StateMachineException extends SmackException {
  private static final long serialVersionUID=1L;
  protected StateMachineException(  String message){
    super(message);
  }
  protected StateMachineException(){
    super();
  }
public static class SmackMandatoryStateFailedException extends StateMachineException {
    private static final long serialVersionUID=1L;
    public SmackMandatoryStateFailedException(    State state,    StateTransitionResult failureReason){
    }
  }
public static final class SmackStateGraphDeadEndException extends StateMachineException {
    private final List<State> walkedStateGraphPath;
    private final Map<State,StateTransitionResult> failedStates;
    private final StateDescriptor deadEndState;
    private static final long serialVersionUID=1L;
    private SmackStateGraphDeadEndException(    String message,    WalkStateGraphContext walkStateGraphContext,    GraphVertex<State> stateVertex){
      super(message);
      this.walkedStateGraphPath=Collections.unmodifiableList(walkStateGraphContext.getWalk());
      this.failedStates=Collections.unmodifiableMap(walkStateGraphContext.getFailedStates());
      deadEndState=stateVertex.getElement().getStateDescriptor();
    }
    public List<State> getWalkedStateGraph(){
      return walkedStateGraphPath;
    }
    public Map<State,StateTransitionResult> getFailedStates(){
      return failedStates;
    }
    public StateDescriptor getDeadEndState(){
      return deadEndState;
    }
    public static SmackStateGraphDeadEndException from(    WalkStateGraphContext walkStateGraphContext,    GraphVertex<State> stateVertex){
      String message=stateVertex + " has no successor vertexes";
      return new SmackStateGraphDeadEndException(message,walkStateGraphContext,stateVertex);
    }
  }
}
