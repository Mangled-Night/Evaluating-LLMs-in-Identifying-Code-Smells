public static class ShadowDrawable extends DrawableWrapper {
  private static final double COS_45=Math.cos(Math.toRadians(45));
  private float mShadowMultiplier=1f;
  private float mShadowTopScale=1f;
  private float mShadowHorizScale=1f;
  private float mShadowBottomScale=1f;
  private Paint mCornerShadowPaint;
  private Paint mEdgeShadowPaint;
  private RectF mContentBounds;
  private float mCornerRadius;
  private Path mCornerShadowPath;
  private float mMaxShadowSize;
  private float mRawMaxShadowSize;
  private float mShadowSize;
  private float mRawShadowSize;
  private boolean mDirty=true;
  private final int mShadowStartColor;
  private final int mShadowEndColor;
  private boolean mAddPaddingForCorners=false;
  private float mRotation;
  private boolean isCircle;
  public ShadowDrawable(  Drawable content,  float radius,  float shadowSize,  float maxShadowSize,  int shadowColor,  boolean isCircle){
    super(content);
    mShadowStartColor=shadowColor;
    mShadowEndColor=mShadowStartColor & 0x00ffffff;
    this.isCircle=isCircle;
    if (isCircle) {
      mShadowMultiplier=1;
      mShadowTopScale=1;
      mShadowHorizScale=1;
      mShadowBottomScale=1;
    }
    mCornerShadowPaint=new Paint(Paint.ANTI_ALIAS_FLAG | Paint.DITHER_FLAG);
    mCornerShadowPaint.setStyle(Paint.Style.FILL);
    mCornerRadius=Math.round(radius);
    mContentBounds=new RectF();
    mEdgeShadowPaint=new Paint(mCornerShadowPaint);
    mEdgeShadowPaint.setAntiAlias(false);
    setShadowSize(shadowSize,maxShadowSize);
  }
  /** 
 * Casts the value to an even integer.
 */
  private static int toEven(  float value){
    int i=Math.round(value);
    return (i % 2 == 1) ? i - 1 : i;
  }
  public void setAddPaddingForCorners(  boolean addPaddingForCorners){
    mAddPaddingForCorners=addPaddingForCorners;
    invalidateSelf();
  }
  @Override public void setAlpha(  int alpha){
    super.setAlpha(alpha);
    mCornerShadowPaint.setAlpha(alpha);
    mEdgeShadowPaint.setAlpha(alpha);
  }
  @Override protected void onBoundsChange(  Rect bounds){
    mDirty=true;
  }
  void setShadowSize(  float shadowSize,  float maxShadowSize){
    if (shadowSize < 0 || maxShadowSize < 0) {
      throw new IllegalArgumentException("invalid shadow size");
    }
    shadowSize=toEven(shadowSize);
    maxShadowSize=toEven(maxShadowSize);
    if (shadowSize > maxShadowSize) {
      shadowSize=maxShadowSize;
    }
    if (mRawShadowSize == shadowSize && mRawMaxShadowSize == maxShadowSize) {
      return;
    }
    mRawShadowSize=shadowSize;
    mRawMaxShadowSize=maxShadowSize;
    mShadowSize=Math.round(shadowSize * mShadowMultiplier);
    mMaxShadowSize=maxShadowSize;
    mDirty=true;
    invalidateSelf();
  }
  @Override public boolean getPadding(  Rect padding){
    int vOffset=(int)Math.ceil(calculateVerticalPadding(mRawMaxShadowSize,mCornerRadius,mAddPaddingForCorners));
    int hOffset=(int)Math.ceil(calculateHorizontalPadding(mRawMaxShadowSize,mCornerRadius,mAddPaddingForCorners));
    padding.set(hOffset,vOffset,hOffset,vOffset);
    return true;
  }
  private float calculateVerticalPadding(  float maxShadowSize,  float cornerRadius,  boolean addPaddingForCorners){
    if (addPaddingForCorners) {
      return (float)(maxShadowSize * mShadowMultiplier + (1 - COS_45) * cornerRadius);
    }
 else {
      return maxShadowSize * mShadowMultiplier;
    }
  }
  private static float calculateHorizontalPadding(  float maxShadowSize,  float cornerRadius,  boolean addPaddingForCorners){
    if (addPaddingForCorners) {
      return (float)(maxShadowSize + (1 - COS_45) * cornerRadius);
    }
 else {
      return maxShadowSize;
    }
  }
  @Override public int getOpacity(){
    return PixelFormat.TRANSLUCENT;
  }
  public void setCornerRadius(  float radius){
    radius=Math.round(radius);
    if (mCornerRadius == radius) {
      return;
    }
    mCornerRadius=radius;
    mDirty=true;
    invalidateSelf();
  }
  @Override public void draw(  Canvas canvas){
    if (mDirty) {
      buildComponents(getBounds());
      mDirty=false;
    }
    drawShadow(canvas);
    super.draw(canvas);
  }
  final void setRotation(  float rotation){
    if (mRotation != rotation) {
      mRotation=rotation;
      invalidateSelf();
    }
  }
  private void drawShadow(  Canvas canvas){
    if (isCircle) {
      int saved=canvas.save();
      canvas.translate(mContentBounds.centerX(),mContentBounds.centerY());
      canvas.drawPath(mCornerShadowPath,mCornerShadowPaint);
      canvas.restoreToCount(saved);
      return;
    }
    final int rotateSaved=canvas.save();
    canvas.rotate(mRotation,mContentBounds.centerX(),mContentBounds.centerY());
    final float edgeShadowTop=-mCornerRadius - mShadowSize;
    final float shadowOffset=mCornerRadius;
    final boolean drawHorizontalEdges=mContentBounds.width() - 2 * shadowOffset > 0;
    final boolean drawVerticalEdges=mContentBounds.height() - 2 * shadowOffset > 0;
    final float shadowOffsetTop=mRawShadowSize - (mRawShadowSize * mShadowTopScale);
    final float shadowOffsetHorizontal=mRawShadowSize - (mRawShadowSize * mShadowHorizScale);
    final float shadowOffsetBottom=mRawShadowSize - (mRawShadowSize * mShadowBottomScale);
    final float shadowScaleHorizontal=shadowOffset == 0 ? 1 : shadowOffset / (shadowOffset + shadowOffsetHorizontal);
    final float shadowScaleTop=shadowOffset == 0 ? 1 : shadowOffset / (shadowOffset + shadowOffsetTop);
    final float shadowScaleBottom=shadowOffset == 0 ? 1 : shadowOffset / (shadowOffset + shadowOffsetBottom);
    int saved=canvas.save();
    canvas.translate(mContentBounds.left + shadowOffset,mContentBounds.top + shadowOffset);
    canvas.scale(shadowScaleHorizontal,shadowScaleTop);
    canvas.drawPath(mCornerShadowPath,mCornerShadowPaint);
    if (drawHorizontalEdges) {
      canvas.scale(1f / shadowScaleHorizontal,1f);
      canvas.drawRect(0,edgeShadowTop,mContentBounds.width() - 2 * shadowOffset,-mCornerRadius,mEdgeShadowPaint);
    }
    canvas.restoreToCount(saved);
    saved=canvas.save();
    canvas.translate(mContentBounds.right - shadowOffset,mContentBounds.bottom - shadowOffset);
    canvas.scale(shadowScaleHorizontal,shadowScaleBottom);
    canvas.rotate(180f);
    canvas.drawPath(mCornerShadowPath,mCornerShadowPaint);
    if (drawHorizontalEdges) {
      canvas.scale(1f / shadowScaleHorizontal,1f);
      canvas.drawRect(0,edgeShadowTop,mContentBounds.width() - 2 * shadowOffset,-mCornerRadius,mEdgeShadowPaint);
    }
    canvas.restoreToCount(saved);
    saved=canvas.save();
    canvas.translate(mContentBounds.left + shadowOffset,mContentBounds.bottom - shadowOffset);
    canvas.scale(shadowScaleHorizontal,shadowScaleBottom);
    canvas.rotate(270f);
    canvas.drawPath(mCornerShadowPath,mCornerShadowPaint);
    if (drawVerticalEdges) {
      canvas.scale(1f / shadowScaleBottom,1f);
      canvas.drawRect(0,edgeShadowTop,mContentBounds.height() - 2 * shadowOffset,-mCornerRadius,mEdgeShadowPaint);
    }
    canvas.restoreToCount(saved);
    saved=canvas.save();
    canvas.translate(mContentBounds.right - shadowOffset,mContentBounds.top + shadowOffset);
    canvas.scale(shadowScaleHorizontal,shadowScaleTop);
    canvas.rotate(90f);
    canvas.drawPath(mCornerShadowPath,mCornerShadowPaint);
    if (drawVerticalEdges) {
      canvas.scale(1f / shadowScaleTop,1f);
      canvas.drawRect(0,edgeShadowTop,mContentBounds.height() - 2 * shadowOffset,-mCornerRadius,mEdgeShadowPaint);
    }
    canvas.restoreToCount(saved);
    canvas.restoreToCount(rotateSaved);
  }
  private void buildShadowCorners(){
    if (isCircle) {
      float size=mContentBounds.width() / 2 - 1f;
      RectF innerBounds=new RectF(-size,-size,size,size);
      RectF outerBounds=new RectF(innerBounds);
      outerBounds.inset(-mShadowSize,-mShadowSize);
      if (mCornerShadowPath == null) {
        mCornerShadowPath=new Path();
      }
 else {
        mCornerShadowPath.reset();
      }
      mCornerShadowPath.setFillType(Path.FillType.EVEN_ODD);
      mCornerShadowPath.moveTo(-size,0);
      mCornerShadowPath.rLineTo(-mShadowSize,0);
      mCornerShadowPath.arcTo(outerBounds,180f,180f,false);
      mCornerShadowPath.arcTo(outerBounds,0f,180f,false);
      mCornerShadowPath.arcTo(innerBounds,180f,180f,false);
      mCornerShadowPath.arcTo(innerBounds,0f,180f,false);
      mCornerShadowPath.close();
      float shadowRadius=-outerBounds.top;
      if (shadowRadius > 0f) {
        float startRatio=size / shadowRadius;
        mCornerShadowPaint.setShader(new RadialGradient(0,0,shadowRadius,new int[]{0,mShadowStartColor,mShadowEndColor},new float[]{0.0F,startRatio,1.0F},Shader.TileMode.CLAMP));
      }
      return;
    }
    RectF innerBounds=new RectF(-mCornerRadius,-mCornerRadius,mCornerRadius,mCornerRadius);
    RectF outerBounds=new RectF(innerBounds);
    outerBounds.inset(-mShadowSize,-mShadowSize);
    if (mCornerShadowPath == null) {
      mCornerShadowPath=new Path();
    }
 else {
      mCornerShadowPath.reset();
    }
    mCornerShadowPath.setFillType(Path.FillType.EVEN_ODD);
    mCornerShadowPath.moveTo(-mCornerRadius,0);
    mCornerShadowPath.rLineTo(-mShadowSize,0);
    mCornerShadowPath.arcTo(outerBounds,180f,90f,false);
    mCornerShadowPath.arcTo(innerBounds,270f,-90f,false);
    mCornerShadowPath.close();
    float shadowRadius=-outerBounds.top;
    if (shadowRadius > 0f) {
      float startRatio=mCornerRadius / shadowRadius;
      mCornerShadowPaint.setShader(new RadialGradient(0,0,shadowRadius,new int[]{0,mShadowStartColor,mShadowEndColor},new float[]{0F,startRatio,1F},Shader.TileMode.CLAMP));
    }
    mEdgeShadowPaint.setShader(new LinearGradient(0,innerBounds.top,0,outerBounds.top,mShadowStartColor,mShadowEndColor,Shader.TileMode.CLAMP));
    mEdgeShadowPaint.setAntiAlias(false);
  }
  private void buildComponents(  Rect bounds){
    if (isCircle) {
      mCornerRadius=bounds.width() / 2;
    }
    final float verticalOffset=mRawMaxShadowSize * mShadowMultiplier;
    mContentBounds.set(bounds.left + mRawMaxShadowSize,bounds.top + verticalOffset,bounds.right - mRawMaxShadowSize,bounds.bottom - verticalOffset);
    getWrappedDrawable().setBounds((int)mContentBounds.left,(int)mContentBounds.top,(int)mContentBounds.right,(int)mContentBounds.bottom);
    buildShadowCorners();
  }
  public float getCornerRadius(){
    return mCornerRadius;
  }
  public void setShadowSize(  float size){
    setShadowSize(size,mRawMaxShadowSize);
  }
  public void setMaxShadowSize(  float size){
    setShadowSize(mRawShadowSize,size);
  }
  public float getShadowSize(){
    return mRawShadowSize;
  }
  public float getMaxShadowSize(){
    return mRawMaxShadowSize;
  }
  public float getMinWidth(){
    final float content=2 * Math.max(mRawMaxShadowSize,mCornerRadius + mRawMaxShadowSize / 2);
    return content + mRawMaxShadowSize * 2;
  }
  public float getMinHeight(){
    final float content=2 * Math.max(mRawMaxShadowSize,mCornerRadius + mRawMaxShadowSize * mShadowMultiplier / 2);
    return content + (mRawMaxShadowSize * mShadowMultiplier) * 2;
  }
}
