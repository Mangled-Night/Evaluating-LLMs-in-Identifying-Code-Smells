private void renderEntitiesByMaterial(SetMultimap<Material,EntityRef> meshByMaterial){
  Vector3f cameraPosition=worldRenderer.getActiveCamera().getPosition();
  Quaternionf worldRot=new Quaternionf();
  Vector3f worldPos=new Vector3f();
  Matrix3f normalMatrix=new Matrix3f();
  Matrix4f matrixCameraSpace=new Matrix4f();
  Matrix4f modelViewMatrix=new Matrix4f();
  FloatBuffer tempMatrixBuffer44=BufferUtils.createFloatBuffer(16);
  FloatBuffer tempMatrixBuffer33=BufferUtils.createFloatBuffer(12);
  for (  Material material : meshByMaterial.keySet()) {
    if (material.isRenderable()) {
      material.enable();
      material.setFloat("sunlight",1.0f,true);
      material.setFloat("blockLight",1.0f,true);
      material.setMatrix4("projectionMatrix",worldRenderer.getActiveCamera().getProjectionMatrix(),true);
      material.bindTextures();
      Set<EntityRef> entities=meshByMaterial.get(material);
      lastRendered=entities.size();
      for (      EntityRef entity : entities) {
        MeshComponent meshComp=entity.getComponent(MeshComponent.class);
        LocationComponent location=entity.getComponent(LocationComponent.class);
        if (isHidden(entity,meshComp) || location == null || meshComp.mesh == null) {
          continue;
        }
        Vector3f worldPosition=location.getWorldPosition(new Vector3f());
        if (!worldPosition.isFinite() && !isRelevant(entity,worldPosition)) {
          continue;
        }
        if (meshComp.mesh.isDisposed()) {
          logger.error("Attempted to render disposed mesh");
          continue;
        }
        worldRot.set(location.getWorldRotation(new Quaternionf()));
        worldPos.set(location.getWorldPosition(new Vector3f()));
        float worldScale=location.getWorldScale();
        Vector3f offsetFromCamera=worldPos.sub(cameraPosition,new Vector3f());
        matrixCameraSpace.translationRotateScale(offsetFromCamera,worldRot,worldScale);
        AABBf aabb=meshComp.mesh.getAABB().transform(new Matrix4f().translationRotateScale(worldPos,worldRot,worldScale),new AABBf());
        if (worldRenderer.getActiveCamera().hasInSight(aabb)) {
          modelViewMatrix.set(worldRenderer.getActiveCamera().getViewMatrix()).mul(matrixCameraSpace);
          modelViewMatrix.get(tempMatrixBuffer44);
          modelViewMatrix.normal(normalMatrix).get(tempMatrixBuffer33);
          material.setMatrix4("projectionMatrix",worldRenderer.getActiveCamera().getProjectionMatrix(),true);
          material.setMatrix4("modelViewMatrix",tempMatrixBuffer44,true);
          material.setMatrix3("normalMatrix",tempMatrixBuffer33,true);
          material.setFloat3("colorOffset",meshComp.color.rf(),meshComp.color.gf(),meshComp.color.bf(),true);
          material.setFloat("sunlight",worldRenderer.getMainLightIntensityAt(worldPos),true);
          material.setFloat("blockLight",Math.max(worldRenderer.getBlockLightIntensityAt(worldPos),meshComp.selfLuminance),true);
          meshComp.mesh.render();
        }
      }
    }
  }
}
