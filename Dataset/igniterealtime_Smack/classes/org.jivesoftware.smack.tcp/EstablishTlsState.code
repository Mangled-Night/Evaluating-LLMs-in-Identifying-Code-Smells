private final class EstablishTlsState extends State {
  private EstablishTlsState(  EstablishTlsStateDescriptor stateDescriptor,  ModularXmppClientToServerConnectionInternal connectionInternal){
    super(stateDescriptor,connectionInternal);
  }
  @Override public StateTransitionResult.TransitionImpossible isTransitionToPossible(  WalkStateGraphContext walkStateGraphContext) throws SecurityRequiredByClientException, SecurityRequiredByServerException {
    StartTls startTlsFeature=connectionInternal.connection.getFeature(StartTls.class);
    SecurityMode securityMode=connectionInternal.connection.getConfiguration().getSecurityMode();
switch (securityMode) {
case required:
case ifpossible:
      if (startTlsFeature == null) {
        if (securityMode == SecurityMode.ifpossible) {
          return new StateTransitionResult.TransitionImpossibleReason("Server does not announce support for TLS and we do not required it");
        }
        throw new SecurityRequiredByClientException();
      }
    return null;
case disabled:
  if (startTlsFeature != null && startTlsFeature.required()) {
    throw new SecurityRequiredByServerException();
  }
return new StateTransitionResult.TransitionImpossibleReason("TLS disabled in client settings and server does not require it");
default :
throw new AssertionError("Unknown security mode: " + securityMode);
}
}
@Override public StateTransitionResult.AttemptResult transitionInto(WalkStateGraphContext walkStateGraphContext) throws IOException, InterruptedException, SmackException, XMPPException {
connectionInternal.sendAndWaitForResponse(StartTls.INSTANCE,TlsProceed.class,TlsFailure.class);
SmackTlsContext smackTlsContext=connectionInternal.getSmackTlsContext();
tlsState=new TlsState(smackTlsContext);
connectionInternal.addXmppInputOutputFilter(tlsState);
channelSelectedCallbackLock.lock();
try {
pendingOutputFilterData=true;
tlsState.engine.beginHandshake();
tlsState.handshakeStatus=TlsHandshakeStatus.initiated;
}
  finally {
channelSelectedCallbackLock.unlock();
}
connectionInternal.setInterestOps(selectionKey,SelectionKey.OP_WRITE | SelectionKey.OP_READ);
try {
tlsState.waitForHandshakeFinished();
}
 catch (CertificateException e) {
throw new SmackCertificateException(e);
}
connectionInternal.newStreamOpenWaitForFeaturesSequence("stream features after TLS established");
return new TlsEstablishedResult(tlsState.engine);
}
@Override public void resetState(){
tlsState=null;
}
}
