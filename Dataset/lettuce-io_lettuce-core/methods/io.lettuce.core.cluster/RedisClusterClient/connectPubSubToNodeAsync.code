/** 
 * Create a pub/sub connection to a redis socket address.
 * @param codec Use this codec to encode/decode keys and values, must not be {@code null}
 * @param nodeId the nodeId
 * @param socketAddressSupplier supplier for the socket address
 * @param < K > Key type
 * @param < V > Value type
 * @return A new connection
 */
<K,V>ConnectionFuture<StatefulRedisPubSubConnection<K,V>> connectPubSubToNodeAsync(RedisCodec<K,V> codec,String nodeId,Mono<SocketAddress> socketAddressSupplier){
  assertNotNull(codec);
  assertNotEmpty(initialUris);
  LettuceAssert.notNull(socketAddressSupplier,"SocketAddressSupplier must not be null");
  logger.debug("connectPubSubToNode(" + nodeId + ")");
  PubSubEndpoint<K,V> endpoint=new PubSubEndpoint<>(getClusterClientOptions(),getResources());
  RedisChannelWriter writer=endpoint;
  if (CommandExpiryWriter.isSupported(getClusterClientOptions())) {
    writer=new CommandExpiryWriter(writer,getClusterClientOptions(),getResources());
  }
  if (CommandListenerWriter.isSupported(getCommandListeners())) {
    writer=new CommandListenerWriter(writer,getCommandListeners());
  }
  StatefulRedisPubSubConnectionImpl<K,V> connection=new StatefulRedisPubSubConnectionImpl<>(endpoint,writer,codec,getFirstUri().getTimeout());
  ConnectionFuture<StatefulRedisPubSubConnection<K,V>> connectionFuture=connectStatefulAsync(connection,endpoint,getFirstUri(),socketAddressSupplier,() -> new PubSubCommandHandler<>(getClusterClientOptions(),getResources(),codec,endpoint));
  return connectionFuture.whenComplete((conn,throwable) -> {
    if (throwable != null) {
      connection.closeAsync();
    }
  }
);
}
