/** 
 * A chat is a series of messages sent between two users. Each chat has a unique thread ID, which is used to track which messages are part of a particular conversation. Some messages are sent without a thread ID, and some clients don't send thread IDs at all. Therefore, if a message without a thread ID arrives it is routed to the most recently created Chat with the message sender.
 * @author Matt Tucker
 * @deprecated use <code>org.jivesoftware.smack.chat2.Chat</code> from <code>smack-extensions</code> instead.
 */
@Deprecated public class Chat {
  private final ChatManager chatManager;
  private final String threadID;
  private final EntityJid participant;
  private final Set<ChatMessageListener> listeners=new CopyOnWriteArraySet<>();
  /** 
 * Creates a new chat with the specified user and thread ID.
 * @param chatManager the chatManager the chat will use.
 * @param participant the user to chat with.
 * @param threadID the thread ID to use.
 */
  Chat(  ChatManager chatManager,  EntityJid participant,  String threadID){
    if (StringUtils.isEmpty(threadID)) {
      throw new IllegalArgumentException("Thread ID must not be null");
    }
    this.chatManager=chatManager;
    this.participant=participant;
    this.threadID=threadID;
  }
  /** 
 * Returns the thread id associated with this chat, which corresponds to the <code>thread</code> field of XMPP messages. This method may return <code>null</code> if there is no thread ID is associated with this Chat.
 * @return the thread ID of this chat.
 */
  public String getThreadID(){
    return threadID;
  }
  /** 
 * Returns the name of the user the chat is with.
 * @return the name of the user the chat is occuring with.
 */
  public EntityJid getParticipant(){
    return participant;
  }
  /** 
 * Sends the specified text as a message to the other chat participant. This is a convenience method for: <pre> Message message = chat.createMessage(); message.setBody(messageText); chat.sendMessage(message); </pre>
 * @param text the text to send.
 * @throws NotConnectedException if the XMPP connection is not connected.
 * @throws InterruptedException if the calling thread was interrupted.
 */
  public void sendMessage(  String text) throws NotConnectedException, InterruptedException {
    MessageBuilder message=StanzaBuilder.buildMessage().setBody(text);
    sendMessage(message);
  }
  /** 
 * Sends a message to the other chat participant. The thread ID, recipient, and message type of the message will automatically set to those of this chat.
 * @param message the message to send.
 * @throws NotConnectedException if the XMPP connection is not connected.
 * @throws InterruptedException if the calling thread was interrupted.
 */
  public void sendMessage(  MessageBuilder message) throws NotConnectedException, InterruptedException {
    message.to(participant);
    message.ofType(Message.Type.chat);
    message.setThread(threadID);
    chatManager.sendMessage(this,message.build());
  }
  /** 
 * Sends a message to the other chat participant. The thread ID, recipient, and message type of the message will automatically set to those of this chat.
 * @param message the message to send.
 * @throws NotConnectedException if the XMPP connection is not connected.
 * @throws InterruptedException if the calling thread was interrupted.
 */
  public void sendMessage(  Message message) throws NotConnectedException, InterruptedException {
    message.setTo(participant);
    message.setType(Message.Type.chat);
    message.setThread(threadID);
    chatManager.sendMessage(this,message);
  }
  /** 
 * Adds a stanza listener that will be notified of any new messages in the chat.
 * @param listener a stanza listener.
 */
  public void addMessageListener(  ChatMessageListener listener){
    if (listener == null) {
      return;
    }
    listeners.add(listener);
  }
  public void removeMessageListener(  ChatMessageListener listener){
    listeners.remove(listener);
  }
  /** 
 * Closes the Chat and removes all references to it from the  {@link ChatManager}. The chat will be unusable when this method returns, so it's recommend to drop all references to the instance right after calling  {@link #close()}.
 */
  public void close(){
    chatManager.closeChat(this);
    listeners.clear();
  }
  /** 
 * Returns an unmodifiable set of all of the listeners registered with this chat.
 * @return an unmodifiable set of all of the listeners registered with this chat.
 */
  public Set<ChatMessageListener> getListeners(){
    return Collections.unmodifiableSet(listeners);
  }
  /** 
 * Creates a  {@link org.jivesoftware.smack.StanzaCollector} which will accumulate the Messagesfor this chat. Always cancel StanzaCollectors when finished with them as they will accumulate messages indefinitely.
 * @return the StanzaCollector which returns Messages for this chat.
 */
  public StanzaCollector createCollector(){
    return chatManager.createStanzaCollector(this);
  }
  /** 
 * Delivers a message directly to this chat, which will add the message to the collector and deliver it to all listeners registered with the Chat. This is used by the XMPPConnection class to deliver messages without a thread ID.
 * @param message the message.
 */
  void deliver(  Message message){
    message.setThread(threadID);
    for (    ChatMessageListener listener : listeners) {
      listener.processMessage(this,message);
    }
  }
  @Override public String toString(){
    return "Chat [(participant=" + participant + "), (thread="+ threadID+ ")]";
  }
  @Override public int hashCode(){
    int hash=1;
    hash=hash * 31 + threadID.hashCode();
    hash=hash * 31 + participant.hashCode();
    return hash;
  }
  @Override public boolean equals(  Object obj){
    return obj instanceof Chat && threadID.equals(((Chat)obj).getThreadID()) && participant.equals(((Chat)obj).getParticipant());
  }
}
