/** 
 * @see io.mycat.memory.unsafe.ringbuffer.common.event.EventSink#publishEvent(EventTranslator)
 */
@Override public boolean tryPublishEvents(EventTranslator<E>[] translators){
  return false;
}
/** 
 * @see io.mycat.memory.unsafe.ringbuffer.common.event.EventSink#publishEvent(EventTranslator)
 */
@Override public boolean tryPublishEvents(EventTranslator<E>[] translators,int batchStartsAt,int batchSize){
  checkBounds(translators,batchStartsAt,batchSize);
  try {
    final long finalSequence=sequencer.tryNext(batchSize);
    translateAndPublishBatch(translators,batchStartsAt,batchSize,finalSequence);
    return true;
  }
 catch (  InsufficientCapacityException e) {
    return false;
  }
}
/** 
 * @see io.mycat.memory.unsafe.ringbuffer.common.event.EventSink#publishEvent(EventTranslator)
 */
@Override public <A>boolean tryPublishEvents(EventTranslatorOneArg<E,A> translator,A[] arg0){
  return tryPublishEvents(translator,0,arg0.length,arg0);
}
/** 
 * @see io.mycat.memory.unsafe.ringbuffer.common.event.EventSink#publishEvent(EventTranslator)
 */
@Override public <A>boolean tryPublishEvents(EventTranslatorOneArg<E,A> translator,int batchStartsAt,int batchSize,A[] arg0){
  checkBounds(arg0,batchStartsAt,batchSize);
  try {
    final long finalSequence=sequencer.tryNext(batchSize);
    translateAndPublishBatch(translator,arg0,batchStartsAt,batchSize,finalSequence);
    return true;
  }
 catch (  InsufficientCapacityException e) {
    return false;
  }
}
/** 
 * @see io.mycat.memory.unsafe.ringbuffer.common.event.EventSink#publishEvent(EventTranslator)
 */
@Override public <A,B>boolean tryPublishEvents(EventTranslatorTwoArg<E,A,B> translator,A[] arg0,B[] arg1){
  return tryPublishEvents(translator,0,arg0.length,arg0,arg1);
}
/** 
 * @see io.mycat.memory.unsafe.ringbuffer.common.event.EventSink#publishEvent(EventTranslator)
 */
@Override public <A,B>boolean tryPublishEvents(EventTranslatorTwoArg<E,A,B> translator,int batchStartsAt,int batchSize,A[] arg0,B[] arg1){
  checkBounds(arg0,arg1,batchStartsAt,batchSize);
  try {
    final long finalSequence=sequencer.tryNext(batchSize);
    translateAndPublishBatch(translator,arg0,arg1,batchStartsAt,batchSize,finalSequence);
    return true;
  }
 catch (  InsufficientCapacityException e) {
    return false;
  }
}
/** 
 * @see io.mycat.memory.unsafe.ringbuffer.common.event.EventSink#publishEvent(EventTranslator)
 */
@Override public <A,B,C>boolean tryPublishEvents(EventTranslatorThreeArg<E,A,B,C> translator,A[] arg0,B[] arg1,C[] arg2){
  return tryPublishEvents(translator,0,arg0.length,arg0,arg1,arg2);
}
/** 
 * @see io.mycat.memory.unsafe.ringbuffer.common.event.EventSink#publishEvent(EventTranslator)
 */
@Override public <A,B,C>boolean tryPublishEvents(EventTranslatorThreeArg<E,A,B,C> translator,int batchStartsAt,int batchSize,A[] arg0,B[] arg1,C[] arg2){
  checkBounds(arg0,arg1,arg2,batchStartsAt,batchSize);
  try {
    final long finalSequence=sequencer.tryNext(batchSize);
    translateAndPublishBatch(translator,arg0,arg1,arg2,batchStartsAt,batchSize,finalSequence);
    return true;
  }
 catch (  InsufficientCapacityException e) {
    return false;
  }
}
/** 
 * @see io.mycat.memory.unsafe.ringbuffer.common.event.EventSink#publishEvent(EventTranslator)
 */
@Override public boolean tryPublishEvents(EventTranslatorVararg<E> translator,Object[]... args){
  return tryPublishEvents(translator,0,args.length,args);
}
/** 
 * @see io.mycat.memory.unsafe.ringbuffer.common.event.EventSink#publishEvent(EventTranslator)
 */
@Override public boolean tryPublishEvents(EventTranslatorVararg<E> translator,int batchStartsAt,int batchSize,Object[]... args){
  return false;
}
