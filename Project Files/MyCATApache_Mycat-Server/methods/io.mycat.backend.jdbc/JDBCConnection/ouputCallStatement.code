private void ouputCallStatement(RouteResultsetNode rrn,ServerConnection sc,String sql) throws SQLException {
  CallableStatement stmt=null;
  ResultSet rs=null;
  try {
    Procedure procedure=rrn.getProcedure();
    Collection<ProcedureParameter> paramters=procedure.getParamterMap().values();
    String callSql=procedure.toPreCallSql(null);
    stmt=con.prepareCall(callSql);
    if (sc.getSqlSelectLimit() > 0) {
      stmt.setMaxRows(sc.getSqlSelectLimit());
    }
    for (    ProcedureParameter paramter : paramters) {
      if ((ProcedureParameter.IN.equalsIgnoreCase(paramter.getParameterType()) || ProcedureParameter.INOUT.equalsIgnoreCase(paramter.getParameterType()))) {
        Object value=paramter.getValue() != null ? paramter.getValue() : paramter.getName();
        stmt.setObject(paramter.getIndex(),value);
      }
      if (ProcedureParameter.OUT.equalsIgnoreCase(paramter.getParameterType()) || ProcedureParameter.INOUT.equalsIgnoreCase(paramter.getParameterType())) {
        int jdbcType="oracle".equalsIgnoreCase(getDbType()) && procedure.getListFields().contains(paramter.getName()) ? oracleCURSORTypeValue : paramter.getJdbcType();
        stmt.registerOutParameter(paramter.getIndex(),jdbcType);
      }
    }
    boolean hadResults=stmt.execute();
    ByteBuffer byteBuf=sc.allocate();
    if (procedure.getSelectColumns().size() > 0 && !procedure.isResultList()) {
      List<FieldPacket> fieldPks=new LinkedList<FieldPacket>();
      for (      ProcedureParameter paramter : paramters) {
        if (!procedure.getListFields().contains(paramter.getName()) && (ProcedureParameter.OUT.equalsIgnoreCase(paramter.getParameterType()) || ProcedureParameter.INOUT.equalsIgnoreCase(paramter.getParameterType()))) {
          FieldPacket packet=PacketUtil.getField(paramter.getName(),MysqlDefs.javaTypeMysql(paramter.getJdbcType()));
          fieldPks.add(packet);
        }
      }
      int colunmCount=fieldPks.size();
      ResultSetHeaderPacket headerPkg=new ResultSetHeaderPacket();
      headerPkg.fieldCount=fieldPks.size();
      headerPkg.packetId=++packetId;
      byteBuf=headerPkg.write(byteBuf,sc,true);
      byteBuf.flip();
      byte[] header=new byte[byteBuf.limit()];
      byteBuf.get(header);
      byteBuf.clear();
      List<byte[]> fields=new ArrayList<byte[]>(fieldPks.size());
      Iterator<FieldPacket> itor=fieldPks.iterator();
      while (itor.hasNext()) {
        FieldPacket curField=itor.next();
        curField.packetId=++packetId;
        byteBuf=curField.write(byteBuf,sc,false);
        byteBuf.flip();
        byte[] field=new byte[byteBuf.limit()];
        byteBuf.get(field);
        byteBuf.clear();
        fields.add(field);
        itor.remove();
      }
      EOFPacket eofPckg=new EOFPacket();
      eofPckg.packetId=++packetId;
      byteBuf=eofPckg.write(byteBuf,sc,false);
      byteBuf.flip();
      byte[] eof=new byte[byteBuf.limit()];
      byteBuf.get(eof);
      byteBuf.clear();
      this.respHandler.fieldEofResponse(header,fields,eof,this);
      RowDataPacket curRow=new RowDataPacket(colunmCount);
      for (      String name : procedure.getSelectColumns()) {
        ProcedureParameter procedureParameter=procedure.getParamterMap().get(name);
        Object object=stmt.getObject(procedureParameter.getIndex());
        if (object != null) {
          curRow.add(StringUtil.encode(String.valueOf(object),sc.getCharset()));
        }
 else {
          curRow.add(null);
        }
      }
      curRow.packetId=++packetId;
      byteBuf=curRow.write(byteBuf,sc,false);
      byteBuf.flip();
      byte[] row=new byte[byteBuf.limit()];
      byteBuf.get(row);
      byteBuf.clear();
      this.respHandler.rowResponse(row,this);
      eofPckg=new EOFPacket();
      eofPckg.packetId=++packetId;
      if (procedure.isResultList()) {
        eofPckg.status=42;
      }
      byteBuf=eofPckg.write(byteBuf,sc,false);
      byteBuf.flip();
      eof=new byte[byteBuf.limit()];
      byteBuf.get(eof);
      byteBuf.clear();
      this.respHandler.rowEofResponse(eof,this);
    }
    if (procedure.isResultList()) {
      List<FieldPacket> fieldPks=new LinkedList<FieldPacket>();
      int listSize=procedure.getListFields().size();
      for (      ProcedureParameter paramter : paramters) {
        if (procedure.getListFields().contains(paramter.getName()) && (ProcedureParameter.OUT.equalsIgnoreCase(paramter.getParameterType()) || ProcedureParameter.INOUT.equalsIgnoreCase(paramter.getParameterType()))) {
          listSize--;
          Object object=stmt.getObject(paramter.getIndex());
          rs=(ResultSet)object;
          if (rs == null) {
            continue;
          }
          ResultSetUtil.resultSetToFieldPacket(sc.getCharset(),fieldPks,rs,this.isSpark);
          int colunmCount=fieldPks.size();
          ResultSetHeaderPacket headerPkg=new ResultSetHeaderPacket();
          headerPkg.fieldCount=fieldPks.size();
          headerPkg.packetId=++packetId;
          byteBuf=headerPkg.write(byteBuf,sc,true);
          byteBuf.flip();
          byte[] header=new byte[byteBuf.limit()];
          byteBuf.get(header);
          byteBuf.clear();
          List<byte[]> fields=new ArrayList<byte[]>(fieldPks.size());
          Iterator<FieldPacket> itor=fieldPks.iterator();
          while (itor.hasNext()) {
            FieldPacket curField=itor.next();
            curField.packetId=++packetId;
            byteBuf=curField.write(byteBuf,sc,false);
            byteBuf.flip();
            byte[] field=new byte[byteBuf.limit()];
            byteBuf.get(field);
            byteBuf.clear();
            fields.add(field);
            itor.remove();
          }
          EOFPacket eofPckg=new EOFPacket();
          eofPckg.packetId=++packetId;
          byteBuf=eofPckg.write(byteBuf,sc,false);
          byteBuf.flip();
          byte[] eof=new byte[byteBuf.limit()];
          byteBuf.get(eof);
          byteBuf.clear();
          this.respHandler.fieldEofResponse(header,fields,eof,this);
          while (rs.next()) {
            RowDataPacket curRow=new RowDataPacket(colunmCount);
            for (int i=0; i < colunmCount; i++) {
              int j=i + 1;
              Object object1=rs.getObject(j);
              if (object1 == null) {
                curRow.add(null);
              }
 else {
                curRow.add(StringUtil.encode(Objects.toString(object1),sc.getCharset()));
              }
            }
            curRow.packetId=++packetId;
            byteBuf=curRow.write(byteBuf,sc,false);
            byteBuf.flip();
            byte[] row=new byte[byteBuf.limit()];
            byteBuf.get(row);
            byteBuf.clear();
            this.respHandler.rowResponse(row,this);
          }
          eofPckg=new EOFPacket();
          eofPckg.packetId=++packetId;
          if (listSize != 0) {
            eofPckg.status=42;
          }
          byteBuf=eofPckg.write(byteBuf,sc,false);
          byteBuf.flip();
          eof=new byte[byteBuf.limit()];
          byteBuf.get(eof);
          byteBuf.clear();
          this.respHandler.rowEofResponse(eof,this);
        }
      }
    }
    if (!procedure.isResultSimpleValue()) {
      byte[] OK=new byte[]{7,0,0,1,0,0,0,2,0,0,0};
      OK[3]=++packetId;
      this.respHandler.okResponse(OK,this);
    }
    sc.recycle(byteBuf);
  }
  finally {
    if (rs != null) {
      try {
        rs.close();
      }
 catch (      SQLException e) {
      }
    }
    if (stmt != null) {
      try {
        stmt.close();
      }
 catch (      SQLException e) {
      }
    }
  }
}
