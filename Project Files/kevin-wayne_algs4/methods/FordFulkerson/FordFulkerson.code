/** 
 * Compute a maximum flow and minimum cut in the network  {@code G}from vertex  {@code s} to vertex {@code t}.
 * @param G the flow network
 * @param s the source vertex
 * @param t the sink vertex
 * @throws IllegalArgumentException unless {@code 0 <= s < V}
 * @throws IllegalArgumentException unless {@code 0 <= t < V}
 * @throws IllegalArgumentException if {@code s == t}
 * @throws IllegalArgumentException if initial flow is infeasible
 */
public FordFulkerson(FlowNetwork G,int s,int t){
  V=G.V();
  validate(s);
  validate(t);
  if (s == t)   throw new IllegalArgumentException("Source equals sink");
  if (!isFeasible(G,s,t))   throw new IllegalArgumentException("Initial flow is infeasible");
  value=excess(G,t);
  while (hasAugmentingPath(G,s,t)) {
    double bottle=Double.POSITIVE_INFINITY;
    for (int v=t; v != s; v=edgeTo[v].other(v)) {
      bottle=Math.min(bottle,edgeTo[v].residualCapacityTo(v));
    }
    for (int v=t; v != s; v=edgeTo[v].other(v)) {
      edgeTo[v].addResidualFlowTo(v,bottle);
    }
    value+=bottle;
  }
  assert check(G,s,t);
}
