/** 
 * A popup message that is shown while a long-term background operation is running. Some of them can be cancelled.
 */
public class WaitPopup<T> extends CoreScreenLayer {
  public static final ResourceUrn ASSET_URI=new ResourceUrn("engine:waitPopup!instance");
  private static final Logger logger=LoggerFactory.getLogger(WaitPopup.class);
  private FutureTask<T> parallelTask;
  private Thread thread;
  private Consumer<T> resultEvent;
  private UILabel titleLabel;
  private UILabel messageLabel;
  private UIButton cancelButton;
  @Override public void initialise(){
    titleLabel=find("title",UILabel.class);
    Preconditions.checkNotNull(titleLabel,"UILabel 'title' not found");
    messageLabel=find("message",UILabel.class);
    Preconditions.checkNotNull(messageLabel,"UILabel 'message' not found");
    cancelButton=find("cancel",UIButton.class);
    Preconditions.checkNotNull(cancelButton,"UIButton 'cancel' not found");
  }
  public void setMessage(  String title,  String message){
    setTitleText(title);
    bindMessageText(new ReadOnlyBinding<String>(){
      @Override public String get(){
        return message;
      }
    }
);
  }
  @Override public void update(  float delta){
    super.update(delta);
    if (parallelTask == null) {
      return;
    }
    if (!parallelTask.isDone()) {
      return;
    }
    if (parallelTask.isCancelled()) {
      if (!thread.isAlive()) {
        getManager().popScreen();
      }
      return;
    }
    try {
      T result=parallelTask.get();
      getManager().popScreen();
      if (resultEvent != null) {
        resultEvent.accept(result);
      }
    }
 catch (    InterruptedException|ExecutionException e) {
      logger.warn("An error occurred during execution",e);
      getManager().popScreen();
      getManager().pushScreen(MessagePopup.ASSET_URI,MessagePopup.class).setMessage("Error",e.getMessage());
    }
  }
  /** 
 * @param runnable will be called once the result is available
 */
  public void onSuccess(  Consumer<T> runnable){
    this.resultEvent=runnable;
  }
  /** 
 * @param operation the operation to run - the executing thread will be interrupted when the operation is cancelled
 * @param canBeCancelled true if the operation is aborted when the {@link Thread#isInterrupted()} flag is set
 * @throws NullPointerException if operation is null
 * @throws IllegalArgumentException if startOperation() was called before
 */
  public void startOperation(  Callable<T> operation,  boolean canBeCancelled){
    Preconditions.checkState(parallelTask == null,"startOperation() cannot be called twice");
    cancelButton.setVisible(canBeCancelled);
    parallelTask=new FutureTask<>(operation);
    thread=new Thread(parallelTask,"Parallel Operation");
    thread.start();
    WidgetUtil.trySubscribe(this,"cancel",button -> parallelTask.cancel(true));
  }
  public boolean canBeCancelled(){
    return cancelButton.isVisible();
  }
  public void setTitleText(  String text){
    titleLabel.setText(text);
  }
  public void bindMessageText(  Binding<String> binding){
    messageLabel.bindText(binding);
  }
  public void setCancelText(  String text){
    cancelButton.setText(text);
  }
}
