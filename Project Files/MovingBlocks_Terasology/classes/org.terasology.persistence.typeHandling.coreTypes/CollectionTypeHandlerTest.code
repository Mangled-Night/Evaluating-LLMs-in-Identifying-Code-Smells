class CollectionTypeHandlerTest {
  @Test void testSerialize(){
    IntTypeHandler elementTypeHandler=mock(IntTypeHandler.class);
    CollectionCopyConstructor<Queue<Integer>,Integer> constructor=Queues::newArrayDeque;
    CollectionTypeHandler<Integer> typeHandler=new CollectionTypeHandler<>(elementTypeHandler,constructor);
    Collection<Integer> collection=constructor.construct(Lists.newArrayList());
    collection.addAll(Collections.nCopies(500,-1));
    PersistedDataSerializer context=mock(PersistedDataSerializer.class);
    typeHandler.serialize(collection,context);
    verify(elementTypeHandler,times(collection.size())).serialize(any(),any());
    verify(context).serialize(argThat(new ArgumentMatcher<Iterable<PersistedData>>(){
      @Override public boolean matches(      Iterable<PersistedData> argument){
        return argument instanceof Collection && ((Collection)argument).size() == collection.size();
      }
    }
));
  }
  @Test void testDeserialize(){
    IntTypeHandler elementTypeHandler=mock(IntTypeHandler.class);
    CollectionCopyConstructor<Collection<Integer>,Integer> constructor=mock(CollectionCopyConstructor.class);
    when(constructor.construct(Lists.newArrayList())).then((Answer<Collection<Integer>>)invocation -> Queues.newArrayDeque());
    CollectionTypeHandler<Integer> typeHandler=new CollectionTypeHandler<>(elementTypeHandler,constructor);
    TIntList intList=new TIntArrayList();
    for (    Integer i : Collections.nCopies(500,-1)) {
      intList.add(i);
    }
    typeHandler.deserialize(new PersistedIntegerArray(intList));
    verify(constructor).construct(Lists.newArrayList());
    verify(elementTypeHandler,times(intList.size())).deserialize(any());
  }
}
