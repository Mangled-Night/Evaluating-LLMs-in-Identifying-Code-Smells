/** 
 * @author Mark Paluch
 * @author Mikhael Sokolov
 */
class ClusterTestHelper {
  private final RedisClusterClient clusterClient;
  private final Map<Integer,RedisAsyncCommands<String,String>> connectionCache=new HashMap<>();
  public ClusterTestHelper(  RedisClusterClient clusterClient,  int... ports){
    this.clusterClient=clusterClient;
    for (    int port : ports) {
      RedisAsyncCommands<String,String> connection=clusterClient.connectToNode(new InetSocketAddress("localhost",port)).async();
      connectionCache.put(port,connection);
    }
  }
  /** 
 * @return true if the cluster state is {@code ok} and there are no failing nodes
 */
  public boolean isStable(){
    for (    RedisAsyncCommands<String,String> commands : connectionCache.values()) {
      try {
        RedisCommands<String,String> sync=commands.getStatefulConnection().sync();
        String info=sync.clusterInfo();
        if (info != null && info.contains("cluster_state:ok")) {
          String s=sync.clusterNodes();
          Partitions parse=ClusterPartitionParser.parse(s);
          for (          RedisClusterNode redisClusterNode : parse) {
            if (redisClusterNode.getFlags().contains(RedisClusterNode.NodeFlag.FAIL) || redisClusterNode.getFlags().contains(RedisClusterNode.NodeFlag.EVENTUAL_FAIL) || redisClusterNode.getFlags().contains(RedisClusterNode.NodeFlag.HANDSHAKE)) {
              return false;
            }
          }
        }
 else {
          return false;
        }
      }
 catch (      Exception e) {
        e.printStackTrace();
      }
    }
    return true;
  }
  /** 
 * Flush data on all nodes, ignore failures.
 */
  public void flushdb(){
    onAllConnections(RedisServerAsyncCommands::flushdb,true);
  }
  /** 
 * Cluster reset on all nodes.
 */
  public void clusterReset(){
    onAllConnections(RedisServerAsyncCommands::flushall,true);
    onAllConnections(c -> c.clusterReset(true));
    onAllConnections(RedisClusterAsyncCommands::clusterFlushslots);
  }
  /** 
 * Meet on all nodes.
 * @param host
 * @param port
 */
  public void meet(  String host,  int port){
    onAllConnections(c -> c.clusterMeet(host,port));
  }
  public RedisClusterClient getClusterClient(){
    return clusterClient;
  }
  private <T>void onAllConnections(  Function<RedisClusterAsyncCommands<?,?>,Future<T>> function){
    onAllConnections(function,false);
  }
  private <T>void onAllConnections(  Function<RedisClusterAsyncCommands<?,?>,Future<T>> function,  boolean ignoreExecutionException){
    List<Future<?>> futures=new ArrayList<>();
    for (    RedisClusterAsyncCommands<?,?> connection : connectionCache.values()) {
      futures.add(function.apply(connection));
    }
    try {
      await(futures,ignoreExecutionException);
    }
 catch (    InterruptedException|ExecutionException|TimeoutException e) {
      throw new IllegalStateException(e);
    }
  }
  private void await(  List<Future<?>> futures,  boolean ignoreExecutionException) throws InterruptedException, java.util.concurrent.ExecutionException, java.util.concurrent.TimeoutException {
    for (    Future<?> future : futures) {
      try {
        future.get(10,TimeUnit.SECONDS);
      }
 catch (      ExecutionException e) {
        if (!ignoreExecutionException) {
          throw e;
        }
      }
    }
  }
}
