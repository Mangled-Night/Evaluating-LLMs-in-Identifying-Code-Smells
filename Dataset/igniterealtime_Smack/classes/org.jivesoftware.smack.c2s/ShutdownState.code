private final class ShutdownState extends State {
  private ShutdownState(  StateDescriptor stateDescriptor,  ModularXmppClientToServerConnectionInternal connectionInternal){
    super(stateDescriptor,connectionInternal);
  }
  @Override public StateTransitionResult.TransitionImpossible isTransitionToPossible(  WalkStateGraphContext walkStateGraphContext){
    ensureNotOnOurWayToAuthenticatedAndResourceBound(walkStateGraphContext);
    return null;
  }
  @Override public StateTransitionResult.AttemptResult transitionInto(  WalkStateGraphContext walkStateGraphContext){
    closingStreamReceived=false;
    StreamOpenAndCloseFactory openAndCloseFactory=activeTransport.getStreamOpenAndCloseFactory();
    AbstractStreamClose closeStreamElement=openAndCloseFactory.createStreamClose();
    boolean streamCloseIssued=outgoingElementsQueue.offerAndShutdown(closeStreamElement);
    if (streamCloseIssued) {
      activeTransport.notifyAboutNewOutgoingElements();
      boolean successfullyReceivedStreamClose=waitForClosingStreamTagFromServer();
      if (successfullyReceivedStreamClose) {
        for (Iterator<XmppInputOutputFilter> it=connectionInternal.getXmppInputOutputFilterBeginIterator(); it.hasNext(); ) {
          XmppInputOutputFilter filter=it.next();
          filter.closeInputOutput();
        }
        activeTransport.afterFiltersClosed();
        for (Iterator<XmppInputOutputFilter> it=connectionInternal.getXmppInputOutputFilterBeginIterator(); it.hasNext(); ) {
          XmppInputOutputFilter filter=it.next();
          try {
            filter.waitUntilInputOutputClosed();
          }
 catch (          IOException|CertificateException|InterruptedException|SmackException|XMPPException e) {
            LOGGER.log(Level.WARNING,"waitUntilInputOutputClosed() threw",e);
          }
        }
        authenticated=false;
      }
    }
    return StateTransitionResult.Success.EMPTY_INSTANCE;
  }
}
