/** 
 * Creates  {@link TypeInformation} for the given {@link Type}.
 * @param fieldType
 * @return
 */
@SuppressWarnings({"rawtypes","unchecked","deprecation"}) protected TypeInformation<?> createInfo(Type fieldType){
  if (fieldType.equals(this.type)) {
    return this;
  }
  if (fieldType instanceof Class) {
    return new ClassTypeInformation((Class<?>)fieldType);
  }
  Class<S> resolveType=resolveClass(fieldType);
  Map<TypeVariable,Type> variableMap=new HashMap<TypeVariable,Type>();
  variableMap.putAll(GenericTypeResolver.getTypeVariableMap(resolveType));
  if (fieldType instanceof ParameterizedType) {
    ParameterizedType parameterizedType=(ParameterizedType)fieldType;
    TypeVariable<Class<S>>[] typeParameters=resolveType.getTypeParameters();
    Type[] arguments=parameterizedType.getActualTypeArguments();
    for (int i=0; i < typeParameters.length; i++) {
      variableMap.put(typeParameters[i],arguments[i]);
    }
    return new ParametrizedTypeInformation(parameterizedType,this,variableMap);
  }
  if (fieldType instanceof TypeVariable) {
    TypeVariable<?> variable=(TypeVariable<?>)fieldType;
    return new TypeVariableTypeInformation(variable,type,this,variableMap);
  }
  if (fieldType instanceof GenericArrayType) {
    return new GenericArrayTypeInformation((GenericArrayType)fieldType,this,variableMap);
  }
  if (fieldType instanceof WildcardType) {
    WildcardType wildcardType=(WildcardType)fieldType;
    return new WildcardTypeInformation(wildcardType,variableMap);
  }
  throw new IllegalArgumentException();
}
