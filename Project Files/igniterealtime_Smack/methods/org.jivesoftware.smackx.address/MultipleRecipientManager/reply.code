/** 
 * Sends a reply to a previously received stanza that was sent to multiple recipients. Before attempting to send the reply message some checks are performed. If any of those checks fails, then an XMPPException is going to be thrown with the specific error detail.
 * @param connection the connection to use to send the reply.
 * @param original   the previously received stanza that was sent to multiple recipients.
 * @param reply      the new message to send as a reply.
 * @throws XMPPErrorException if there was an XMPP error returned.
 * @throws InterruptedException if the calling thread was interrupted.
 * @throws NotConnectedException if the XMPP connection is not connected.
 * @throws FeatureNotSupportedException if a requested feature is not supported by the remote entity.
 * @throws NoResponseException if there was no response from the remote entity.
 */
public static void reply(XMPPConnection connection,Message original,Message reply) throws XMPPErrorException, InterruptedException, NotConnectedException, NoResponseException, FeatureNotSupportedException {
  MultipleRecipientInfo info=getMultipleRecipientInfo(original);
  if (info == null) {
    throw new IllegalArgumentException("Original message does not contain multiple recipient info");
  }
  if (info.shouldNotReply()) {
    throw new IllegalArgumentException("Original message should not be replied");
  }
  if (info.getReplyRoom() != null) {
    throw new IllegalArgumentException("Reply should be sent through a room");
  }
  if (original.getThread() != null) {
    reply.asBuilder().setThread(original.getThread()).build();
  }
  MultipleAddresses.Address replyAddress=info.getReplyAddress();
  if (replyAddress != null && replyAddress.getJid() != null) {
    reply.setTo(replyAddress.getJid());
    connection.sendStanza(reply);
  }
 else {
    List<Jid> to=new ArrayList<>(info.getTOAddresses().size());
    List<Jid> cc=new ArrayList<>(info.getCCAddresses().size());
    for (    MultipleAddresses.Address jid : info.getTOAddresses()) {
      to.add(jid.getJid());
    }
    for (    MultipleAddresses.Address jid : info.getCCAddresses()) {
      cc.add(jid.getJid());
    }
    if (!to.contains(original.getFrom()) && !cc.contains(original.getFrom())) {
      to.add(original.getFrom());
    }
    EntityFullJid from=connection.getUser();
    if (!to.remove(from) && !cc.remove(from)) {
      EntityBareJid bareJID=from.asEntityBareJid();
      to.remove(bareJID);
      cc.remove(bareJID);
    }
    send(connection,reply,to,cc,null,null,null,false);
  }
}
