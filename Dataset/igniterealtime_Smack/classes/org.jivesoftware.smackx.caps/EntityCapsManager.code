/** 
 * Keeps track of entity capabilities.
 * @author Florian Schmaus
 * @see <a href="http://www.xmpp.org/extensions/xep-0115.html">XEP-0115: Entity Capabilities</a>
 */
public final class EntityCapsManager extends Manager {
  public static final String NAMESPACE=CapsExtension.NAMESPACE;
  public static final String ELEMENT=CapsExtension.ELEMENT;
  private static final Map<String,MessageDigest> SUPPORTED_HASHES=new HashMap<String,MessageDigest>();
  /** 
 * The default hash. Currently 'sha-1'.
 */
  private static final String DEFAULT_HASH=StringUtils.SHA1;
  private static String DEFAULT_ENTITY_NODE=SmackConfiguration.SMACK_URL_STRING;
  static EntityCapsPersistentCache persistentCache;
  private static boolean autoEnableEntityCaps=true;
  private static final Map<XMPPConnection,EntityCapsManager> instances=new WeakHashMap<>();
  private static final StanzaFilter PRESENCES_WITH_CAPS=new AndFilter(new StanzaTypeFilter(Presence.class),new StanzaExtensionFilter(ELEMENT,NAMESPACE));
  /** 
 * Map of "node + '#' + hash" to DiscoverInfo data
 */
  static final LruCache<String,DiscoverInfo> CAPS_CACHE=new LruCache<>(1000);
  /** 
 * Map of Full JID -&gt; DiscoverInfo/null. In case of c2s connection the key is formed as user@server/resource (resource is required) In case of link-local connection the key is formed as user@host (no resource) In case of a server or component the key is formed as domain
 */
  static final LruCache<Jid,NodeVerHash> JID_TO_NODEVER_CACHE=new LruCache<>(10000);
static {
    XMPPConnectionRegistry.addConnectionCreationListener(new ConnectionCreationListener(){
      @Override public void connectionCreated(      XMPPConnection connection){
        getInstanceFor(connection);
      }
    }
);
    try {
      MessageDigest sha1MessageDigest=MessageDigest.getInstance(DEFAULT_HASH);
      SUPPORTED_HASHES.put(DEFAULT_HASH,sha1MessageDigest);
    }
 catch (    NoSuchAlgorithmException e) {
    }
    ServiceDiscoveryManager.addDiscoInfoLookupShortcutMechanism(new DiscoInfoLookupShortcutMechanism("XEP-0115: Entity Capabilities",100){
      @Override public DiscoverInfo getDiscoverInfoByUser(      ServiceDiscoveryManager serviceDiscoveryManager,      Jid jid){
        DiscoverInfo info=EntityCapsManager.getDiscoverInfoByUser(jid);
        if (info != null) {
          return info;
        }
        NodeVerHash nodeVerHash=getNodeVerHashByJid(jid);
        if (nodeVerHash == null) {
          return null;
        }
        try {
          info=serviceDiscoveryManager.discoverInfo(jid,nodeVerHash.getNodeVer());
        }
 catch (        NoResponseException|XMPPErrorException|NotConnectedException|InterruptedException e) {
          return null;
        }
        if (verifyDiscoverInfoVersion(nodeVerHash.getVer(),nodeVerHash.getHash(),info)) {
          addDiscoverInfoByNode(nodeVerHash.getNodeVer(),info);
        }
 else {
        }
        return info;
      }
    }
);
  }
  /** 
 * Set the default entity node that will be used for new EntityCapsManagers.
 * @param entityNode TODO javadoc me please
 */
  public static void setDefaultEntityNode(  String entityNode){
    DEFAULT_ENTITY_NODE=entityNode;
  }
  /** 
 * Add DiscoverInfo to the database.
 * @param nodeVer TODO javadoc me pleaseThe node and verification String (e.g. "http://psi-im.org#q07IKJEyjvHSyhy//CH0CxmKi8w=").
 * @param info TODO javadoc me pleaseDiscoverInfo for the specified node.
 */
  static void addDiscoverInfoByNode(  String nodeVer,  DiscoverInfo info){
    CAPS_CACHE.put(nodeVer,info);
    if (persistentCache != null)     persistentCache.addDiscoverInfoByNodePersistent(nodeVer,info);
  }
  /** 
 * Get the Node version (node#ver) of a JID. Returns a String or null if EntiyCapsManager does not have any information.
 * @param jid TODO javadoc me pleasethe user (Full JID)
 * @return the node version (node#ver) or null
 */
  public static String getNodeVersionByJid(  Jid jid){
    NodeVerHash nvh=JID_TO_NODEVER_CACHE.lookup(jid);
    if (nvh != null) {
      return nvh.nodeVer;
    }
 else {
      return null;
    }
  }
  public static NodeVerHash getNodeVerHashByJid(  Jid jid){
    return JID_TO_NODEVER_CACHE.lookup(jid);
  }
  /** 
 * Get the discover info given a user name. The discover info is returned if the user has a node#ver associated with it and the node#ver has a discover info associated with it.
 * @param user TODO javadoc me pleaseuser name (Full JID)
 * @return the discovered info
 */
  public static DiscoverInfo getDiscoverInfoByUser(  Jid user){
    NodeVerHash nvh=JID_TO_NODEVER_CACHE.lookup(user);
    if (nvh == null)     return null;
    return getDiscoveryInfoByNodeVer(nvh.nodeVer);
  }
  /** 
 * Retrieve DiscoverInfo for a specific node.
 * @param nodeVer TODO javadoc me pleaseThe node name (e.g. "http://psi-im.org#q07IKJEyjvHSyhy//CH0CxmKi8w=").
 * @return The corresponding DiscoverInfo or null if none is known.
 */
  public static DiscoverInfo getDiscoveryInfoByNodeVer(  String nodeVer){
    DiscoverInfo info=CAPS_CACHE.lookup(nodeVer);
    if (info == null && persistentCache != null) {
      info=persistentCache.lookup(nodeVer);
      if (info != null) {
        CAPS_CACHE.put(nodeVer,info);
      }
    }
    if (info != null)     info=new DiscoverInfo(info);
    return info;
  }
  /** 
 * Set the persistent cache implementation.
 * @param cache TODO javadoc me please
 */
  public static void setPersistentCache(  EntityCapsPersistentCache cache){
    persistentCache=cache;
  }
  /** 
 * Sets the maximum cache sizes.
 * @param maxJidToNodeVerSize TODO javadoc me please
 * @param maxCapsCacheSize TODO javadoc me please
 */
  public static void setMaxsCacheSizes(  int maxJidToNodeVerSize,  int maxCapsCacheSize){
    JID_TO_NODEVER_CACHE.setMaxCacheSize(maxJidToNodeVerSize);
    CAPS_CACHE.setMaxCacheSize(maxCapsCacheSize);
  }
  /** 
 * Clears the memory cache.
 */
  public static void clearMemoryCache(){
    JID_TO_NODEVER_CACHE.clear();
    CAPS_CACHE.clear();
  }
  private static void addCapsExtensionInfo(  Jid from,  CapsExtension capsExtension){
    String capsExtensionHash=capsExtension.getHash();
    String hashInUppercase=capsExtensionHash.toUpperCase(Locale.US);
    if (!SUPPORTED_HASHES.containsKey(hashInUppercase))     return;
    String hash=capsExtensionHash.toLowerCase(Locale.US);
    String node=capsExtension.getNode();
    String ver=capsExtension.getVer();
    JID_TO_NODEVER_CACHE.put(from,new NodeVerHash(node,ver,hash));
  }
  private final Queue<CapsVersionAndHash> lastLocalCapsVersions=new ConcurrentLinkedQueue<>();
  private final ServiceDiscoveryManager sdm;
  private boolean entityCapsEnabled;
  private CapsVersionAndHash currentCapsVersion;
  /** 
 * The entity node String used by this EntityCapsManager instance.
 */
  private String entityNode=DEFAULT_ENTITY_NODE;
  private void addCapsExtension(  PresenceBuilder presenceBuilder){
    final CapsVersionAndHash capsVersionAndHash=getCapsVersionAndHash();
    if (capsVersionAndHash == null) {
      return;
    }
    CapsExtension caps=new CapsExtension(entityNode,capsVersionAndHash.version,capsVersionAndHash.hash);
    presenceBuilder.overrideExtension(caps);
  }
  private EntityCapsManager(  XMPPConnection connection){
    super(connection);
    this.sdm=ServiceDiscoveryManager.getInstanceFor(connection);
    instances.put(connection,this);
    connection.addConnectionListener(new ConnectionListener(){
      @Override public void connected(      XMPPConnection connection){
        processCapsStreamFeatureIfAvailable(connection);
      }
      @Override public void authenticated(      XMPPConnection connection,      boolean resumed){
        processCapsStreamFeatureIfAvailable(connection);
      }
      private void processCapsStreamFeatureIfAvailable(      XMPPConnection connection){
        CapsExtension capsExtension=connection.getFeature(CapsExtension.class);
        if (capsExtension == null) {
          return;
        }
        DomainBareJid from=connection.getXMPPServiceDomain();
        addCapsExtensionInfo(from,capsExtension);
      }
    }
);
    if (autoEnableEntityCaps)     enableEntityCaps();
    connection.addAsyncStanzaListener(new StanzaListener(){
      @Override public void processStanza(      Stanza packet){
        if (!entityCapsEnabled())         return;
        CapsExtension capsExtension=CapsExtension.from(packet);
        Jid from=packet.getFrom();
        addCapsExtensionInfo(from,capsExtension);
      }
    }
,PRESENCES_WITH_CAPS);
    Roster.getInstanceFor(connection).addPresenceEventListener(new AbstractPresenceEventListener(){
      @Override public void presenceUnavailable(      FullJid from,      Presence presence){
        JID_TO_NODEVER_CACHE.remove(from);
      }
    }
);
    sdm.addEntityCapabilitiesChangedListener(new EntityCapabilitiesChangedListener(){
      @Override public void onEntityCapabilitiesChanged(      DiscoverInfo synthesizedDiscoveryInfo){
        if (!entityCapsEnabled()) {
          return;
        }
        updateLocalEntityCaps(synthesizedDiscoveryInfo);
      }
    }
);
  }
  public static synchronized EntityCapsManager getInstanceFor(  XMPPConnection connection){
    if (SUPPORTED_HASHES.size() <= 0)     throw new IllegalStateException("No supported hashes for EntityCapsManager");
    EntityCapsManager entityCapsManager=instances.get(connection);
    if (entityCapsManager == null) {
      entityCapsManager=new EntityCapsManager(connection);
    }
    return entityCapsManager;
  }
  public synchronized void enableEntityCaps(){
    connection().addPresenceInterceptor(this::addCapsExtension,p -> {
      return PresenceTypeFilter.AVAILABLE.accept(p);
    }
);
    sdm.addFeature(NAMESPACE);
    entityCapsEnabled=true;
  }
  public synchronized void disableEntityCaps(){
    entityCapsEnabled=false;
    sdm.removeFeature(NAMESPACE);
    connection().removePresenceInterceptor(this::addCapsExtension);
  }
  public boolean entityCapsEnabled(){
    return entityCapsEnabled;
  }
  /** 
 * Remove a record telling what entity caps node a user has.
 * @param user TODO javadoc me pleasethe user (Full JID)
 */
  public static void removeUserCapsNode(  Jid user){
    JID_TO_NODEVER_CACHE.remove(user);
  }
  /** 
 * Get our own caps version or  {@code null} if none is yet set. The version depends on the enabled features.A caps version looks like '66/0NaeaBKkwk85efJTGmU47vXI='
 * @return our own caps version or {@code null}.
 */
  public CapsVersionAndHash getCapsVersionAndHash(){
    return currentCapsVersion;
  }
  /** 
 * Returns the local entity's NodeVer (e.g. "http://www.igniterealtime.org/projects/smack/#66/0NaeaBKkwk85efJTGmU47vXI= )
 * @return the local NodeVer
 */
  public String getLocalNodeVer(){
    CapsVersionAndHash capsVersionAndHash=getCapsVersionAndHash();
    if (capsVersionAndHash == null) {
      return null;
    }
    return entityNode + '#' + capsVersionAndHash.version;
  }
  /** 
 * Returns true if Entity Caps are supported by a given JID.
 * @param jid TODO javadoc me please
 * @return true if the entity supports Entity Capabilities.
 * @throws XMPPErrorException if there was an XMPP error returned.
 * @throws NoResponseException if there was no response from the remote entity.
 * @throws NotConnectedException if the XMPP connection is not connected.
 * @throws InterruptedException if the calling thread was interrupted.
 */
  public boolean areEntityCapsSupported(  Jid jid) throws NoResponseException, XMPPErrorException, NotConnectedException, InterruptedException {
    return sdm.supportsFeature(jid,NAMESPACE);
  }
  /** 
 * Returns true if Entity Caps are supported by the local service/server.
 * @return true if the user's server supports Entity Capabilities.
 * @throws XMPPErrorException if there was an XMPP error returned.
 * @throws NoResponseException if there was no response from the remote entity.
 * @throws NotConnectedException if the XMPP connection is not connected.
 * @throws InterruptedException if the calling thread was interrupted.
 */
  public boolean areEntityCapsSupportedByServer() throws NoResponseException, XMPPErrorException, NotConnectedException, InterruptedException {
    return areEntityCapsSupported(connection().getXMPPServiceDomain());
  }
  /** 
 * Updates the local user Entity Caps information with the data provided If we are connected and there was already a presence send, another presence is send to inform others about your new Entity Caps node string.
 */
  private void updateLocalEntityCaps(  DiscoverInfo synthesizedDiscoveryInfo){
    XMPPConnection connection=connection();
    DiscoverInfoBuilder discoverInfoBuilder=synthesizedDiscoveryInfo.asBuilder("synthesized-disco-info-result");
    currentCapsVersion=generateVerificationString(discoverInfoBuilder);
    final String localNodeVer=getLocalNodeVer();
    discoverInfoBuilder.setNode(localNodeVer);
    final DiscoverInfo discoverInfo=discoverInfoBuilder.build();
    addDiscoverInfoByNode(localNodeVer,discoverInfo);
    if (lastLocalCapsVersions.size() > 10) {
      CapsVersionAndHash oldCapsVersion=lastLocalCapsVersions.poll();
      sdm.removeNodeInformationProvider(entityNode + '#' + oldCapsVersion.version);
    }
    lastLocalCapsVersions.add(currentCapsVersion);
    if (connection != null)     JID_TO_NODEVER_CACHE.put(connection.getUser(),new NodeVerHash(entityNode,currentCapsVersion));
    final List<Identity> identities=new LinkedList<>(ServiceDiscoveryManager.getInstanceFor(connection).getIdentities());
    sdm.setNodeInformationProvider(localNodeVer,new AbstractNodeInformationProvider(){
      List<String> features=sdm.getFeatures();
      List<DataForm> packetExtensions=sdm.getExtendedInfo();
      @Override public List<String> getNodeFeatures(){
        return features;
      }
      @Override public List<Identity> getNodeIdentities(){
        return identities;
      }
      @Override public List<DataForm> getNodePacketExtensions(){
        return packetExtensions;
      }
    }
);
  }
  /** 
 * Verify DiscoverInfo and Caps Node as defined in XEP-0115 5.4 Processing Method.
 * @see <a href="http://xmpp.org/extensions/xep-0115.html#ver-proc">XEP-0115
     *      5.4 Processing Method</a>
 * @param ver TODO javadoc me please
 * @param hash TODO javadoc me please
 * @param info TODO javadoc me please
 * @return true if it's valid and should be cache, false if not
 */
  public static boolean verifyDiscoverInfoVersion(  String ver,  String hash,  DiscoverInfo info){
    if (info.containsDuplicateIdentities())     return false;
    if (info.containsDuplicateFeatures())     return false;
    if (!verifyPacketExtensions(info))     return false;
    String calculatedVer=generateVerificationString(info,hash).version;
    if (!ver.equals(calculatedVer))     return false;
    return true;
  }
  /** 
 * Verify that the given discovery info is not ill-formed.
 * @param info the discovery info to verify.
 * @return true if the stanza extensions is not ill-formed
 */
  private static boolean verifyPacketExtensions(  DiscoverInfo info){
    Set<String> foundFormTypes=new HashSet<>();
    List<DataForm> dataForms=info.getExtensions(DataForm.class);
    for (    DataForm dataForm : dataForms) {
      FormField formFieldTypeField=dataForm.getHiddenFormTypeField();
      if (formFieldTypeField == null) {
        continue;
      }
      String type=formFieldTypeField.getFirstValue();
      boolean noDuplicate=foundFormTypes.add(type);
      if (!noDuplicate) {
        return false;
      }
    }
    return true;
  }
  static CapsVersionAndHash generateVerificationString(  DiscoverInfoView discoverInfo){
    return generateVerificationString(discoverInfo,null);
  }
  /** 
 * Generates a XEP-115 Verification String
 * @see <a href="http://xmpp.org/extensions/xep-0115.html#ver">XEP-115
     *      Verification String</a>
 * @param discoverInfo TODO javadoc me please
 * @param hash TODO javadoc me pleasethe used hash function, if null, default hash will be used
 * @return The generated verification String or null if the hash is notsupported
 */
  static CapsVersionAndHash generateVerificationString(  DiscoverInfoView discoverInfo,  String hash){
    if (hash == null) {
      hash=DEFAULT_HASH;
    }
    MessageDigest md=SUPPORTED_HASHES.get(hash.toUpperCase(Locale.US));
    if (md == null)     return null;
    hash=hash.toLowerCase(Locale.US);
    StringBuilder sb=new StringBuilder();
    SortedSet<DiscoverInfo.Identity> sortedIdentities=new TreeSet<>();
    sortedIdentities.addAll(discoverInfo.getIdentities());
    for (    DiscoverInfo.Identity identity : sortedIdentities) {
      sb.append(identity.getCategory());
      sb.append('/');
      sb.append(identity.getType());
      sb.append('/');
      sb.append(identity.getLanguage() == null ? "" : identity.getLanguage());
      sb.append('/');
      sb.append(identity.getName() == null ? "" : identity.getName());
      sb.append('<');
    }
    SortedSet<String> features=new TreeSet<>();
    for (    Feature f : discoverInfo.getFeatures())     features.add(f.getVar());
    for (    String f : features) {
      sb.append(f);
      sb.append('<');
    }
    List<DataForm> extendedInfos=discoverInfo.getExtensions(DataForm.class);
    for (    DataForm extendedInfo : extendedInfos) {
      if (!extendedInfo.hasHiddenFormTypeField()) {
        continue;
      }
      SortedSet<FormField> fs=new TreeSet<>(new Comparator<FormField>(){
        @Override public int compare(        FormField f1,        FormField f2){
          return f1.getFieldName().compareTo(f2.getFieldName());
        }
      }
);
      for (      FormField f : extendedInfo.getFields()) {
        if (!f.getFieldName().equals("FORM_TYPE")) {
          fs.add(f);
        }
      }
      formFieldValuesToCaps(Collections.singletonList(extendedInfo.getFormType()),sb);
      for (      FormField f : fs) {
        sb.append(f.getFieldName());
        sb.append('<');
        formFieldValuesToCaps(f.getRawValueCharSequences(),sb);
      }
    }
    byte[] bytes=sb.toString().getBytes(StandardCharsets.UTF_8);
    byte[] digest;
synchronized (md) {
      digest=md.digest(bytes);
    }
    String version=Base64.encodeToString(digest);
    return new CapsVersionAndHash(version,hash);
  }
  private static void formFieldValuesToCaps(  List<? extends CharSequence> i,  StringBuilder sb){
    SortedSet<CharSequence> fvs=new TreeSet<>();
    fvs.addAll(i);
    for (    CharSequence fv : fvs) {
      sb.append(fv);
      sb.append('<');
    }
  }
public static class NodeVerHash {
    private String node;
    private String hash;
    private String ver;
    private String nodeVer;
    NodeVerHash(    String node,    CapsVersionAndHash capsVersionAndHash){
      this(node,capsVersionAndHash.version,capsVersionAndHash.hash);
    }
    NodeVerHash(    String node,    String ver,    String hash){
      this.node=node;
      this.ver=ver;
      this.hash=hash;
      nodeVer=node + "#" + ver;
    }
    public String getNodeVer(){
      return nodeVer;
    }
    public String getNode(){
      return node;
    }
    public String getHash(){
      return hash;
    }
    public String getVer(){
      return ver;
    }
  }
}
