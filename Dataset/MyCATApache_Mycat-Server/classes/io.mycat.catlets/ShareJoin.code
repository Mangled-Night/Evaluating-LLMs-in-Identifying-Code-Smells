/** 
 * 功能详细描述:分片join
 * @author sohudo[http://blog.csdn.net/wind520]
 * @create 2015年01月22日 下午6:50:23 
 * @version 0.0.1
 */
public class ShareJoin implements Catlet {
  private EngineCtx ctx;
  private RouteResultset rrs;
  private JoinParser joinParser;
  private Map<String,byte[]> rows=new ConcurrentHashMap<String,byte[]>();
  private Map<String,String> ids=new ConcurrentHashMap<String,String>();
  private List<byte[]> fields;
  private ArrayList<byte[]> allfields;
  private boolean isMfield=false;
  private int mjob=0;
  private int maxjob=0;
  private int joinindex=0;
  private int sendField=0;
  private boolean childRoute=false;
  private boolean jointTableIsData=false;
  private int joinKeyType=Fields.FIELD_TYPE_LONG;
  private SystemConfig sysConfig;
  private SchemaConfig schema;
  private int sqltype;
  private String charset;
  private ServerConnection sc;
  private LayerCachePool cachePool;
  private RowDataSorter sorter;
  private volatile boolean isInit=false;
  public void setRoute(  RouteResultset rrs){
    this.rrs=rrs;
  }
  public void route(  SystemConfig sysConfig,  SchemaConfig schema,  int sqlType,  String realSQL,  String charset,  ServerConnection sc,  LayerCachePool cachePool){
    int rs=ServerParse.parse(realSQL);
    this.sqltype=rs & 0xff;
    this.sysConfig=sysConfig;
    this.schema=schema;
    this.charset=charset;
    this.sc=sc;
    this.cachePool=cachePool;
    try {
      MySqlStatementParser parser=new MySqlStatementParser(realSQL);
      SQLStatement statement=parser.parseStatement();
      if (statement instanceof SQLSelectStatement) {
        SQLSelectStatement st=(SQLSelectStatement)statement;
        SQLSelectQuery sqlSelectQuery=st.getSelect().getQuery();
        if (sqlSelectQuery instanceof MySqlSelectQueryBlock) {
          MySqlSelectQueryBlock mysqlSelectQuery=(MySqlSelectQueryBlock)sqlSelectQuery;
          joinParser=new JoinParser(mysqlSelectQuery,realSQL);
          joinParser.parser();
        }
      }
    }
 catch (    Exception e) {
    }
  }
  private void getRoute(  String sql){
    try {
      if (joinParser != null) {
        rrs=RouteStrategyFactory.getRouteStrategy().route(sysConfig,schema,sqltype,sql,charset,sc,cachePool);
      }
    }
 catch (    Exception e) {
    }
  }
  private String[] getDataNodes(){
    String[] dataNodes=new String[rrs.getNodes().length];
    for (int i=0; i < rrs.getNodes().length; i++) {
      dataNodes[i]=rrs.getNodes()[i].getName();
    }
    return dataNodes;
  }
  private String getDataNode(  String[] dataNodes){
    String dataNode="";
    for (int i=0; i < dataNodes.length; i++) {
      dataNode+=dataNodes[i] + ",";
    }
    return dataNode;
  }
  public void processSQL(  String sql,  EngineCtx ctx){
    String ssql=joinParser.getSql();
    getRoute(ssql);
    RouteResultsetNode[] nodes=rrs.getNodes();
    if (nodes == null || nodes.length == 0 || nodes[0].getName() == null || nodes[0].getName().equals("")) {
      ctx.getSession().getSource().writeErrMessage(ErrorCode.ER_NO_DB_ERROR,"No dataNode found ,please check tables defined in schema:" + ctx.getSession().getSource().getSchema());
      return;
    }
    this.ctx=ctx;
    if (joinParser.hasLimit() || joinParser.hasOrder()) {
      ctx.setIsStreamOutputResult(false);
    }
    String[] dataNodes=getDataNodes();
    maxjob=dataNodes.length;
    ShareDBJoinHandler joinHandler=new ShareDBJoinHandler(this,joinParser.getJoinLkey(),sc.getSession2());
    ctx.executeNativeSQLSequnceJob(dataNodes,ssql,joinHandler);
    EngineCtx.LOGGER.info("Catlet exec:" + getDataNode(getDataNodes()) + " sql:"+ ssql);
    final ShareJoin shareJoin=this;
    ctx.setAllJobFinishedListener(new AllJobFinishedListener(){
      @Override public void onAllJobFinished(      EngineCtx ctx){
        if (!jointTableIsData) {
          ctx.writeHeader(fields);
        }
        MiddlerResultHandler middlerResultHandler=sc.getSession2().getMiddlerResultHandler();
        if (middlerResultHandler != null) {
          middlerResultHandler.secondEexcute();
        }
 else {
          shareJoin.writeEof();
        }
        EngineCtx.LOGGER.info("发送数据OK");
      }
    }
);
  }
  public void putDBRow(  String id,  String nid,  byte[] rowData,  int findex){
    rows.put(id,rowData);
    ids.put(id,nid);
    joinindex=findex;
    int batchSize=999;
    if (ids.size() > batchSize) {
      createQryJob(batchSize);
    }
  }
  public void putDBFields(  List<byte[]> mFields){
    if (!isMfield) {
      fields=mFields;
    }
  }
  public void endJobInput(  String dataNode,  boolean failed){
    mjob++;
    if (mjob >= maxjob) {
      createQryJob(Integer.MAX_VALUE);
      ctx.endJobInput();
    }
  }
  private void createQryJob(  int batchSize){
    int count=0;
    Map<String,byte[]> batchRows=new ConcurrentHashMap<String,byte[]>();
    String theId=null;
    StringBuilder sb=new StringBuilder().append('(');
    String svalue="";
    for (    Map.Entry<String,String> e : ids.entrySet()) {
      theId=e.getKey();
      byte[] rowbyte=rows.remove(theId);
      if (rowbyte != null) {
        batchRows.put(theId,rowbyte);
      }
      if (!svalue.equals(e.getValue())) {
        if (joinKeyType == Fields.FIELD_TYPE_VAR_STRING || joinKeyType == Fields.FIELD_TYPE_STRING) {
          sb.append("'").append(e.getValue()).append("'").append(',');
        }
 else {
          sb.append(e.getValue()).append(',');
        }
      }
      svalue=e.getValue();
      if (count++ > batchSize) {
        break;
      }
    }
    if (count == 0) {
      return;
    }
    jointTableIsData=true;
    sb.deleteCharAt(sb.length() - 1).append(')');
    String sql=String.format(joinParser.getChildSQL(),sb);
    getRoute(sql);
    ctx.executeNativeSQLParallJob(getDataNodes(),sql,new ShareRowOutPutDataHandler(this,fields,joinindex,joinParser.getJoinRkey(),batchRows,ctx.getSession()));
    EngineCtx.LOGGER.info("SQLParallJob:" + getDataNode(getDataNodes()) + " sql:"+ sql);
  }
  public void writeHeader(  String dataNode,  List<byte[]> afields,  List<byte[]> bfields){
    sendField++;
    if (sendField == 1) {
      MiddlerResultHandler middlerResultHandler=sc.getSession2().getMiddlerResultHandler();
      if (middlerResultHandler == null) {
        ctx.writeHeader(afields,bfields);
      }
      setAllFields(afields,bfields);
    }
    setRowDataSorterHeader(afields,bfields);
  }
  private void setRowDataSorterHeader(  List<byte[]> afields,  List<byte[]> bfields){
    if (!ctx.getIsStreamOutputResult() && !isInit) {
synchronized (joinParser) {
        if (!isInit) {
          LinkedHashMap<String,Integer> orderByCols=joinParser.getOrderByCols();
          LinkedHashMap<String,Integer> childOrderByCols=joinParser.getChildByCols();
          OrderCol[] orderCols=new OrderCol[orderByCols.size() + childOrderByCols.size()];
          for (          String fileldName : orderByCols.keySet()) {
            ColMeta colMeta=getCommonFieldIndex(afields,fileldName);
            int val=orderByCols.get(fileldName);
            int orignIndex=TableFilter.decodeOrignOrder(val);
            int orderType=TableFilter.decodeOrderType(val);
            orderCols[orignIndex]=new OrderCol(colMeta,orderType);
          }
          for (          String fileldName : childOrderByCols.keySet()) {
            ColMeta colMeta=getCommonFieldIndex(bfields,fileldName);
            colMeta.setColIndex(colMeta.getColIndex() + afields.size() - 1);
            int val=childOrderByCols.get(fileldName);
            int orignIndex=TableFilter.decodeOrignOrder(val);
            int orderType=TableFilter.decodeOrderType(val);
            orderCols[orignIndex]=new OrderCol(colMeta,orderType);
          }
          RowDataSorter tmp=new RowDataSorter(orderCols);
          tmp.setLimit(joinParser.getOffset(),joinParser.getRowCount());
          sorter=tmp;
          isInit=true;
        }
      }
    }
  }
  private void setAllFields(  List<byte[]> afields,  List<byte[]> bfields){
    allfields=new ArrayList<byte[]>();
    for (    byte[] field : afields) {
      allfields.add(field);
    }
    for (int i=1; i < bfields.size(); i++) {
      allfields.add(bfields.get(i));
    }
  }
  public List<byte[]> getAllFields(){
    return allfields;
  }
  public void writeRow(  RowDataPacket rowDataPkg){
    if (ctx.getIsStreamOutputResult()) {
      ctx.writeRow(rowDataPkg);
    }
 else {
      if (isInit) {
        sorter.addRow(rowDataPkg);
      }
 else {
        EngineCtx.LOGGER.error("===怎么会还没初始化===");
      }
    }
  }
  protected void writeEof(){
    boolean t=jointTableIsData;
    if (ctx.getIsStreamOutputResult() || (!jointTableIsData)) {
      ctx.writeEof();
    }
 else {
      int start=joinParser.getOffset();
      int end=start + joinParser.getRowCount();
      List<RowDataPacket> results=sorter.getSortedResult();
      if (start < 0) {
        start=0;
      }
      if (joinParser.getRowCount() <= 0) {
        end=results.size();
      }
      if (end > results.size()) {
        end=results.size();
      }
      for (int i=start; i < end; i++) {
        ctx.writeRow(results.get(i));
      }
      ctx.writeEof();
    }
  }
  public int getFieldIndex(  List<byte[]> fields,  String fkey){
    int i=0;
    for (    byte[] field : fields) {
      FieldPacket fieldPacket=new FieldPacket();
      fieldPacket.read(field);
      if (ByteUtil.getString(fieldPacket.orgName).equals(fkey)) {
        joinKeyType=fieldPacket.type;
        return i;
      }
      i++;
    }
    return i;
  }
  public ColMeta getCommonFieldIndex(  List<byte[]> fields,  String fkey){
    int i=0;
    for (    byte[] field : fields) {
      FieldPacket fieldPacket=new FieldPacket();
      fieldPacket.read(field);
      if (ByteUtil.getString(fieldPacket.orgName).equals(fkey)) {
        return new ColMeta(i,fieldPacket.type);
      }
      i++;
    }
    return null;
  }
}
