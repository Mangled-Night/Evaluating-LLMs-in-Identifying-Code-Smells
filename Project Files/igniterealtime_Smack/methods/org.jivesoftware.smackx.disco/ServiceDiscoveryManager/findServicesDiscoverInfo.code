/** 
 * Find all services under the users service that provide a given feature.
 * @param feature the feature to search for
 * @param stopOnFirst if true, stop searching after the first service was found
 * @param useCache if true, query a cache first to avoid network I/O
 * @return a possible empty list of services providing the given feature
 * @throws NoResponseException if there was no response from the remote entity.
 * @throws XMPPErrorException if there was an XMPP error returned.
 * @throws NotConnectedException if the XMPP connection is not connected.
 * @throws InterruptedException if the calling thread was interrupted.
 */
public List<DiscoverInfo> findServicesDiscoverInfo(String feature,boolean stopOnFirst,boolean useCache) throws NoResponseException, XMPPErrorException, NotConnectedException, InterruptedException {
  return findServicesDiscoverInfo(feature,stopOnFirst,useCache,null);
}
/** 
 * Find all services under the users service that provide a given feature.
 * @param feature the feature to search for
 * @param stopOnFirst if true, stop searching after the first service was found
 * @param useCache if true, query a cache first to avoid network I/O
 * @param encounteredExceptions an optional map which will be filled with the exceptions encountered
 * @return a possible empty list of services providing the given feature
 * @throws NoResponseException if there was no response from the remote entity.
 * @throws XMPPErrorException if there was an XMPP error returned.
 * @throws NotConnectedException if the XMPP connection is not connected.
 * @throws InterruptedException if the calling thread was interrupted.
 * @since 4.2.2
 */
public List<DiscoverInfo> findServicesDiscoverInfo(String feature,boolean stopOnFirst,boolean useCache,Map<? super Jid,Exception> encounteredExceptions) throws NoResponseException, XMPPErrorException, NotConnectedException, InterruptedException {
  DomainBareJid serviceName=connection().getXMPPServiceDomain();
  return findServicesDiscoverInfo(serviceName,feature,stopOnFirst,useCache,encounteredExceptions);
}
/** 
 * Find all services under a given service that provide a given feature.
 * @param serviceName the service to query
 * @param feature the feature to search for
 * @param stopOnFirst if true, stop searching after the first service was found
 * @param useCache if true, query a cache first to avoid network I/O
 * @param encounteredExceptions an optional map which will be filled with the exceptions encountered
 * @return a possible empty list of services providing the given feature
 * @throws NoResponseException if there was no response from the remote entity.
 * @throws XMPPErrorException if there was an XMPP error returned.
 * @throws NotConnectedException if the XMPP connection is not connected.
 * @throws InterruptedException if the calling thread was interrupted.
 * @since 4.3.0
 */
public List<DiscoverInfo> findServicesDiscoverInfo(DomainBareJid serviceName,String feature,boolean stopOnFirst,boolean useCache,Map<? super Jid,Exception> encounteredExceptions) throws NoResponseException, XMPPErrorException, NotConnectedException, InterruptedException {
  List<DiscoverInfo> serviceDiscoInfo;
  if (useCache) {
    serviceDiscoInfo=services.lookup(feature);
    if (serviceDiscoInfo != null) {
      return serviceDiscoInfo;
    }
  }
  serviceDiscoInfo=new LinkedList<>();
  DiscoverInfo info;
  try {
    info=discoverInfo(serviceName);
  }
 catch (  XMPPErrorException e) {
    if (encounteredExceptions != null) {
      encounteredExceptions.put(serviceName,e);
    }
    return serviceDiscoInfo;
  }
  if (info.containsFeature(feature)) {
    serviceDiscoInfo.add(info);
    if (stopOnFirst) {
      if (useCache) {
        services.put(feature,serviceDiscoInfo);
      }
      return serviceDiscoInfo;
    }
  }
  DiscoverItems items;
  try {
    items=discoverItems(serviceName);
  }
 catch (  XMPPErrorException e) {
    if (encounteredExceptions != null) {
      encounteredExceptions.put(serviceName,e);
    }
    return serviceDiscoInfo;
  }
  for (  DiscoverItems.Item item : items.getItems()) {
    Jid address=item.getEntityID();
    try {
      info=discoverInfo(address);
    }
 catch (    XMPPErrorException|NoResponseException e) {
      if (encounteredExceptions != null) {
        encounteredExceptions.put(address,e);
      }
      continue;
    }
    if (info.containsFeature(feature)) {
      serviceDiscoInfo.add(info);
      if (stopOnFirst) {
        break;
      }
    }
  }
  if (useCache) {
    services.put(feature,serviceDiscoInfo);
  }
  return serviceDiscoInfo;
}
