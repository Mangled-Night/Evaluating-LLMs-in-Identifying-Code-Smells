/** 
 * Test for the InitiationListener class.
 * @author Henning Staib
 */
public class InitiationListenerTest extends SmackTestSuite {
  private static final EntityFullJid initiatorJID=JidTestUtil.DUMMY_AT_EXAMPLE_ORG_SLASH_DUMMYRESOURCE;
  private static final EntityFullJid targetJID=JidTestUtil.FULL_JID_1_RESOURCE_1;
  private static final String sessionID="session_id";
  private XMPPConnection connection;
  private InBandBytestreamManager byteStreamManager;
  private InitiationListener initiationListener;
  private Open initBytestream;
  /** 
 * Initialize fields used in the tests.
 */
  @BeforeEach public void setup(){
    connection=mock(XMPPConnection.class);
    byteStreamManager=InBandBytestreamManager.getByteStreamManager(connection);
    initiationListener=Whitebox.getInternalState(byteStreamManager,"initiationListener",InitiationListener.class);
    initBytestream=new Open(sessionID,4096);
    initBytestream.setFrom(initiatorJID);
    initBytestream.setTo(targetJID);
  }
  /** 
 * If no listeners are registered for incoming In-Band Bytestream requests, all request should be rejected with an error.
 * @throws Exception should not happen
 */
  @Test public void shouldRespondWithError() throws Exception {
    IQ response=initiationListener.handleIQRequest(initBytestream);
    assertEquals(initiatorJID,response.getTo());
    assertEquals(IQ.Type.error,response.getType());
    assertEquals(StanzaError.Condition.not_acceptable,response.getError().getCondition());
  }
  /** 
 * Open request with a block size that exceeds the maximum block size should be replied with an resource-constraint error.
 * @throws Exception should not happen
 */
  @Test public void shouldRejectRequestWithTooBigBlockSize() throws Exception {
    byteStreamManager.setMaximumBlockSize(1024);
    IQ response=initiationListener.handleIQRequest(initBytestream);
    assertEquals(initiatorJID,response.getTo());
    assertEquals(IQ.Type.error,response.getType());
    assertEquals(StanzaError.Condition.resource_constraint,response.getError().getCondition());
  }
  /** 
 * If a listener for all requests is registered it should be notified on incoming requests.
 * @throws Exception should not happen
 */
  @Test public void shouldInvokeListenerForAllRequests() throws Exception {
    InBandBytestreamListener listener=mock(InBandBytestreamListener.class);
    byteStreamManager.addIncomingBytestreamListener(listener);
    initiationListener.handleIQRequest(initBytestream);
    Thread.sleep(200);
    ArgumentCaptor<BytestreamRequest> byteStreamRequest=ArgumentCaptor.forClass(BytestreamRequest.class);
    verify(listener).incomingBytestreamRequest(byteStreamRequest.capture());
    assertEquals(initiatorJID,byteStreamRequest.getValue().getFrom());
  }
  /** 
 * If a listener for a specific user in registered it should be notified on incoming requests for that user.
 * @throws Exception should not happen
 */
  @Test public void shouldInvokeListenerForUser() throws Exception {
    InBandBytestreamListener listener=mock(InBandBytestreamListener.class);
    byteStreamManager.addIncomingBytestreamListener(listener,initiatorJID);
    initiationListener.handleIQRequest(initBytestream);
    Thread.sleep(200);
    ArgumentCaptor<BytestreamRequest> byteStreamRequest=ArgumentCaptor.forClass(BytestreamRequest.class);
    verify(listener).incomingBytestreamRequest(byteStreamRequest.capture());
    assertEquals(initiatorJID,byteStreamRequest.getValue().getFrom());
  }
  /** 
 * If listener for a specific user is registered it should not be notified on incoming requests from other users.
 * @throws Exception should not happen
 */
  @Test public void shouldNotInvokeListenerForUser() throws Exception {
    InBandBytestreamListener listener=mock(InBandBytestreamListener.class);
    byteStreamManager.addIncomingBytestreamListener(listener,JidCreate.from("other_" + initiatorJID));
    IQ response=initiationListener.handleIQRequest(initBytestream);
    ArgumentCaptor<BytestreamRequest> byteStreamRequest=ArgumentCaptor.forClass(BytestreamRequest.class);
    verify(listener,never()).incomingBytestreamRequest(byteStreamRequest.capture());
    assertEquals(initiatorJID,response.getTo());
    assertEquals(IQ.Type.error,response.getType());
    assertEquals(StanzaError.Condition.not_acceptable,response.getError().getCondition());
  }
  /** 
 * If a user specific listener and an all requests listener is registered only the user specific listener should be notified.
 * @throws Exception should not happen
 */
  @Test public void shouldNotInvokeAllRequestsListenerIfUserListenerExists() throws Exception {
    InBandBytestreamListener allRequestsListener=mock(InBandBytestreamListener.class);
    byteStreamManager.addIncomingBytestreamListener(allRequestsListener);
    InBandBytestreamListener userRequestsListener=mock(InBandBytestreamListener.class);
    byteStreamManager.addIncomingBytestreamListener(userRequestsListener,initiatorJID);
    initiationListener.handleIQRequest(initBytestream);
    Thread.sleep(200);
    ArgumentCaptor<BytestreamRequest> byteStreamRequest=ArgumentCaptor.forClass(BytestreamRequest.class);
    verify(userRequestsListener).incomingBytestreamRequest(byteStreamRequest.capture());
    byteStreamRequest=ArgumentCaptor.forClass(BytestreamRequest.class);
    verify(allRequestsListener,never()).incomingBytestreamRequest(byteStreamRequest.capture());
  }
  /** 
 * If a user specific listener and an all requests listener is registered only the all requests listener should be notified on an incoming request for another user.
 * @throws Exception should not happen
 */
  @Test public void shouldInvokeAllRequestsListenerIfUserListenerExists() throws Exception {
    InBandBytestreamListener allRequestsListener=mock(InBandBytestreamListener.class);
    byteStreamManager.addIncomingBytestreamListener(allRequestsListener);
    InBandBytestreamListener userRequestsListener=mock(InBandBytestreamListener.class);
    byteStreamManager.addIncomingBytestreamListener(userRequestsListener,JidCreate.from("other_" + initiatorJID));
    initiationListener.handleIQRequest(initBytestream);
    Thread.sleep(200);
    ArgumentCaptor<BytestreamRequest> byteStreamRequest=ArgumentCaptor.forClass(BytestreamRequest.class);
    verify(userRequestsListener,never()).incomingBytestreamRequest(byteStreamRequest.capture());
    byteStreamRequest=ArgumentCaptor.forClass(BytestreamRequest.class);
    verify(allRequestsListener).incomingBytestreamRequest(byteStreamRequest.capture());
  }
  /** 
 * If a request with a specific session ID should be ignored no listeners should be notified.
 * @throws Exception should not happen
 */
  @Test public void shouldIgnoreInBandBytestreamRequestOnce() throws Exception {
    InBandBytestreamListener allRequestsListener=mock(InBandBytestreamListener.class);
    byteStreamManager.addIncomingBytestreamListener(allRequestsListener);
    InBandBytestreamListener userRequestsListener=mock(InBandBytestreamListener.class);
    byteStreamManager.addIncomingBytestreamListener(userRequestsListener,initiatorJID);
    byteStreamManager.ignoreBytestreamRequestOnce(sessionID);
    initiationListener.handleIQRequest(initBytestream);
    Thread.sleep(200);
    ArgumentCaptor<BytestreamRequest> byteStreamRequest=ArgumentCaptor.forClass(BytestreamRequest.class);
    verify(userRequestsListener,never()).incomingBytestreamRequest(byteStreamRequest.capture());
    byteStreamRequest=ArgumentCaptor.forClass(BytestreamRequest.class);
    verify(allRequestsListener,never()).incomingBytestreamRequest(byteStreamRequest.capture());
    initiationListener.handleIQRequest(initBytestream);
    Thread.sleep(200);
    verify(userRequestsListener).incomingBytestreamRequest(byteStreamRequest.capture());
    byteStreamRequest=ArgumentCaptor.forClass(BytestreamRequest.class);
    verify(allRequestsListener,never()).incomingBytestreamRequest(byteStreamRequest.capture());
  }
}
