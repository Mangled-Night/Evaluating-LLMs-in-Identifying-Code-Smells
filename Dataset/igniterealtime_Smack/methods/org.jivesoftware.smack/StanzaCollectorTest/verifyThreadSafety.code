/** 
 * Although this doesn't guarantee anything due to the nature of threading, it can potentially catch problems.
 * @throws InterruptedException if interrupted.
 */
@SuppressWarnings("ThreadPriorityCheck") @Test public void verifyThreadSafety() throws InterruptedException {
  final int insertCount=500;
  final StanzaCollector collector=createTestStanzaCollector(null,new OKEverything(),insertCount);
  final AtomicInteger consumer1Dequeued=new AtomicInteger();
  final AtomicInteger consumer2Dequeued=new AtomicInteger();
  final AtomicInteger consumer3Dequeued=new AtomicInteger();
  Thread consumer1=new Thread(new Runnable(){
    @Override public void run(){
      int dequeueCount=0;
      try {
        while (true) {
          Thread.yield();
          Stanza packet=collector.nextResultBlockForever();
          if (packet != null) {
            dequeueCount++;
          }
        }
      }
 catch (      InterruptedException e) {
      }
 finally {
        consumer1Dequeued.set(dequeueCount);
      }
    }
  }
);
  consumer1.setName("consumer 1");
  Thread consumer2=new Thread(new Runnable(){
    @Override public void run(){
      Stanza p;
      int dequeueCount=0;
      do {
        Thread.yield();
        try {
          p=collector.nextResult(1000);
        }
 catch (        InterruptedException e) {
          throw new RuntimeException(e);
        }
        if (p != null) {
          dequeueCount++;
        }
      }
 while (p != null);
      consumer2Dequeued.set(dequeueCount);
    }
  }
);
  consumer2.setName("consumer 2");
  Thread consumer3=new Thread(new Runnable(){
    @Override public void run(){
      Stanza p;
      int dequeueCount=0;
      do {
        Thread.yield();
        p=collector.pollResult();
        if (p != null) {
          dequeueCount++;
        }
      }
 while (p != null);
      consumer3Dequeued.set(dequeueCount);
    }
  }
);
  consumer3.setName("consumer 3");
  for (int i=0; i < insertCount; i++) {
    collector.processStanza(new TestPacket(i));
  }
  consumer1.start();
  consumer2.start();
  consumer3.start();
  consumer3.join();
  consumer2.join();
  consumer1.interrupt();
  consumer1.join();
  assertNull(collector.pollResult());
  int consumer1DequeuedLocal=consumer1Dequeued.get();
  int consumer2DequeuedLocal=consumer2Dequeued.get();
  int consumer3DequeuedLocal=consumer3Dequeued.get();
  final int totalDequeued=consumer1DequeuedLocal + consumer2DequeuedLocal + consumer3DequeuedLocal;
  assertEquals("Inserted " + insertCount + " but only "+ totalDequeued+ " c1: "+ consumer1DequeuedLocal+ " c2: "+ consumer2DequeuedLocal+ " c3: "+ consumer3DequeuedLocal,insertCount,totalDequeued);
}
