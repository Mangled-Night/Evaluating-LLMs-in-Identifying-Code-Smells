/** 
 * life cycle: from connection establish to close <br/>
 * @author mycat
 */
public class MySQLConnectionHandler extends BackendAsyncHandler {
  private static final Logger logger=LoggerFactory.getLogger(MySQLConnectionHandler.class);
  private static final int RESULT_STATUS_INIT=0;
  private static final int RESULT_STATUS_HEADER=1;
  private static final int RESULT_STATUS_FIELD_EOF=2;
  private static final int RESULT_STATUS_PREPARE_RESPONSE_OK=3;
  private final MySQLConnection source;
  private volatile int resultStatus;
  private volatile byte[] header;
  private volatile List<byte[]> fields;
  private static final Logger LOGGER=LoggerFactory.getLogger(MySQLConnectionHandler.class);
  /** 
 * life cycle: one SQL execution
 */
  private volatile ResponseHandler responseHandler;
  public MySQLConnectionHandler(  MySQLConnection source){
    this.source=source;
    this.resultStatus=RESULT_STATUS_INIT;
  }
  public void connectionError(  Throwable e){
    if (responseHandler != null) {
      responseHandler.connectionError(e,source);
    }
    LOGGER.error("connectionError but not handle");
  }
  public MySQLConnection getSource(){
    return source;
  }
  @Override public void handle(  byte[] data){
    offerData(data,source.getProcessor().getExecutor());
  }
  @Override protected void offerDataError(){
    resultStatus=RESULT_STATUS_INIT;
    throw new RuntimeException("offer data error!");
  }
  @Override protected void handleData(  byte[] data){
switch (resultStatus) {
case RESULT_STATUS_INIT:
switch (data[4]) {
case OkPacket.FIELD_COUNT:
        int packetSize=(int)ByteUtil.readLength(data,0);
      if (packetSize == PreparedOkPacket.PACKET_SIZE && (responseHandler != null && responseHandler instanceof PrepareRequestHandler)) {
        handlePrepareOkPacket(data);
        resultStatus=RESULT_STATUS_PREPARE_RESPONSE_OK;
      }
 else {
        handleOkPacket(data);
      }
    break;
case ErrorPacket.FIELD_COUNT:
  handleErrorPacket(data);
break;
case RequestFilePacket.FIELD_COUNT:
handleRequestPacket(data);
break;
default :
resultStatus=RESULT_STATUS_HEADER;
header=data;
fields=new ArrayList<byte[]>((int)ByteUtil.readLength(data,4));
}
break;
case RESULT_STATUS_HEADER:
switch (data[4]) {
case ErrorPacket.FIELD_COUNT:
resultStatus=RESULT_STATUS_INIT;
handleErrorPacket(data);
break;
case EOFPacket.FIELD_COUNT:
resultStatus=RESULT_STATUS_FIELD_EOF;
handleFieldEofPacket(data);
break;
default :
fields.add(data);
}
break;
case RESULT_STATUS_FIELD_EOF:
switch (data[4]) {
case ErrorPacket.FIELD_COUNT:
resultStatus=RESULT_STATUS_INIT;
handleErrorPacket(data);
break;
case EOFPacket.FIELD_COUNT:
resultStatus=RESULT_STATUS_INIT;
handleRowEofPacket(data);
break;
default :
handleRowPacket(data);
}
break;
case RESULT_STATUS_PREPARE_RESPONSE_OK:
handlePrepareOkPacket(data);
break;
default :
throw new RuntimeException("unknown status!");
}
}
public void setResponseHandler(ResponseHandler responseHandler){
if (responseHandler == null && resultStatus != RESULT_STATUS_INIT) {
logger.warn("try to reset resultStatus. last responseHandler:{}, resultStatus = {}",this.responseHandler,resultStatus);
resultStatus=RESULT_STATUS_INIT;
}
this.responseHandler=responseHandler;
}
private void handleLogNodeInfo(String pkgName){
Object att=source.getAttachment();
if (LOGGER.isDebugEnabled() && att != null && att instanceof RouteResultsetNode) {
RouteResultsetNode rrn=(RouteResultsetNode)att;
String sql=rrn.getStatement();
if (sql != null) {
sql=sql.replaceAll("[\r\n]+","");
}
LOGGER.debug("{} MySQLConnection@{} [id={}] for node={}, sql={}",new Object[]{pkgName,source.hashCode(),source.getId(),rrn.getName(),sql});
}
}
/** 
 * prepare response OK数据包处理
 */
private void handlePrepareOkPacket(byte[] data){
ResponseHandler respHand=responseHandler;
if (respHand != null) {
respHand.okResponse(data,source);
if (((PrepareRequestHandler)respHand).isLastPacket()) {
this.resultStatus=RESULT_STATUS_INIT;
}
}
 else {
LOGGER.error("receive OkPacket but not handle");
source.close("receive OkPacket but not handle");
}
}
/** 
 * OK数据包处理
 */
private void handleOkPacket(byte[] data){
ResponseHandler respHand=responseHandler;
if (respHand != null) {
handleLogNodeInfo("handleOkPacket");
respHand.okResponse(data,source);
}
 else {
LOGGER.error("receive OkPacket but not handle");
}
}
/** 
 * ERROR数据包处理
 */
private void handleErrorPacket(byte[] data){
ResponseHandler respHand=responseHandler;
if (respHand != null) {
handleLogNodeInfo("handleErrorPacket");
respHand.errorResponse(data,source);
}
 else {
LOGGER.error("receive ErrorPacket but no handler");
closeNoHandler();
}
}
/** 
 * load data file 请求文件数据包处理
 */
private void handleRequestPacket(byte[] data){
ResponseHandler respHand=responseHandler;
if (respHand != null && respHand instanceof LoadDataResponseHandler) {
((LoadDataResponseHandler)respHand).requestDataResponse(data,source);
}
 else {
LOGGER.error("receive RequestPacket but no handler");
closeNoHandler();
}
}
/** 
 * 字段数据包结束处理
 */
private void handleFieldEofPacket(byte[] data){
ResponseHandler respHand=responseHandler;
if (respHand != null) {
handleLogNodeInfo("handleFieldEofPacket");
respHand.fieldEofResponse(header,fields,data,source);
}
 else {
LOGGER.error("receive FieldEofPacket but no handler");
closeNoHandler();
}
}
/** 
 * 行数据包处理
 */
private void handleRowPacket(byte[] data){
ResponseHandler respHand=responseHandler;
if (respHand != null) {
respHand.rowResponse(data,source);
}
 else {
LOGGER.error("receive RowPacket but no handler");
closeNoHandler();
}
}
private void closeNoHandler(){
if (!source.isClosedOrQuit()) {
source.close("no handler");
logger.warn("no handler bind in this con " + this + " client:"+ source);
}
}
/** 
 * 行数据包结束处理
 */
private void handleRowEofPacket(byte[] data){
if (responseHandler != null) {
handleLogNodeInfo("handleRowEofPacket");
responseHandler.rowEofResponse(data,source);
}
 else {
LOGGER.error("receive RowEofPacket but no handler");
closeNoHandler();
}
}
}
