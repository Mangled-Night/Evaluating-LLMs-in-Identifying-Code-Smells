/** 
 * MUC Light blocking IQ provider class.
 * @author Fernando Ramirez
 */
public class MUCLightBlockingIQProvider extends IqProvider<MUCLightBlockingIQ> {
  @Override public MUCLightBlockingIQ parse(  XmlPullParser parser,  int initialDepth,  IqData iqData,  XmlEnvironment xmlEnvironment) throws XmlPullParserException, IOException {
    HashMap<Jid,Boolean> rooms=null;
    HashMap<Jid,Boolean> users=null;
    outerloop:     while (true) {
      XmlPullParser.Event eventType=parser.next();
      if (eventType == XmlPullParser.Event.START_ELEMENT) {
        if (parser.getName().equals("room")) {
          rooms=parseBlocking(parser,rooms);
        }
        if (parser.getName().equals("user")) {
          users=parseBlocking(parser,users);
        }
      }
 else       if (eventType == XmlPullParser.Event.END_ELEMENT) {
        if (parser.getDepth() == initialDepth) {
          break outerloop;
        }
      }
    }
    MUCLightBlockingIQ mucLightBlockingIQ=new MUCLightBlockingIQ(rooms,users);
    mucLightBlockingIQ.setType(IQ.Type.result);
    return mucLightBlockingIQ;
  }
  private static HashMap<Jid,Boolean> parseBlocking(  XmlPullParser parser,  HashMap<Jid,Boolean> map) throws XmppStringprepException, XmlPullParserException, IOException {
    if (map == null) {
      map=new HashMap<>();
    }
    String action=parser.getAttributeValue("","action");
    if (action.equals("deny")) {
      map.put(JidCreate.from(parser.nextText()),false);
    }
 else     if (action.equals("allow")) {
      map.put(JidCreate.from(parser.nextText()),true);
    }
    return map;
  }
}
