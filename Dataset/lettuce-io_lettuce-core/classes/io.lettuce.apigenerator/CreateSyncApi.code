/** 
 * Create sync API based on the templates.
 * @author Mark Paluch
 */
class CreateSyncApi {
  private static final Set<String> FILTER_METHODS=LettuceSets.unmodifiableSet("setAutoFlushCommands","flushCommands");
  /** 
 * Mutate type comment.
 * @return
 */
  Function<String,String> commentMutator(){
    return s -> s.replaceAll("\\$\\{intent\\}","Synchronous executed commands") + "* @generated by " + getClass().getName()+ "\r\n ";
  }
  /** 
 * Method filter
 * @return
 */
  Predicate<MethodDeclaration> methodFilter(){
    return method -> !CompilationUnitFactory.contains(FILTER_METHODS,method);
  }
  /** 
 * Mutate type to async result.
 * @return
 */
  Function<MethodDeclaration,Type> methodTypeMutator(){
    return MethodDeclaration::getType;
  }
  /** 
 * Supply additional imports.
 * @return
 */
  Supplier<List<String>> importSupplier(){
    return Collections::emptyList;
  }
  @ParameterizedTest @MethodSource("arguments") void createInterface(  String argument) throws Exception {
    createFactory(argument).createInterface();
  }
  static List<String> arguments(){
    return Arrays.asList(Constants.TEMPLATE_NAMES);
  }
  private CompilationUnitFactory createFactory(  String templateName){
    String targetName=templateName;
    File templateFile=new File(Constants.TEMPLATES,"io/lettuce/core/api/" + templateName + ".java");
    String targetPackage;
    if (templateName.contains("RedisSentinel")) {
      targetPackage="io.lettuce.core.sentinel.api.sync";
    }
 else {
      targetPackage="io.lettuce.core.api.sync";
    }
    return new CompilationUnitFactory(templateFile,Constants.SOURCES,targetPackage,targetName,commentMutator(),methodTypeMutator(),methodFilter(),importSupplier(),null,Function.identity());
  }
}
