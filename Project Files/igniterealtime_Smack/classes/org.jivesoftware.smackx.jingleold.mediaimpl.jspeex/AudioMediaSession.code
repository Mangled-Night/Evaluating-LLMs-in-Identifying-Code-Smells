/** 
 * This Class implements a complete JingleMediaSession. It should be used to transmit and receive audio captured from the Mic. This Class should be automatically controlled by JingleSession. But you could also use in any VOIP application. For better NAT Traversal support this implementation don't support only receive or only transmit. To receive you MUST transmit. So the only implemented and functionally methods are startTransmit() and stopTransmit()
 * @author Thiago Camargo
 */
public class AudioMediaSession extends JingleMediaSession implements MediaSessionListener {
  private static final Logger LOGGER=Logger.getLogger(AudioMediaSession.class.getName());
  private MediaSession mediaSession;
  /** 
 * Create a Session using Speex Codec.
 * @param localhost    localHost
 * @param localPort    localPort
 * @param remoteHost   remoteHost
 * @param remotePort   remotePort
 * @param eventHandler eventHandler
 * @param quality      quality
 * @param secure       secure
 * @param micOn        micOn
 * @return MediaSession TODO javadoc me please
 * @throws NoProcessorException if there is no media processor.
 * @throws UnsupportedFormatException if the format is not supported.
 * @throws IOException if an I/O error occurred.
 * @throws GeneralSecurityException if there was a geneeral security exception.
 */
  public static MediaSession createSession(  String localhost,  int localPort,  String remoteHost,  int remotePort,  MediaSessionListener eventHandler,  int quality,  boolean secure,  boolean micOn) throws NoProcessorException, UnsupportedFormatException, IOException, GeneralSecurityException {
    SpeexFormat.setFramesPerPacket(1);
    byte[] masterKey=new byte[]{(byte)0xE1,(byte)0xF9,0x7A,0x0D,0x3E,0x01,(byte)0x8B,(byte)0xE0,(byte)0xD6,0x4F,(byte)0xA3,0x2C,0x06,(byte)0xDE,0x41,0x39};
    byte[] masterSalt=new byte[]{0x0E,(byte)0xC6,0x75,(byte)0xAD,0x49,(byte)0x8A,(byte)0xFE,(byte)0xEB,(byte)0xB6,(byte)0x96,0x0B,0x3A,(byte)0xAB,(byte)0xE6};
    DatagramSocket[] localPorts=MediaSession.getLocalPorts(InetAddress.getByName(localhost),localPort);
    MediaSession session=MediaSession.createInstance(remoteHost,remotePort,localPorts,quality,secure,masterKey,masterSalt);
    session.setListener(eventHandler);
    session.setSourceDescription(new SourceDescription[]{new SourceDescription(SourceDescription.SOURCE_DESC_NAME,"Superman",1,false),new SourceDescription(SourceDescription.SOURCE_DESC_EMAIL,"cdcie.tester@je.jfcom.mil",1,false),new SourceDescription(SourceDescription.SOURCE_DESC_LOC,InetAddress.getByName(localhost) + " Port " + session.getLocalDataPort(),1,false),new SourceDescription(SourceDescription.SOURCE_DESC_TOOL,"JFCOM CDCIE Audio Chat",1,false)});
    return session;
  }
  /** 
 * Creates a org.jivesoftware.jingleaudio.jspeex.AudioMediaSession with defined payload type, remote and local candidates.
 * @param payloadType Payload of the jmf
 * @param remote      the remote information. The candidate that the jmf will be sent to.
 * @param local       the local information. The candidate that will receive the jmf
 * @param locator     media locator
 * @param jingleSession the jingle session.
 */
  public AudioMediaSession(  final PayloadType payloadType,  final TransportCandidate remote,  final TransportCandidate local,  String locator,  JingleSession jingleSession){
    super(payloadType,remote,local,locator == null ? "dsound://" : locator,jingleSession);
    initialize();
  }
  /** 
 * Initialize the Audio Channel to make it able to send and receive audio.
 */
  @Override public void initialize(){
    String ip;
    String localIp;
    int localPort;
    int remotePort;
    if (this.getLocal().getSymmetric() != null) {
      ip=this.getLocal().getIp();
      localIp=this.getLocal().getLocalIp();
      localPort=getFreePort();
      remotePort=this.getLocal().getSymmetric().getPort();
      LOGGER.fine(this.getLocal().getConnection() + " " + ip+ ": "+ localPort+ "->"+ remotePort);
    }
 else {
      ip=this.getRemote().getIp();
      localIp=this.getLocal().getLocalIp();
      localPort=this.getLocal().getPort();
      remotePort=this.getRemote().getPort();
    }
    try {
      mediaSession=createSession(localIp,localPort,ip,remotePort,this,2,false,true);
    }
 catch (    NoProcessorException e) {
      LOGGER.log(Level.WARNING,"exception",e);
    }
catch (    UnsupportedFormatException e) {
      LOGGER.log(Level.WARNING,"exception",e);
    }
catch (    IOException e) {
      LOGGER.log(Level.WARNING,"exception",e);
    }
catch (    GeneralSecurityException e) {
      LOGGER.log(Level.WARNING,"exception",e);
    }
  }
  /** 
 * Starts transmission and for NAT Traversal reasons start receiving also.
 * @deprecated use {@link #startTransmit()} instead.
 */
  @Deprecated public void startTrasmit(){
    startTransmit();
  }
  /** 
 * Starts transmission and for NAT Traversal reasons start receiving also.
 */
  @Override public void startTransmit(){
    try {
      LOGGER.fine("start");
      mediaSession.start(true);
      this.mediaReceived("");
    }
 catch (    IOException e) {
      LOGGER.log(Level.WARNING,"exception",e);
    }
  }
  /** 
 * Set transmit activity. If the active is true, the instance should transmit. If it is set to false, the instance should pause transmit.
 * @param active active state
 * @deprecated use {@link #setTransmit(boolean)} instead.
 */
  @Deprecated public void setTrasmit(  boolean active){
    setTransmit(active);
  }
  /** 
 * Set transmit activity. If the active is true, the instance should transmit. If it is set to false, the instance should pause transmit.
 * @param active active state
 */
  @Override public void setTransmit(  boolean active){
  }
  /** 
 * For NAT Reasons this method does nothing. Use startTransmit() to start transmit and receive jmf
 */
  @Override public void startReceive(){
  }
  /** 
 * Stops transmission and for NAT Traversal reasons stop receiving also.
 * @deprecated use {@link #stopTransmit()} instead.
 */
  @Deprecated public void stopTrasmit(){
    stopTransmit();
  }
  /** 
 * Stops transmission and for NAT Traversal reasons stop receiving also.
 */
  @Override public void stopTransmit(){
    if (mediaSession != null)     mediaSession.close();
  }
  /** 
 * For NAT Reasons this method does nothing. Use startTransmit() to start transmit and receive jmf
 */
  @Override public void stopReceive(){
  }
  @Override public void newStreamIdentified(  StreamPlayer streamPlayer){
  }
  @Override public void senderReportReceived(  SenderReport report){
  }
  @Override public void streamClosed(  StreamPlayer stream,  boolean timeout){
  }
  /** 
 * Obtain a free port we can use.
 * @return A free port number.
 */
  protected int getFreePort(){
    ServerSocket ss;
    int freePort=0;
    for (int i=0; i < 10; i++) {
      freePort=(int)(10000 + Math.round(Math.random() * 10000));
      freePort=freePort % 2 == 0 ? freePort : freePort + 1;
      try {
        ss=new ServerSocket(freePort);
        freePort=ss.getLocalPort();
        ss.close();
        return freePort;
      }
 catch (      IOException e) {
        LOGGER.log(Level.WARNING,"exception",e);
      }
    }
    try {
      ss=new ServerSocket(0);
      freePort=ss.getLocalPort();
      ss.close();
    }
 catch (    IOException e) {
      LOGGER.log(Level.WARNING,"exception",e);
    }
    return freePort;
  }
}
