/** 
 * Performs a partial sort by copying data into destination offsets for each byte value at the specified byte offset.
 * @param array array to partially sort.
 * @param numRecords number of data records in the array.
 * @param counts counts for each byte value. This routine destructively modifies this array.
 * @param byteIdx the byte in a long to sort at, counting from the least significant byte.
 * @param inIndex the starting index in the array where input data is located.
 * @param outIndex the starting index where sorted output data should be written.
 * @param desc whether this is a descending (binary-order) sort.
 * @param signed whether this is a signed (two's complement) sort (only applies to last byte).
 */
private static void sortAtByte(LongArray array,int numRecords,long[] counts,int byteIdx,int inIndex,int outIndex,boolean desc,boolean signed){
  assert counts.length == 256;
  long[] offsets=transformCountsToOffsets(counts,numRecords,array.getBaseOffset() + outIndex * 8,8,desc,signed);
  Object baseObject=array.getBaseObject();
  long baseOffset=array.getBaseOffset() + inIndex * 8;
  long maxOffset=baseOffset + numRecords * 8;
  for (long offset=baseOffset; offset < maxOffset; offset+=8) {
    long value=Platform.getLong(baseObject,offset);
    int bucket=(int)((value >>> (byteIdx * 8)) & 0xff);
    Platform.putLong(baseObject,offsets[bucket],value);
    offsets[bucket]+=8;
  }
}
