/** 
 * Pings the given jid. This method will return false if an error occurs.  The exception to this, is a server ping, which will always return true if the server is reachable, event if there is an error on the ping itself (i.e. ping not supported). <p> Use  {@link #isPingSupported(Jid)} to determine if XMPP Ping is supportedby the entity.
 * @param jid The id of the entity the ping is being sent to
 * @param pingTimeout The time to wait for a reply in milliseconds
 * @return true if a reply was received from the entity, false otherwise.
 * @throws NoResponseException if there was no response from the jid.
 * @throws NotConnectedException if the XMPP connection is not connected.
 * @throws InterruptedException if the calling thread was interrupted.
 */
public boolean ping(Jid jid,long pingTimeout) throws NotConnectedException, NoResponseException, InterruptedException {
  final XMPPConnection connection=connection();
  if (!connection.isAuthenticated()) {
    throw new NotConnectedException();
  }
  Ping ping=new Ping(connection,jid);
  try {
    connection.createStanzaCollectorAndSend(ping).nextResultOrThrow(pingTimeout);
  }
 catch (  XMPPErrorException e) {
    return isValidErrorPong(jid,e);
  }
  return true;
}
/** 
 * Same as calling  {@link #ping(Jid,long)} with the defaultpacket replytimeout.
 * @param jid The id of the entity the ping is being sent to
 * @return true if a reply was received from the entity, false otherwise.
 * @throws NotConnectedException if the XMPP connection is not connected.
 * @throws NoResponseException if there was no response from the jid.
 * @throws InterruptedException if the calling thread was interrupted.
 */
public boolean ping(Jid jid) throws NotConnectedException, NoResponseException, InterruptedException {
  return ping(jid,connection().getReplyTimeout());
}
