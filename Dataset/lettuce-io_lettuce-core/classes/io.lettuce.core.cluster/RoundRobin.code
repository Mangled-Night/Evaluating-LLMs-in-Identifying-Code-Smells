/** 
 * Circular element provider. This class allows infinite scrolling over a collection with the possibility to provide an initial offset.
 * @author Mark Paluch
 * @author Christian Lang
 */
class RoundRobin<V> {
  protected volatile Collection<? extends V> collection=Collections.emptyList();
  protected volatile V offset;
  private final BiPredicate<V,V> isEqual;
  public RoundRobin(){
    this((a,b) -> true);
  }
  public RoundRobin(  BiPredicate<V,V> hasElementChanged){
    this.isEqual=hasElementChanged;
  }
  /** 
 * Return whether this  {@link RoundRobin} is still consistent and contains all items from the leader {@link Collection} andvice versa.
 * @param leader the leader collection containing source elements for this {@link RoundRobin}.
 * @return {@code true} if this {@link RoundRobin} is consistent with the leader {@link Collection}.
 */
  public boolean isConsistent(  Collection<? extends V> leader){
    Collection<? extends V> collection=this.collection;
    if (collection.size() != leader.size()) {
      return false;
    }
    for (    V currentElement : collection) {
      boolean found=find(leader,currentElement);
      if (!found) {
        return false;
      }
    }
    return true;
  }
  private boolean find(  Collection<? extends V> hayStack,  V needle){
    for (    V searchedElement : hayStack) {
      if (searchedElement.equals(needle)) {
        return isEqual.test(needle,searchedElement);
      }
    }
    return false;
  }
  /** 
 * Rebuild the  {@link RoundRobin} from the leader {@link Collection}.
 * @param leader the leader collection containing source elements for this {@link RoundRobin}.
 */
  public void rebuild(  Collection<? extends V> leader){
    this.collection=new ArrayList<>(leader);
    this.offset=null;
  }
  /** 
 * Returns the next item.
 * @return the next item
 */
  public V next(){
    Collection<? extends V> collection=this.collection;
    V offset=this.offset;
    if (offset != null) {
      boolean accept=false;
      for (      V element : collection) {
        if (element == offset) {
          accept=true;
          continue;
        }
        if (accept) {
          return this.offset=element;
        }
      }
    }
    return this.offset=collection.iterator().next();
  }
}
