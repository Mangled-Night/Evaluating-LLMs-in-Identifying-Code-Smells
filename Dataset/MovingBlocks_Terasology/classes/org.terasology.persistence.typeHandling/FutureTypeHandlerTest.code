public class FutureTypeHandlerTest {
  private final Reflections reflections=new Reflections(getClass().getClassLoader());
  private final TypeHandlerLibrary typeHandlerLibrary=Mockito.spy(new TypeHandlerLibrary(reflections));
private static final class RecursiveType<T> {
    final T data;
    final List<RecursiveType<T>> children;
    @SafeVarargs private RecursiveType(    T data,    RecursiveType<T>... children){
      this.data=data;
      this.children=Lists.newArrayList(children);
    }
  }
private class ResultCaptor<T> implements Answer {
    private T result=null;
    public T getResult(){
      return result;
    }
    @Override public T answer(    InvocationOnMock invocationOnMock) throws Throwable {
      result=(T)invocationOnMock.callRealMethod();
      return result;
    }
  }
  @Test public void testRecursiveType(){
    ResultCaptor<Optional<TypeHandler<RecursiveType<Integer>>>> resultCaptor=new ResultCaptor<>();
    doAnswer(resultCaptor).when(typeHandlerLibrary).getTypeHandler(eq(new TypeInfo<RecursiveType<Integer>>(){
    }
.getType()));
    TypeHandler<RecursiveType<Integer>> typeHandler=typeHandlerLibrary.getTypeHandler(new TypeInfo<RecursiveType<Integer>>(){
    }
).get();
    verify(typeHandlerLibrary,times(1)).getTypeHandler(eq(new TypeInfo<RecursiveType<Integer>>(){
    }
.getType()));
    TypeHandler possibleFuture=assertDoesNotThrow(() -> resultCaptor.getResult().get());
    assertTrue(possibleFuture instanceof FutureTypeHandler);
    FutureTypeHandler<RecursiveType<Integer>> future=(FutureTypeHandler<RecursiveType<Integer>>)possibleFuture;
    assertEquals(typeHandler,future.typeHandler);
  }
}
