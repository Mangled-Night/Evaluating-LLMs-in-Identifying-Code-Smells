/** 
 * An abstract Jingle session. This class contains some basic properties of every Jingle session. However, the concrete implementation can be found in subclasses.
 * @author Alvaro Saurin
 * @author Jeff Williams
 */
public final class JingleSession extends JingleNegotiator implements MediaReceivedListener {
  private static final Logger LOGGER=Logger.getLogger(JingleSession.class.getName());
  private static final HashMap<XMPPConnection,JingleSession> sessions=new HashMap<>();
  private static final Random randomGenerator=new Random();
  private Jid initiator;
  private Jid responder;
  private String sid;
  private ConnectionListener connectionListener;
  private StanzaListener packetListener;
  private StanzaFilter packetFilter;
  List<JingleMediaManager> jingleMediaManagers=null;
  private JingleSessionState sessionState;
  private final List<ContentNegotiator> contentNegotiators;
  private final XMPPConnection connection;
  private String sessionInitPacketID;
  private final Map<String,JingleMediaSession> mediaSessionMap;
  /** 
 * Full featured JingleSession constructor.
 * @param conn TODO javadoc me pleasethe XMPPConnection which is used
 * @param initiator TODO javadoc me pleasethe initiator JID
 * @param responder TODO javadoc me pleasethe responder JID
 * @param sessionid TODO javadoc me pleasethe session ID
 * @param jingleMediaManagers TODO javadoc me pleasethe jingleMediaManager
 */
  public JingleSession(  XMPPConnection conn,  Jid initiator,  Jid responder,  String sessionid,  List<JingleMediaManager> jingleMediaManagers){
    super();
    this.initiator=initiator;
    this.responder=responder;
    this.sid=sessionid;
    this.jingleMediaManagers=jingleMediaManagers;
    this.setSession(this);
    this.connection=conn;
    setSessionState(JingleSessionStateUnknown.getInstance());
    contentNegotiators=new ArrayList<>();
    mediaSessionMap=new HashMap<>();
    registerInstance();
    installConnectionListeners(conn);
  }
  /** 
 * JingleSession constructor (for an outgoing Jingle session).
 * @param conn Connection
 * @param request the request.
 * @param initiator the initiator JID
 * @param responder the responder JID
 * @param jingleMediaManagers the jingleMediaManager
 */
  public JingleSession(  XMPPConnection conn,  JingleSessionRequest request,  Jid initiator,  Jid responder,  List<JingleMediaManager> jingleMediaManagers){
    this(conn,initiator,responder,generateSessionId(),jingleMediaManagers);
  }
  /** 
 * Get the session initiator.
 * @return the initiator
 */
  public Jid getInitiator(){
    return initiator;
  }
  @Override public XMPPConnection getConnection(){
    return connection;
  }
  /** 
 * Set the session initiator.
 * @param initiator TODO javadoc me pleasethe initiator to set
 */
  public void setInitiator(  Jid initiator){
    this.initiator=initiator;
  }
  /** 
 * Get the Media Manager of this Jingle Session.
 * @return the JingleMediaManagers
 */
  public List<JingleMediaManager> getMediaManagers(){
    return jingleMediaManagers;
  }
  /** 
 * Set the Media Manager of this Jingle Session.
 * @param jingleMediaManagers TODO javadoc me please
 */
  public void setMediaManagers(  List<JingleMediaManager> jingleMediaManagers){
    this.jingleMediaManagers=jingleMediaManagers;
  }
  /** 
 * Get the session responder.
 * @return the responder
 */
  public Jid getResponder(){
    return responder;
  }
  /** 
 * Set the session responder.
 * @param responder TODO javadoc me pleasethe receptor to set
 */
  public void setResponder(  Jid responder){
    this.responder=responder;
  }
  /** 
 * Get the session ID.
 * @return the sid
 */
  public String getSid(){
    return sid;
  }
  /** 
 * Set the session ID
 * @param sessionId TODO javadoc me pleasethe sid to set
 */
  void setSid(  String sessionId){
    sid=sessionId;
  }
  /** 
 * Generate a unique session ID.
 * @return the generated session ID.
 */
  static String generateSessionId(){
    return String.valueOf(randomGenerator.nextInt(Integer.MAX_VALUE) + randomGenerator.nextInt(Integer.MAX_VALUE));
  }
  /** 
 * Validate the state changes.
 * @param stateIs the jingle session state.
 */
  public void setSessionState(  JingleSessionState stateIs){
    LOGGER.fine("Session state change: " + sessionState + "->"+ stateIs);
    stateIs.enter();
    sessionState=stateIs;
  }
  public JingleSessionState getSessionState(){
    return sessionState;
  }
  /** 
 * Return true if all of the media managers have finished.
 * @return <code>true</code> if fully established.
 */
  public boolean isFullyEstablished(){
    boolean result=true;
    for (    ContentNegotiator contentNegotiator : contentNegotiators) {
      if (!contentNegotiator.isFullyEstablished())       result=false;
    }
    return result;
  }
  /** 
 * Process and respond to an incoming packet. This method is called from the stanza listener dispatcher when a new stanza has arrived. The method is responsible for recognizing the stanza type and, depending on the current state, delivering it to the right event handler and wait for a response. The response will be another Jingle stanza that will be sent to the other end point.
 * @param iq TODO javadoc me pleasethe stanza received
 * @throws XMPPException if an XMPP protocol error was received.
 * @throws SmackException if Smack detected an exceptional situation.
 * @throws InterruptedException if the calling thread was interrupted.
 */
  public synchronized void receivePacketAndRespond(  IQ iq) throws XMPPException, SmackException, InterruptedException {
    List<IQ> responses=new ArrayList<>();
    String responseId;
    LOGGER.fine("Packet: " + iq.toXML());
    try {
      responses.addAll(dispatchIncomingPacket(iq,null));
      if (iq != null) {
        responseId=iq.getStanzaId();
        for (        ContentNegotiator contentNegotiator : contentNegotiators) {
          if (!contentNegotiator.isStarted()) {
            contentNegotiator.start();
          }
          responses.addAll(contentNegotiator.dispatchIncomingPacket(iq,responseId));
        }
      }
    }
 catch (    JingleException e) {
      JingleError error=e.getError();
      if (error != null) {
        responses.add(createJingleError(iq,error));
      }
      triggerSessionClosedOnError(e);
    }
    for (    IQ response : responses) {
      sendStanza(response);
    }
  }
  /** 
 * Dispatch an incoming packet. The method is responsible for recognizing the stanza type and, depending on the current state, delivering the stanza to the right event handler and wait for a response.
 * @param iq TODO javadoc me pleasethe stanza received
 * @return the new Jingle stanza to send.
 * @throws XMPPException if an XMPP protocol error was received.
 * @throws SmackException if Smack detected an exceptional situation.
 * @throws InterruptedException if the calling thread was interrupted.
 */
  @Override public List<IQ> dispatchIncomingPacket(  IQ iq,  String id) throws XMPPException, SmackException, InterruptedException {
    List<IQ> responses=new ArrayList<>();
    IQ response=null;
    if (iq != null) {
      if (iq.getType().equals(IQ.Type.error)) {
      }
 else       if (iq.getType().equals(IQ.Type.result)) {
        if (isExpectedId(iq.getStanzaId())) {
          if (iq.getStanzaId().equals(sessionInitPacketID)) {
            startNegotiators();
          }
          removeExpectedId(iq.getStanzaId());
        }
      }
 else       if (iq instanceof Jingle) {
        Jingle jin=(Jingle)iq;
        JingleActionEnum action=jin.getAction();
        response=getSessionState().processJingle(this,jin,action);
      }
    }
    if (response != null) {
      addExpectedId(response.getStanzaId());
      responses.add(response);
    }
    return responses;
  }
  /** 
 * Add a new content negotiator on behalf of a &lt;content/&gt; section received.
 * @param inContentNegotiator the content negotiator.
 */
  public void addContentNegotiator(  ContentNegotiator inContentNegotiator){
    contentNegotiators.add(inContentNegotiator);
  }
  public void sendStanza(  IQ iq) throws NotConnectedException, InterruptedException {
    if (iq instanceof Jingle) {
      sendFormattedJingle((Jingle)iq);
    }
 else {
      getConnection().sendStanza(iq);
    }
  }
  /** 
 * Complete and send a packet. Complete all the null fields in a Jingle reponse, using the session information we have.
 * @param jout the Jingle stanza we want to complete and send
 * @return the Jingle stanza.
 * @throws NotConnectedException if the XMPP connection is not connected.
 * @throws InterruptedException if the calling thread was interrupted.
 */
  public Jingle sendFormattedJingle(  Jingle jout) throws NotConnectedException, InterruptedException {
    return sendFormattedJingle(null,jout);
  }
  /** 
 * Complete and send a packet. Complete all the null fields in a Jingle reponse, using the session information we have or some info from the incoming packet.
 * @param iq The Jingle stanza we are responding to
 * @param jout the Jingle stanza we want to complete and send
 * @return the Jingle stanza.
 * @throws NotConnectedException if the XMPP connection is not connected.
 * @throws InterruptedException if the calling thread was interrupted.
 */
  public Jingle sendFormattedJingle(  IQ iq,  Jingle jout) throws NotConnectedException, InterruptedException {
    if (jout != null) {
      if (jout.getInitiator() == null) {
        jout.setInitiator(getInitiator());
      }
      if (jout.getResponder() == null) {
        jout.setResponder(getResponder());
      }
      if (jout.getSid() == null) {
        jout.setSid(getSid());
      }
      Jid me=getConnection().getUser();
      Jid other=getResponder().equals(me) ? getInitiator() : getResponder();
      if (jout.getTo() == null) {
        if (iq != null) {
          jout.setTo(iq.getFrom());
        }
 else {
          jout.setTo(other);
        }
      }
      if (jout.getFrom() == null) {
        if (iq != null) {
          jout.setFrom(iq.getTo());
        }
 else {
          jout.setFrom(me);
        }
      }
      if ((getConnection() != null) && getConnection().isConnected())       getConnection().sendStanza(jout);
    }
    return jout;
  }
  /** 
 * Acknowledge a IQ packet.
 * @param iq The IQ to acknowledge.
 * @return the ack IQ.
 */
  public IQ createAck(  IQ iq){
    IQ result=null;
    if (iq != null) {
      if (iq.getType().equals(IQ.Type.set)) {
        IQ ack=IQ.createResultIQ(iq);
        result=ack;
      }
    }
    return result;
  }
  /** 
 * Send a content info message.
 */
  @Override public int hashCode(){
    return Jingle.getSessionHash(getSid(),getInitiator());
  }
  @Override public boolean equals(  Object obj){
    if (this == obj) {
      return true;
    }
    if (obj == null) {
      return false;
    }
    if (getClass() != obj.getClass()) {
      return false;
    }
    final JingleSession other=(JingleSession)obj;
    if (initiator == null) {
      if (other.initiator != null) {
        return false;
      }
    }
 else     if (!initiator.equals(other.initiator)) {
    }
    if (responder == null) {
      if (other.responder != null) {
        return false;
      }
    }
 else     if (!responder.equals(other.responder)) {
      return false;
    }
    if (sid == null) {
      if (other.sid != null) {
        return false;
      }
    }
 else     if (!sid.equals(other.sid)) {
      return false;
    }
    return true;
  }
  /** 
 * Clean a session from the list.
 * @param connection TODO javadoc me pleaseThe connection to clean up
 */
  private static void unregisterInstanceFor(  XMPPConnection connection){
synchronized (sessions) {
      sessions.remove(connection);
    }
  }
  /** 
 * Register this instance.
 */
  private void registerInstance(){
synchronized (sessions) {
      sessions.put(getConnection(),this);
    }
  }
  /** 
 * Returns the JingleSession related to a particular connection.
 * @param con TODO javadoc me pleaseA XMPP connection
 * @return a Jingle session
 */
  public static synchronized JingleSession getInstanceFor(  XMPPConnection con){
    if (con == null) {
      throw new IllegalArgumentException("XMPPConnection cannot be null");
    }
    JingleSession result=null;
synchronized (sessions) {
      if (sessions.containsKey(con)) {
        result=sessions.get(con);
      }
    }
    return result;
  }
  /** 
 * Configure a session, setting some action listeners...
 * @param connection TODO javadoc me pleaseThe connection to set up
 */
  private void installConnectionListeners(  final XMPPConnection connection){
    if (connection != null) {
      connectionListener=new AbstractConnectionClosedListener(){
        @Override public void connectionTerminated(){
          unregisterInstanceFor(connection);
        }
      }
;
      connection.addConnectionListener(connectionListener);
    }
  }
  private void removeConnectionListener(){
    if (connectionListener != null) {
      getConnection().removeConnectionListener(connectionListener);
      LOGGER.fine("JINGLE SESSION: REMOVE CONNECTION LISTENER");
    }
  }
  /** 
 * Remove the stanza listener used for processing packet.
 */
  void removeAsyncPacketListener(){
    if (packetListener != null) {
      getConnection().removeAsyncStanzaListener(packetListener);
      LOGGER.fine("JINGLE SESSION: REMOVE PACKET LISTENER");
    }
  }
  /** 
 * Install the stanza listener. The listener is responsible for responding to any stanza that we receive...
 */
  void updatePacketListener(){
    removeAsyncPacketListener();
    LOGGER.fine("UpdatePacketListener");
    packetListener=new StanzaListener(){
      @Override public void processStanza(      Stanza packet){
        try {
          receivePacketAndRespond((IQ)packet);
        }
 catch (        Exception e) {
          LOGGER.log(Level.WARNING,"exception",e);
        }
      }
    }
;
    packetFilter=new StanzaFilter(){
      @Override public boolean accept(      Stanza packet){
        if (packet instanceof IQ) {
          IQ iq=(IQ)packet;
          Jid me=getConnection().getUser();
          if (!iq.getTo().equals(me)) {
            return false;
          }
          Jid other=getResponder().equals(me) ? getInitiator() : getResponder();
          if (iq.getFrom() == null || !iq.getFrom().equals(other == null ? "" : other)) {
            return false;
          }
          if (iq instanceof Jingle) {
            Jingle jin=(Jingle)iq;
            String sid=jin.getSid();
            if (sid == null || !sid.equals(getSid())) {
              LOGGER.fine("Ignored Jingle(SID) " + sid + "|"+ getSid()+ " :"+ iq.toXML());
              return false;
            }
            Jid ini=jin.getInitiator();
            if (!ini.equals(getInitiator())) {
              LOGGER.fine("Ignored Jingle(INI): " + iq.toXML());
              return false;
            }
          }
 else {
            if (iq.getType().equals(IQ.Type.set)) {
              LOGGER.fine("Ignored Jingle(TYPE): " + iq.toXML());
              return false;
            }
 else             if (iq.getType().equals(IQ.Type.get)) {
              LOGGER.fine("Ignored Jingle(TYPE): " + iq.toXML());
              return false;
            }
          }
          return true;
        }
        return false;
      }
    }
;
    getConnection().addAsyncStanzaListener(packetListener,packetFilter);
  }
  /** 
 * Add a listener for jmf negotiation events.
 * @param li TODO javadoc me pleaseThe listener
 */
  public void addMediaListener(  JingleMediaListener li){
    for (    ContentNegotiator contentNegotiator : contentNegotiators) {
      if (contentNegotiator.getMediaNegotiator() != null) {
        contentNegotiator.getMediaNegotiator().addListener(li);
      }
    }
  }
  /** 
 * Remove a listener for jmf negotiation events.
 * @param li TODO javadoc me pleaseThe listener
 */
  public void removeMediaListener(  JingleMediaListener li){
    for (    ContentNegotiator contentNegotiator : contentNegotiators) {
      if (contentNegotiator.getMediaNegotiator() != null) {
        contentNegotiator.getMediaNegotiator().removeListener(li);
      }
    }
  }
  /** 
 * Add a listener for transport negotiation events.
 * @param li TODO javadoc me pleaseThe listener
 */
  public void addTransportListener(  JingleTransportListener li){
    for (    ContentNegotiator contentNegotiator : contentNegotiators) {
      if (contentNegotiator.getTransportNegotiator() != null) {
        contentNegotiator.getTransportNegotiator().addListener(li);
      }
    }
  }
  /** 
 * Remove a listener for transport negotiation events.
 * @param li TODO javadoc me pleaseThe listener
 */
  public void removeTransportListener(  JingleTransportListener li){
    for (    ContentNegotiator contentNegotiator : contentNegotiators) {
      if (contentNegotiator.getTransportNegotiator() != null) {
        contentNegotiator.getTransportNegotiator().removeListener(li);
      }
    }
  }
  /** 
 * Setup the listeners that act on events coming from the lower level negotiators.
 */
  public void setupListeners(){
    JingleMediaListener jingleMediaListener=new JingleMediaListener(){
      @Override public void mediaClosed(      PayloadType cand){
      }
      @Override public void mediaEstablished(      PayloadType pt) throws NotConnectedException, InterruptedException {
        if (isFullyEstablished()) {
          Jingle jout=new Jingle(JingleActionEnum.SESSION_ACCEPT);
          for (          ContentNegotiator contentNegotiator : contentNegotiators) {
            if (contentNegotiator.getNegotiatorState() == JingleNegotiatorState.SUCCEEDED)             jout.addContent(contentNegotiator.getJingleContent());
          }
          addExpectedId(jout.getStanzaId());
          sendStanza(jout);
        }
      }
    }
;
    JingleTransportListener jingleTransportListener=new JingleTransportListener(){
      @Override public void transportEstablished(      TransportCandidate local,      TransportCandidate remote) throws NotConnectedException, InterruptedException, NoResponseException, XMPPErrorException {
        if (isFullyEstablished()) {
          setSessionState(JingleSessionStateActive.getInstance());
          for (          ContentNegotiator contentNegotiator : contentNegotiators) {
            if (contentNegotiator.getNegotiatorState() == JingleNegotiatorState.SUCCEEDED)             contentNegotiator.triggerContentEstablished();
          }
          if (getSessionState().equals(JingleSessionStatePending.getInstance())) {
            Jingle jout=new Jingle(JingleActionEnum.SESSION_ACCEPT);
            for (            ContentNegotiator contentNegotiator : contentNegotiators) {
              if (contentNegotiator.getNegotiatorState() == JingleNegotiatorState.SUCCEEDED)               jout.addContent(contentNegotiator.getJingleContent());
            }
            addExpectedId(jout.getStanzaId());
            sendStanza(jout);
          }
        }
      }
      @Override public void transportClosed(      TransportCandidate cand){
      }
      @Override public void transportClosedOnError(      XMPPException e){
      }
    }
;
    addMediaListener(jingleMediaListener);
    addTransportListener(jingleTransportListener);
  }
  /** 
 * Trigger a session closed event.
 * @param reason the reason.
 */
  void triggerSessionClosed(  String reason){
    List<JingleListener> listeners=getListenersList();
    for (    JingleListener li : listeners) {
      if (li instanceof JingleSessionListener) {
        JingleSessionListener sli=(JingleSessionListener)li;
        sli.sessionClosed(reason,this);
      }
    }
    close();
  }
  /** 
 * Trigger a session closed event due to an error.
 * @param exc the exception.
 */
  void triggerSessionClosedOnError(  XMPPException exc){
    for (    ContentNegotiator contentNegotiator : contentNegotiators) {
      contentNegotiator.stopJingleMediaSession();
      for (      TransportCandidate candidate : contentNegotiator.getTransportNegotiator().getOfferedCandidates())       candidate.removeCandidateEcho();
    }
    List<JingleListener> listeners=getListenersList();
    for (    JingleListener li : listeners) {
      if (li instanceof JingleSessionListener) {
        JingleSessionListener sli=(JingleSessionListener)li;
        sli.sessionClosedOnError(exc,this);
      }
    }
    close();
  }
  /** 
 * Trigger a media received event.
 * @param participant the participant.
 */
  void triggerMediaReceived(  String participant){
    List<JingleListener> listeners=getListenersList();
    for (    JingleListener li : listeners) {
      if (li instanceof JingleSessionListener) {
        JingleSessionListener sli=(JingleSessionListener)li;
        sli.sessionMediaReceived(this,participant);
      }
    }
  }
  /** 
 * Terminates the session with default reason.
 * @throws XMPPException if an XMPP protocol error was received.
 * @throws NotConnectedException if the XMPP connection is not connected.
 * @throws InterruptedException if the calling thread was interrupted.
 */
  public void terminate() throws XMPPException, NotConnectedException, InterruptedException {
    terminate("Closed Locally");
  }
  /** 
 * Terminates the session with a custom reason.
 * @param reason the reason.
 * @throws XMPPException if an XMPP protocol error was received.
 * @throws NotConnectedException if the XMPP connection is not connected.
 * @throws InterruptedException if the calling thread was interrupted.
 */
  public void terminate(  String reason) throws XMPPException, NotConnectedException, InterruptedException {
    if (isClosed())     return;
    LOGGER.fine("Terminate " + reason);
    Jingle jout=new Jingle(JingleActionEnum.SESSION_TERMINATE);
    jout.setType(IQ.Type.set);
    sendStanza(jout);
    triggerSessionClosed(reason);
  }
  /** 
 * Terminate negotiations.
 */
  @Override public void close(){
    if (isClosed())     return;
    setSessionState(JingleSessionStateEnded.getInstance());
    for (    ContentNegotiator contentNegotiator : contentNegotiators) {
      contentNegotiator.stopJingleMediaSession();
      for (      TransportCandidate candidate : contentNegotiator.getTransportNegotiator().getOfferedCandidates())       candidate.removeCandidateEcho();
      contentNegotiator.close();
    }
    removeAsyncPacketListener();
    removeConnectionListener();
    getConnection().removeConnectionListener(connectionListener);
    LOGGER.fine("Negotiation Closed: " + getConnection().getUser() + " "+ sid);
    super.close();
  }
  public boolean isClosed(){
    return getSessionState().equals(JingleSessionStateEnded.getInstance());
  }
  /** 
 * Complete and send an error. Complete all the null fields in an IQ error response, using the session information we have or some info from the incoming packet.
 * @param iq The Jingle stanza we are responding to
 * @param jingleError the IQ stanza we want to complete and send
 * @return the jingle error IQ.
 */
  public IQ createJingleError(  IQ iq,  JingleError jingleError){
    IQ errorPacket=null;
    if (jingleError != null) {
      StanzaError builder=StanzaError.getBuilder().setCondition(StanzaError.Condition.undefined_condition).addExtension(jingleError).build();
      errorPacket=IQ.createErrorResponse(iq,builder);
      LOGGER.severe("Error sent: " + errorPacket.toXML());
    }
    return errorPacket;
  }
  /** 
 * Called when new Media is received.
 */
  @Override public void mediaReceived(  String participant){
    triggerMediaReceived(participant);
  }
  /** 
 * This is the starting point for intitiating a new session.
 * @throws IllegalStateException if an illegal state was encountered
 * @throws SmackException if Smack detected an exceptional situation.
 * @throws InterruptedException if the calling thread was interrupted.
 */
  public void startOutgoing() throws IllegalStateException, SmackException, InterruptedException {
    updatePacketListener();
    setSessionState(JingleSessionStatePending.getInstance());
    Jingle jingle=new Jingle(JingleActionEnum.SESSION_INITIATE);
    for (    JingleMediaManager mediaManager : getMediaManagers()) {
      ContentNegotiator contentNeg=new ContentNegotiator(this,ContentNegotiator.INITIATOR,mediaManager.getName());
      contentNeg.setMediaNegotiator(new MediaNegotiator(this,mediaManager,mediaManager.getPayloads(),contentNeg));
      JingleTransportManager transportManager=mediaManager.getTransportManager();
      TransportResolver resolver=null;
      try {
        resolver=transportManager.getResolver(this);
      }
 catch (      XMPPException e) {
        LOGGER.log(Level.WARNING,"exception",e);
      }
      if (resolver.getType().equals(TransportResolver.Type.rawupd)) {
        contentNeg.setTransportNegotiator(new TransportNegotiator.RawUdp(this,resolver,contentNeg));
      }
      if (resolver.getType().equals(TransportResolver.Type.ice)) {
        contentNeg.setTransportNegotiator(new TransportNegotiator.Ice(this,resolver,contentNeg));
      }
      addContentNegotiator(contentNeg);
    }
    for (    ContentNegotiator contentNegotiator : contentNegotiators) {
      jingle.addContent(contentNegotiator.getJingleContent());
    }
    sessionInitPacketID=jingle.getStanzaId();
    sendStanza(jingle);
    setupListeners();
  }
  /** 
 * This is the starting point for responding to a new session.
 */
  public void startIncoming(){
  }
  @Override protected void doStart(){
  }
  /** 
 * When we initiate a session we need to start a bunch of negotiators right after we receive the result stanza for our session-initiate.  This is where we start them.
 */
  private void startNegotiators(){
    for (    ContentNegotiator contentNegotiator : contentNegotiators) {
      TransportNegotiator transNeg=contentNegotiator.getTransportNegotiator();
      transNeg.start();
    }
  }
  /** 
 * The jingle session may have one or more media managers that are trying to establish media sessions. When the media manager succeeds in creating a media session is registers it with the session by the media manager's static name.  This routine is where the media manager does the registering.
 * @param mediaManagerName the name of the media manager.
 * @param mediaSession the jingle media session.
 */
  public void addJingleMediaSession(  String mediaManagerName,  JingleMediaSession mediaSession){
    mediaSessionMap.put(mediaManagerName,mediaSession);
  }
  /** 
 * The jingle session may have one or more media managers that are trying to establish media sessions. When the media manager succeeds in creating a media session is registers it with the session by the media manager's static name. This routine is where other objects can access the registered media sessions. NB: If the media manager has not succeeded in establishing a media session then this could return null.
 * @param mediaManagerName the name of the media manager.
 * @return the jingle media session.
 */
  public JingleMediaSession getMediaSession(  String mediaManagerName){
    return mediaSessionMap.get(mediaManagerName);
  }
}
