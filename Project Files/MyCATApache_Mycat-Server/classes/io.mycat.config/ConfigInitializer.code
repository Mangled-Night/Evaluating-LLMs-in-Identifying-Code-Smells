/** 
 * @author mycat
 */
public class ConfigInitializer {
  private static final Logger LOGGER=Logger.getLogger(ConfigInitializer.class);
  private volatile SystemConfig system;
  private volatile MycatCluster cluster;
  private volatile FirewallConfig firewall;
  private volatile Map<String,UserConfig> users;
  private volatile Map<String,SchemaConfig> schemas;
  private volatile Map<String,PhysicalDBNode> dataNodes;
  private volatile Map<String,PhysicalDBPool> dataHosts;
  public ConfigInitializer(  boolean loadDataHost){
    SchemaLoader schemaLoader=new XMLSchemaLoader();
    XMLConfigLoader configLoader=new XMLConfigLoader(schemaLoader);
    schemaLoader=null;
    this.system=configLoader.getSystemConfig();
    this.users=configLoader.getUserConfigs();
    this.schemas=configLoader.getSchemaConfigs();
    if (loadDataHost) {
      this.dataHosts=initDataHosts(configLoader);
      this.dataNodes=initDataNodes(configLoader);
    }
    this.firewall=configLoader.getFirewallConfig();
    this.cluster=initCobarCluster(configLoader);
    if (system.getSequenceHandlerType() == SystemConfig.SEQUENCEHANDLER_MYSQLDB) {
      IncrSequenceMySQLHandler.getInstance().load();
    }
    if (system.getSequenceHandlerType() == SystemConfig.SEQUENCEHANDLER_LOCAL_TIME) {
      IncrSequenceTimeHandler.getInstance().load();
    }
    if (system.getSequenceHandlerType() == SystemConfig.SEQUENCEHANDLER_ZK_DISTRIBUTED) {
      DistributedSequenceHandler.getInstance(system).load();
    }
    if (system.getSequenceHandlerType() == SystemConfig.SEQUENCEHANDLER_ZK_GLOBAL_INCREMENT) {
      IncrSequenceZKHandler.getInstance().load();
    }
    this.selfChecking0();
  }
  private void selfChecking0() throws ConfigException {
    if (users == null || users.isEmpty()) {
      throw new ConfigException("SelfCheck### user all node is empty!");
    }
 else {
      for (      UserConfig uc : users.values()) {
        if (uc == null) {
          throw new ConfigException("SelfCheck### users node within the item is empty!");
        }
        Set<String> authSchemas=uc.getSchemas();
        if (authSchemas == null) {
          throw new ConfigException("SelfCheck### user " + uc.getName() + "refered schemas is empty!");
        }
        for (        String schema : authSchemas) {
          if (!schemas.containsKey(schema)) {
            String errMsg="SelfCheck###  schema " + schema + " refered by user "+ uc.getName()+ " is not exist!";
            throw new ConfigException(errMsg);
          }
        }
      }
    }
    for (    SchemaConfig sc : schemas.values()) {
      if (null == sc) {
        throw new ConfigException("SelfCheck### schema all node is empty!");
      }
 else {
        if (this.dataNodes != null && this.dataHosts != null) {
          Set<String> dataNodeNames=sc.getAllDataNodes();
          for (          String dataNodeName : dataNodeNames) {
            PhysicalDBNode node=this.dataNodes.get(dataNodeName);
            if (node == null) {
              throw new ConfigException("SelfCheck### schema dbnode is empty!");
            }
          }
        }
      }
    }
  }
  public void testConnection(){
    if (this.dataNodes != null && this.dataHosts != null) {
      Map<String,Boolean> map=new HashMap<String,Boolean>();
      for (      PhysicalDBNode dataNode : dataNodes.values()) {
        String database=dataNode.getDatabase();
        PhysicalDBPool pool=dataNode.getDbPool();
        for (        PhysicalDatasource ds : pool.getAllDataSources()) {
          String key=ds.getName() + "_" + database;
          if (map.get(key) == null) {
            map.put(key,false);
            boolean isConnected=false;
            try {
              isConnected=ds.testConnection(database);
              map.put(key,isConnected);
            }
 catch (            IOException e) {
              LOGGER.warn("test conn error:",e);
            }
          }
        }
      }
      boolean isConnectivity=true;
      for (      Map.Entry<String,Boolean> entry : map.entrySet()) {
        String key=entry.getKey();
        Boolean value=entry.getValue();
        if (!value && isConnectivity) {
          LOGGER.warn("SelfCheck### test " + key + " database connection failed ");
          isConnectivity=false;
        }
 else {
          LOGGER.info("SelfCheck### test " + key + " database connection success ");
        }
      }
      if (!isConnectivity) {
        throw new ConfigException("SelfCheck### there are some datasource connection failed, pls check!");
      }
    }
  }
  public SystemConfig getSystem(){
    return system;
  }
  public MycatCluster getCluster(){
    return cluster;
  }
  public FirewallConfig getFirewall(){
    return firewall;
  }
  public Map<String,UserConfig> getUsers(){
    return users;
  }
  public Map<String,SchemaConfig> getSchemas(){
    return schemas;
  }
  public Map<String,PhysicalDBNode> getDataNodes(){
    return dataNodes;
  }
  public Map<String,PhysicalDBPool> getDataHosts(){
    return this.dataHosts;
  }
  private MycatCluster initCobarCluster(  ConfigLoader configLoader){
    return new MycatCluster(configLoader.getClusterConfig());
  }
  private Map<String,PhysicalDBPool> initDataHosts(  ConfigLoader configLoader){
    Map<String,DataHostConfig> nodeConfs=configLoader.getDataHosts();
    boolean isBooster="booster".equalsIgnoreCase(ZkConfig.getInstance().getValue(ZkParamCfg.MYCAT_SERVER_TYPE));
    Map<String,PhysicalDBPool> nodes=new HashMap<String,PhysicalDBPool>(nodeConfs.size());
    for (    DataHostConfig conf : nodeConfs.values()) {
      if (isBooster) {
        conf.setMinCon(2);
      }
      PhysicalDBPool pool=getPhysicalDBPool(conf,configLoader);
      nodes.put(pool.getHostName(),pool);
    }
    return nodes;
  }
  private PhysicalDatasource[] createDataSource(  DataHostConfig conf,  String hostName,  String dbType,  String dbDriver,  DBHostConfig[] nodes,  boolean isRead){
    PhysicalDatasource[] dataSources=new PhysicalDatasource[nodes.length];
    if (dbType.equals("mysql") && dbDriver.equals("native")) {
      for (int i=0; i < nodes.length; i++) {
        nodes[i].setIdleTimeout(system.getIdleTimeout());
        MySQLDataSource ds=new MySQLDataSource(nodes[i],conf,isRead);
        dataSources[i]=ds;
      }
    }
 else     if (dbDriver.equals("jdbc")) {
      for (int i=0; i < nodes.length; i++) {
        nodes[i].setIdleTimeout(system.getIdleTimeout());
        JDBCDatasource ds=new JDBCDatasource(nodes[i],conf,isRead);
        dataSources[i]=ds;
      }
    }
 else     if ("postgresql".equalsIgnoreCase(dbType) && dbDriver.equalsIgnoreCase("native")) {
      for (int i=0; i < nodes.length; i++) {
        nodes[i].setIdleTimeout(system.getIdleTimeout());
        PostgreSQLDataSource ds=new PostgreSQLDataSource(nodes[i],conf,isRead);
        dataSources[i]=ds;
      }
    }
 else {
      throw new ConfigException("not supported yet !" + hostName);
    }
    return dataSources;
  }
  private PhysicalDBPool getPhysicalDBPool(  DataHostConfig conf,  ConfigLoader configLoader){
    String name=conf.getName();
    String dbType=conf.getDbType();
    String dbDriver=conf.getDbDriver();
    PhysicalDatasource[] writeSources=createDataSource(conf,name,dbType,dbDriver,conf.getWriteHosts(),false);
    Map<Integer,DBHostConfig[]> readHostsMap=conf.getReadHosts();
    Map<Integer,PhysicalDatasource[]> readSourcesMap=new HashMap<Integer,PhysicalDatasource[]>(readHostsMap.size());
    for (    Map.Entry<Integer,DBHostConfig[]> entry : readHostsMap.entrySet()) {
      PhysicalDatasource[] readSources=createDataSource(conf,name,dbType,dbDriver,entry.getValue(),true);
      readSourcesMap.put(entry.getKey(),readSources);
    }
    PhysicalDBPool pool=new PhysicalDBPool(conf.getName(),conf,writeSources,readSourcesMap,conf.getBalance(),conf.getWriteType());
    pool.setSlaveIDs(conf.getSlaveIDs());
    return pool;
  }
  private Map<String,PhysicalDBNode> initDataNodes(  ConfigLoader configLoader){
    Map<String,DataNodeConfig> nodeConfs=configLoader.getDataNodes();
    Map<String,PhysicalDBNode> nodes=new HashMap<String,PhysicalDBNode>(nodeConfs.size());
    for (    DataNodeConfig conf : nodeConfs.values()) {
      PhysicalDBPool pool=this.dataHosts.get(conf.getDataHost());
      if (pool == null) {
        throw new ConfigException("dataHost not exists " + conf.getDataHost());
      }
      PhysicalDBNode dataNode=new PhysicalDBNode(conf.getName(),conf.getDatabase(),pool);
      nodes.put(dataNode.getName(),dataNode);
    }
    return nodes;
  }
}
