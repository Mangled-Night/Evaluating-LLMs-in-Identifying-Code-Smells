public SubtypeLayoutBuilder(TypeInfo<T> baseType,TypeWidgetLibrary library,ModuleManager moduleManager,TypeRegistry typeRegistry){
  this.library=library;
  this.baseType=baseType;
  this.moduleManager=moduleManager;
  baseTypeWidgetBuilder=library.getBuilder(baseType).orElse(null);
  Module contextModule=ModuleContext.getContext();
  PermissionProvider permissionProvider=moduleManager.getPermissionProvider(contextModule);
  ModuleEnvironment environment=moduleManager.getEnvironment();
  Set<Name> allowedProvidingModules=ImmutableSet.<Name>builder().add(contextModule.getId()).addAll(environment.getDependencyNamesOf(contextModule.getId())).build();
  List<Class<? extends T>> allowedSubclasses=typeRegistry.getSubtypesOf(baseType.getRawType()).stream().filter(clazz -> allowedProvidingModules.contains(getModuleProviding(clazz)) || permissionProvider.isPermitted(clazz)).filter(clazz -> {
    int modifiers=clazz.getModifiers();
    return Modifier.isPublic(modifiers) && !Modifier.isAbstract(modifiers) && !clazz.isInterface();
  }
).filter(clazz -> {
    if (clazz.isLocalClass()) {
      return false;
    }
    return !clazz.isMemberClass() || Modifier.isStatic(clazz.getModifiers());
  }
).collect(Collectors.toList());
  allowedSubclasses.add(baseType.getRawType());
  for (int i=0; i < allowedSubclasses.size() - 1; i++) {
    Class<? extends T> a=allowedSubclasses.get(i);
    for (int j=i + 1; j < allowedSubclasses.size(); j++) {
      Class<? extends T> b=allowedSubclasses.get(j);
      if (!a.isAssignableFrom(b)) {
        continue;
      }
      allowedSubclasses.set(i,b);
      allowedSubclasses.set(j,a);
    }
  }
  allowedSubtypes=allowedSubclasses.stream().map(clazz -> {
    Type parameterized=ReflectionUtil.parameterizeandResolveRawType(baseType.getType(),clazz);
    return (TypeInfo<T>)TypeInfo.of(parameterized);
  }
).collect(Collectors.toList());
}
