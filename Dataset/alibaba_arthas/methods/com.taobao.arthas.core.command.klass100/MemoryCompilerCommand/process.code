@Override public void process(final CommandProcess process){
  RowAffect affect=new RowAffect();
  try {
    Instrumentation inst=process.session().getInstrumentation();
    if (hashCode == null && classLoaderClass != null) {
      List<ClassLoader> matchedClassLoaders=ClassLoaderUtils.getClassLoaderByClassName(inst,classLoaderClass);
      if (matchedClassLoaders.size() == 1) {
        hashCode=Integer.toHexString(matchedClassLoaders.get(0).hashCode());
      }
 else       if (matchedClassLoaders.size() > 1) {
        Collection<ClassLoaderVO> classLoaderVOList=ClassUtils.createClassLoaderVOList(matchedClassLoaders);
        MemoryCompilerModel memoryCompilerModel=new MemoryCompilerModel().setClassLoaderClass(classLoaderClass).setMatchedClassLoaders(classLoaderVOList);
        process.appendResult(memoryCompilerModel);
        process.end(-1,"Found more than one classloader by class name, please specify classloader with '-c <classloader hash>'");
        return;
      }
 else {
        process.end(-1,"Can not find classloader by class name: " + classLoaderClass + ".");
        return;
      }
    }
    ClassLoader classloader=null;
    if (hashCode == null) {
      classloader=ClassLoader.getSystemClassLoader();
    }
 else {
      classloader=ClassLoaderUtils.getClassLoader(inst,hashCode);
      if (classloader == null) {
        process.end(-1,"Can not find classloader with hashCode: " + hashCode + ".");
        return;
      }
    }
    DynamicCompiler dynamicCompiler=new DynamicCompiler(classloader);
    Charset charset=Charset.defaultCharset();
    if (encoding != null) {
      charset=Charset.forName(encoding);
    }
    for (    String sourceFile : sourcefiles) {
      String sourceCode=FileUtils.readFileToString(new File(sourceFile),charset);
      String name=new File(sourceFile).getName();
      if (name.endsWith(".java")) {
        name=name.substring(0,name.length() - ".java".length());
      }
      dynamicCompiler.addSource(name,sourceCode);
    }
    Map<String,byte[]> byteCodes=dynamicCompiler.buildByteCodes();
    File outputDir=null;
    if (this.directory != null) {
      outputDir=new File(this.directory);
    }
 else {
      outputDir=new File("").getAbsoluteFile();
    }
    List<String> files=new ArrayList<String>();
    for (    Entry<String,byte[]> entry : byteCodes.entrySet()) {
      File byteCodeFile=new File(outputDir,entry.getKey().replace('.','/') + ".class");
      FileUtils.writeByteArrayToFile(byteCodeFile,entry.getValue());
      files.add(byteCodeFile.getAbsolutePath());
      affect.rCnt(1);
    }
    process.appendResult(new MemoryCompilerModel(files));
    process.appendResult(new RowAffectModel(affect));
    process.end();
  }
 catch (  Throwable e) {
    logger.warn("Memory compiler error",e);
    process.end(-1,"Memory compiler error, exception message: " + e.getMessage() + ", please check $HOME/logs/arthas/arthas.log for more details.");
  }
}
