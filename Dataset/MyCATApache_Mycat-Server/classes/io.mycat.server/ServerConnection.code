/** 
 * @author mycat
 */
public class ServerConnection extends FrontendConnection {
  private static final Logger LOGGER=LoggerFactory.getLogger(ServerConnection.class);
  private long authTimeout=SystemConfig.DEFAULT_AUTH_TIMEOUT;
  /** 
 * 保存SET SQL_SELECT_LIMIT的值, default 解析为-1. 
 */
  private volatile int sqlSelectLimit=-1;
  private volatile boolean txReadonly;
  private volatile int txIsolation;
  private volatile boolean autocommit;
  private volatile boolean preAcStates;
  private volatile boolean txInterrupted;
  private volatile String txInterrputMsg="";
  private long lastInsertId;
  private NonBlockingSession session;
  /** 
 * 标志是否执行了lock tables语句，并处于lock状态
 */
  private volatile boolean isLocked=false;
  private Queue<SqlEntry> executeSqlQueue;
  private SqlExecuteStageListener listener;
  public ServerConnection(  NetworkChannel channel) throws IOException {
    super(channel);
    this.txInterrupted=false;
    this.autocommit=true;
    this.preAcStates=true;
    this.txReadonly=false;
    this.executeSqlQueue=new LinkedBlockingQueue<>();
    this.listener=new DefaultSqlExecuteStageListener(this);
  }
  @Override public boolean isIdleTimeout(){
    if (isAuthenticated) {
      return super.isIdleTimeout();
    }
 else {
      return TimeUtil.currentTimeMillis() > Math.max(lastWriteTime,lastReadTime) + this.authTimeout;
    }
  }
  public long getAuthTimeout(){
    return authTimeout;
  }
  public void setAuthTimeout(  long authTimeout){
    this.authTimeout=authTimeout;
  }
  public int getTxIsolation(){
    return txIsolation;
  }
  public void setTxIsolation(  int txIsolation){
    this.txIsolation=txIsolation;
  }
  public boolean isAutocommit(){
    return autocommit;
  }
  public void setAutocommit(  boolean autocommit){
    this.autocommit=autocommit;
  }
  public boolean isTxReadonly(){
    return txReadonly;
  }
  public void setTxReadonly(  boolean txReadonly){
    this.txReadonly=txReadonly;
  }
  public int getSqlSelectLimit(){
    return sqlSelectLimit;
  }
  public void setSqlSelectLimit(  int sqlSelectLimit){
    this.sqlSelectLimit=sqlSelectLimit;
  }
  public long getLastInsertId(){
    return lastInsertId;
  }
  public void setLastInsertId(  long lastInsertId){
    this.lastInsertId=lastInsertId;
  }
  /** 
 * 设置是否需要中断当前事务
 */
  public void setTxInterrupt(  String txInterrputMsg){
    if (!autocommit && !txInterrupted) {
      txInterrupted=true;
      this.txInterrputMsg=txInterrputMsg;
    }
  }
  /** 
 * 清空食事务中断
 */
  public void clearTxInterrupt(){
    if (!autocommit && txInterrupted) {
      txInterrupted=false;
      this.txInterrputMsg="";
    }
  }
  public boolean isTxInterrupted(){
    return txInterrupted;
  }
  public NonBlockingSession getSession2(){
    return session;
  }
  public void setSession2(  NonBlockingSession session2){
    this.session=session2;
  }
  public boolean isLocked(){
    return isLocked;
  }
  public void setLocked(  boolean isLocked){
    this.isLocked=isLocked;
  }
  @Override public void ping(){
    Ping.response(this);
  }
  @Override public void heartbeat(  byte[] data){
    Heartbeat.response(this,data);
  }
  public void execute(  String sql,  int type){
    if (this.isClosed()) {
      LOGGER.warn("ignore execute ,server connection is closed " + this);
      return;
    }
    if (txInterrupted) {
      writeErrMessage(ErrorCode.ER_YES,"Transaction error, need to rollback." + txInterrputMsg);
      return;
    }
    String db=this.schema;
    boolean isDefault=true;
    if (db == null) {
      db=SchemaUtil.detectDefaultDb(sql,type);
      if (db == null) {
        db=MycatServer.getInstance().getConfig().getUsers().get(user).getDefaultSchema();
        if (db == null) {
          writeErrMessage(ErrorCode.ERR_BAD_LOGICDB,"No MyCAT Database selected");
          return;
        }
      }
      isDefault=false;
    }
    if (ServerParse.SELECT == type && sql.contains("mysql") && sql.contains("proc")) {
      SchemaUtil.SchemaInfo schemaInfo=SchemaUtil.parseSchema(sql);
      if (schemaInfo != null && "mysql".equalsIgnoreCase(schemaInfo.schema) && "proc".equalsIgnoreCase(schemaInfo.table)) {
        MysqlProcHandler.handle(sql,this);
        return;
      }
    }
    SchemaConfig schema=MycatServer.getInstance().getConfig().getSchemas().get(db);
    if (schema == null) {
      writeErrMessage(ErrorCode.ERR_BAD_LOGICDB,"Unknown MyCAT Database '" + db + "'");
      return;
    }
    if (ServerParse.SELECT == type && sql.contains(" INFORMATION_SCHEMA.PROFILING ") && sql.contains("CONCAT(ROUND(SUM(DURATION)/")) {
      InformationSchemaProfiling.response(this);
      return;
    }
    if (ServerParse.SELECT == type && sql.contains(" information_schema.profiling ") && sql.contains("duration (summed) in sec")) {
      InformationSchemaProfilingSqlyog.response(this);
      return;
    }
    if (isDefault && schema.isCheckSQLSchema() && isNormalSql(type)) {
      SchemaUtil.SchemaInfo schemaInfo=SchemaUtil.parseSchema(sql);
      if (schemaInfo != null && schemaInfo.schema != null && !schemaInfo.schema.equals(db)) {
        SchemaConfig schemaConfig=MycatServer.getInstance().getConfig().getSchemas().get(schemaInfo.schema);
        if (schemaConfig != null)         schema=schemaConfig;
      }
    }
    routeEndExecuteSQL(sql,type,schema);
  }
  private boolean isNormalSql(  int type){
    return ServerParse.SELECT == type || ServerParse.INSERT == type || ServerParse.UPDATE == type || ServerParse.DELETE == type || ServerParse.DDL == type;
  }
  public RouteResultset routeSQL(  String sql,  int type){
    String db=this.schema;
    if (db == null) {
      db=SchemaUtil.detectDefaultDb(sql,type);
      if (db == null) {
        db=MycatServer.getInstance().getConfig().getUsers().get(user).getDefaultSchema();
        if (db == null) {
          writeErrMessage(ErrorCode.ERR_BAD_LOGICDB,"No MyCAT Database selected");
          return null;
        }
      }
    }
    SchemaConfig schema=MycatServer.getInstance().getConfig().getSchemas().get(db);
    if (schema == null) {
      writeErrMessage(ErrorCode.ERR_BAD_LOGICDB,"Unknown MyCAT Database '" + db + "'");
      return null;
    }
    RouteResultset rrs=null;
    try {
      rrs=MycatServer.getInstance().getRouterservice().route(MycatServer.getInstance().getConfig().getSystem(),schema,type,sql,this.charset,this);
    }
 catch (    Exception e) {
      StringBuilder s=new StringBuilder();
      LOGGER.warn(s.append(this).append(sql).toString() + " err:" + e.toString(),e);
      String msg=e.getMessage();
      writeErrMessage(ErrorCode.ER_PARSE_ERROR,msg == null ? e.getClass().getSimpleName() : msg);
      return null;
    }
    return rrs;
  }
  public void routeEndExecuteSQL(  String sql,  final int type,  final SchemaConfig schema){
    RouteResultset rrs=null;
    try {
      rrs=MycatServer.getInstance().getRouterservice().route(MycatServer.getInstance().getConfig().getSystem(),schema,type,sql,this.charset,this);
    }
 catch (    Exception e) {
      StringBuilder s=new StringBuilder();
      LOGGER.warn(s.append(this).append(sql).toString() + " err:" + e.toString(),e);
      String msg=e.getMessage();
      writeErrMessage(ErrorCode.ER_PARSE_ERROR,msg == null ? e.getClass().getSimpleName() : msg);
      return;
    }
    if (rrs != null) {
      boolean executeNow=false;
synchronized (this.executeSqlQueue) {
        executeNow=this.executeSqlQueue.isEmpty();
        this.executeSqlQueue.add(new SqlEntry(sql,type,rrs));
        if (LOGGER.isDebugEnabled()) {
          LOGGER.debug("add queue,executeSqlQueue size {}",executeSqlQueue.size());
        }
      }
      if (executeNow) {
        this.executeSqlId++;
        session.execute(rrs,rrs.isSelectForUpdate() ? ServerParse.UPDATE : type);
      }
    }
  }
  /** 
 * 提交事务
 */
  public void commit(){
    if (txInterrupted) {
      LOGGER.warn("receive commit ,but found err message in Transaction {}",this);
      this.rollback();
    }
 else {
      session.commit();
    }
  }
  /** 
 * 回滚事务
 */
  public void rollback(){
    if (txInterrupted) {
      txInterrupted=false;
    }
    session.rollback();
  }
  /** 
 * 执行lock tables语句方法
 * @param sql
 */
  public void lockTable(  String sql){
    if (!autocommit) {
      writeErrMessage(ErrorCode.ER_YES,"can't lock table in transaction!");
      return;
    }
    if (isLocked) {
      writeErrMessage(ErrorCode.ER_YES,"can't lock multi-table");
      return;
    }
    RouteResultset rrs=routeSQL(sql,ServerParse.LOCK);
    if (rrs != null) {
      session.lockTable(rrs);
    }
  }
  /** 
 * 执行unlock tables语句方法
 * @param sql
 */
  public void unLockTable(  String sql){
    sql=sql.replaceAll("\n"," ").replaceAll("\t"," ");
    String[] words=SplitUtil.split(sql,' ',true);
    if (words.length == 2 && ("table".equalsIgnoreCase(words[1]) || "tables".equalsIgnoreCase(words[1]))) {
      isLocked=false;
      session.unLockTable(sql);
    }
 else {
      writeErrMessage(ErrorCode.ER_UNKNOWN_COM_ERROR,"Unknown command");
    }
  }
  /** 
 * 撤销执行中的语句
 * @param sponsor 发起者为null表示是自己
 */
  public void cancel(  final FrontendConnection sponsor){
    processor.getExecutor().execute(new Runnable(){
      @Override public void run(){
        session.cancel(sponsor);
      }
    }
);
  }
  @Override public void close(  String reason){
    super.close(reason);
    session.terminate();
    if (getLoadDataInfileHandler() != null) {
      getLoadDataInfileHandler().clear();
    }
  }
  /** 
 * add huangyiming 检测字符串中某字符串出现次数
 * @param srcText
 * @param findText
 * @return
 */
  public static int appearNumber(  String srcText,  String findText){
    int count=0;
    Pattern p=Pattern.compile(findText);
    Matcher m=p.matcher(srcText);
    while (m.find()) {
      count++;
    }
    return count;
  }
  @Override public String toString(){
    return "ServerConnection [id=" + id + ", schema="+ schema+ ", host="+ host+ ", user="+ user+ ",txIsolation="+ txIsolation+ ", autocommit="+ autocommit+ ", schema="+ schema+ ", executeSql="+ executeSql+ "]"+ this.getSession2();
  }
  public boolean isPreAcStates(){
    return preAcStates;
  }
  public void setPreAcStates(  boolean preAcStates){
    this.preAcStates=preAcStates;
  }
  public SqlExecuteStageListener getListener(){
    return listener;
  }
  public void setListener(  SqlExecuteStageListener listener){
    this.listener=listener;
  }
  @Override public void checkQueueFlow(){
    RouteResultset rrs=session.getRrs();
    if (rrs != null && rrs.getNodes().length > 1 && session.getRrs().needMerge()) {
      return;
    }
 else {
      flowController.check(session.getTargetMap());
    }
  }
  @Override public void resetConnection(){
    session.closeAndClearResources("receive com_reset_connection");
    this.txInterrupted=false;
    this.autocommit=true;
    this.preAcStates=true;
    this.txReadonly=false;
    this.lastInsertId=0;
    super.resetConnection();
  }
  /** 
 * sql执行完成后回调函数
 */
  public void onEventSqlCompleted(){
    SqlEntry sqlEntry=null;
synchronized (this.executeSqlQueue) {
      this.executeSqlQueue.poll();
      sqlEntry=this.executeSqlQueue.peek();
      if (LOGGER.isDebugEnabled()) {
        LOGGER.debug("poll queue,executeSqlQueue size {}",this.executeSqlQueue.size());
      }
    }
    if (sqlEntry != null) {
      this.executeSqlId++;
      session.execute(sqlEntry.rrs,sqlEntry.rrs.isSelectForUpdate() ? ServerParse.UPDATE : sqlEntry.type);
    }
  }
private class SqlEntry {
    public String sql;
    public int type;
    public RouteResultset rrs;
    public SqlEntry(    String sql,    int type,    RouteResultset rrs){
      this.sql=sql;
      this.type=type;
      this.rrs=rrs;
    }
  }
}
