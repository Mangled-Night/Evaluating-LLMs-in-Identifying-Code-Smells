/** 
 * <p>Copies the given array and adds the given element at the end of the new array.</p> <p>The new array contains the same elements of the input array plus the given element in the last position. The component type of the new array is the same as that of the input array.</p> <p>If the input array is <code>null</code>, a new one element array is returned whose component type is the same as the element.</p> <pre> ArrayUtils.realAdd(null, null)      = [null] ArrayUtils.realAdd(null, "a")       = ["a"] ArrayUtils.realAdd(["a"], null)     = ["a", null] ArrayUtils.realAdd(["a"], "b")      = ["a", "b"] ArrayUtils.realAdd(["a", "b"], "c") = ["a", "b", "c"] </pre>
 * @param array   the array to "realAdd" the element to, may be <code>null</code>
 * @param element the object to realAdd
 * @return A new array containing the existing elements plus the new element
 */
@NonNull public static <T>T[] add(@Nullable T[] array,@Nullable T element){
  Class type=array != null ? array.getClass() : (element != null ? element.getClass() : Object.class);
  return (T[])realAddOne(array,element,type);
}
@NonNull public static boolean[] add(@Nullable boolean[] array,boolean element){
  return (boolean[])realAddOne(array,element,Boolean.TYPE);
}
@NonNull public static byte[] add(@Nullable byte[] array,byte element){
  return (byte[])realAddOne(array,element,Byte.TYPE);
}
@NonNull public static char[] add(@Nullable char[] array,char element){
  return (char[])realAddOne(array,element,Character.TYPE);
}
@NonNull public static double[] add(@Nullable double[] array,double element){
  return (double[])realAddOne(array,element,Double.TYPE);
}
@NonNull public static float[] add(@Nullable float[] array,float element){
  return (float[])realAddOne(array,element,Float.TYPE);
}
@NonNull public static int[] add(@Nullable int[] array,int element){
  return (int[])realAddOne(array,element,Integer.TYPE);
}
@NonNull public static long[] add(@Nullable long[] array,long element){
  return (long[])realAddOne(array,element,Long.TYPE);
}
@NonNull public static short[] add(@Nullable short[] array,short element){
  return (short[])realAddOne(array,element,Short.TYPE);
}
/** 
 * <p>Adds all the elements of the given arrays into a new array.</p> <p>The new array contains all of the element of <code>array1</code> followed by all of the elements <code>array2</code>. When an array is returned, it is always a new array.</p> <pre> ArrayUtils.add(null, null)     = null ArrayUtils.add(array1, null)   = copy of array1 ArrayUtils.add(null, array2)   = copy of array2 ArrayUtils.add([], [])         = [] ArrayUtils.add([null], [null]) = [null, null] ArrayUtils.add(["a", "b", "c"], ["1", "2", "3"]) = ["a", "b", "c", "1", "2", "3"] </pre>
 * @param array1 the first array whose elements are added to the new array, may be <code>null</code>
 * @param array2 the second array whose elements are added to the new array, may be <code>null</code>
 * @return The new array, <code>null</code> if <code>null</code> array inputs.The type of the new array is the type of the first array.
 */
@Nullable public static <T>T[] add(@Nullable T[] array1,@Nullable T[] array2){
  return (T[])realAddArr(array1,array2);
}
@Nullable public static boolean[] add(@Nullable boolean[] array1,@Nullable boolean[] array2){
  return (boolean[])realAddArr(array1,array2);
}
@Nullable public static char[] add(@Nullable char[] array1,@Nullable char[] array2){
  return (char[])realAddArr(array1,array2);
}
@Nullable public static byte[] add(@Nullable byte[] array1,@Nullable byte[] array2){
  return (byte[])realAddArr(array1,array2);
}
@Nullable public static short[] add(@Nullable short[] array1,@Nullable short[] array2){
  return (short[])realAddArr(array1,array2);
}
@Nullable public static int[] add(@Nullable int[] array1,@Nullable int[] array2){
  return (int[])realAddArr(array1,array2);
}
@Nullable public static long[] add(@Nullable long[] array1,@Nullable long[] array2){
  return (long[])realAddArr(array1,array2);
}
@Nullable public static float[] add(@Nullable float[] array1,@Nullable float[] array2){
  return (float[])realAddArr(array1,array2);
}
@Nullable public static double[] add(@Nullable double[] array1,@Nullable double[] array2){
  return (double[])realAddArr(array1,array2);
}
/** 
 * <p>Inserts the specified element at the specified position in the array. Shifts the element currently at that position (if any) and any subsequent elements to the right (adds one to their indices).</p> <p>This method returns a new array with the same elements of the input array plus the given element on the specified position. The component type of the returned array is always the same as that of the input array.</p> <p>If the input array is <code>null</code>, a new one element array is returned whose component type is the same as the element.</p> <pre> ArrayUtils.add(null, 0, null)        = null ArrayUtils.add(null, 0, ["a"])       = ["a"] ArrayUtils.add(["a"], 1, null)       = ["a"] ArrayUtils.add(["a"], 1, ["b"])      = ["a", "b"] ArrayUtils.add(["a", "b"], 2, ["c"]) = ["a", "b", "c"] </pre>
 * @param array1 the array to realAdd the element to, may be <code>null</code>
 * @param index  the position of the new object
 * @param array2 the array to realAdd
 * @return A new array containing the existing elements and the new element
 * @throws IndexOutOfBoundsException if the index is out of range(index < 0 || index > array.length).
 */
@Nullable public static <T>T[] add(@Nullable T[] array1,int index,@Nullable T[] array2){
  Class clss;
  if (array1 != null) {
    clss=array1.getClass().getComponentType();
  }
 else   if (array2 != null) {
    clss=array2.getClass().getComponentType();
  }
 else {
    return null;
  }
  return (T[])realAddArr(array1,index,array2,clss);
}
@Nullable public static boolean[] add(@Nullable boolean[] array1,int index,@Nullable boolean[] array2){
  Object result=realAddArr(array1,index,array2,Boolean.TYPE);
  if (result == null)   return null;
  return (boolean[])result;
}
public static char[] add(@Nullable char[] array1,int index,@Nullable char[] array2){
  Object result=realAddArr(array1,index,array2,Character.TYPE);
  if (result == null)   return null;
  return (char[])result;
}
@Nullable public static byte[] add(@Nullable byte[] array1,int index,@Nullable byte[] array2){
  Object result=realAddArr(array1,index,array2,Byte.TYPE);
  if (result == null)   return null;
  return (byte[])result;
}
@Nullable public static short[] add(@Nullable short[] array1,int index,@Nullable short[] array2){
  Object result=realAddArr(array1,index,array2,Short.TYPE);
  if (result == null)   return null;
  return (short[])result;
}
@Nullable public static int[] add(@Nullable int[] array1,int index,@Nullable int[] array2){
  Object result=realAddArr(array1,index,array2,Integer.TYPE);
  if (result == null)   return null;
  return (int[])result;
}
@Nullable public static long[] add(@Nullable long[] array1,int index,@Nullable long[] array2){
  Object result=realAddArr(array1,index,array2,Long.TYPE);
  if (result == null)   return null;
  return (long[])result;
}
@Nullable public static float[] add(@Nullable float[] array1,int index,@Nullable float[] array2){
  Object result=realAddArr(array1,index,array2,Float.TYPE);
  if (result == null)   return null;
  return (float[])result;
}
@Nullable public static double[] add(@Nullable double[] array1,int index,@Nullable double[] array2){
  Object result=realAddArr(array1,index,array2,Double.TYPE);
  if (result == null)   return null;
  return (double[])result;
}
/** 
 * <p>Inserts the specified element at the specified position in the array. Shifts the element currently at that position (if any) and any subsequent elements to the right (adds one to their indices).</p> <p>This method returns a new array with the same elements of the input array plus the given element on the specified position. The component type of the returned array is always the same as that of the input array.</p> <p>If the input array is <code>null</code>, a new one element array is returned whose component type is the same as the element.</p> <pre> ArrayUtils.add(null, 0, null)      = [null] ArrayUtils.add(null, 0, "a")       = ["a"] ArrayUtils.add(["a"], 1, null)     = ["a", null] ArrayUtils.add(["a"], 1, "b")      = ["a", "b"] ArrayUtils.add(["a", "b"], 3, "c") = ["a", "b", "c"] </pre>
 * @param array   the array to realAdd the element to, may be <code>null</code>
 * @param index   the position of the new object
 * @param element the object to realAdd
 * @return A new array containing the existing elements and the new element
 * @throws IndexOutOfBoundsException if the index is out of range(index < 0 || index > array.length).
 */
@NonNull public static <T>T[] add(@Nullable T[] array,int index,@Nullable T element){
  Class clss;
  if (array != null) {
    clss=array.getClass().getComponentType();
  }
 else   if (element != null) {
    clss=element.getClass();
  }
 else {
    return (T[])new Object[]{null};
  }
  return (T[])realAdd(array,index,element,clss);
}
@NonNull public static boolean[] add(@Nullable boolean[] array,int index,boolean element){
  return (boolean[])realAdd(array,index,element,Boolean.TYPE);
}
@NonNull public static char[] add(@Nullable char[] array,int index,char element){
  return (char[])realAdd(array,index,element,Character.TYPE);
}
@NonNull public static byte[] add(@Nullable byte[] array,int index,byte element){
  return (byte[])realAdd(array,index,element,Byte.TYPE);
}
@NonNull public static short[] add(@Nullable short[] array,int index,short element){
  return (short[])realAdd(array,index,element,Short.TYPE);
}
@NonNull public static int[] add(@Nullable int[] array,int index,int element){
  return (int[])realAdd(array,index,element,Integer.TYPE);
}
@NonNull public static long[] add(@Nullable long[] array,int index,long element){
  return (long[])realAdd(array,index,element,Long.TYPE);
}
@NonNull public static float[] add(@Nullable float[] array,int index,float element){
  return (float[])realAdd(array,index,element,Float.TYPE);
}
@NonNull public static double[] add(@Nullable double[] array,int index,double element){
  return (double[])realAdd(array,index,element,Double.TYPE);
}
