/** 
 * Create a new UnsafeFixedWidthAggregationMap.
 * @param emptyAggregationBuffer the default value for new keys (a "zero" of the agg. function)
 * @param aggregationBufferSchema the schema of the aggregation buffer, used for row conversion.
 * @param groupingKeySchema the schema of the grouping key, used for row conversion.
 * @param dataNodeMemoryManager the memory manager used to allocate our Unsafe memory structures.
 * @param initialCapacity the initial capacity of the map (a sizing hint to avoid re-hashing).
 * @param pageSizeBytes the data page size, in bytes; limits the maximum record size.
 * @param enablePerfMetrics if true, performance metrics will be recorded (has minor perf impact)
 */
public UnsafeFixedWidthAggregationMap(UnsafeRow emptyAggregationBuffer,StructType aggregationBufferSchema,StructType groupingKeySchema,DataNodeMemoryManager dataNodeMemoryManager,int initialCapacity,long pageSizeBytes,boolean enablePerfMetrics){
  this.aggregationBufferSchema=aggregationBufferSchema;
  this.currentAggregationBuffer=new UnsafeRow(aggregationBufferSchema.length());
  this.groupingKeySchema=groupingKeySchema;
  this.map=new BytesToBytesMap(dataNodeMemoryManager,initialCapacity,pageSizeBytes,enablePerfMetrics);
  this.enablePerfMetrics=enablePerfMetrics;
  this.emptyAggregationBuffer=emptyAggregationBuffer.getBytes();
}
