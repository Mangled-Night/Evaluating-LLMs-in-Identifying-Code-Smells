/** 
 * Decodes  {@link PendingMessages}.
 * @param < K > Key type.
 * @param < V > Value type.
 * @author Mark Paluch
 * @since 6.0
 */
public class PendingMessagesOutput<K,V> extends CommandOutput<K,V,PendingMessages> {
  private Long count;
  private String messageIdsFrom;
  private String messageIdsTo;
  private String consumer;
  private final Map<String,Long> consumerMessageCount=new LinkedHashMap<>();
  public PendingMessagesOutput(  RedisCodec<K,V> codec){
    super(codec,null);
  }
  @Override public void set(  ByteBuffer bytes){
    if (messageIdsFrom == null) {
      messageIdsFrom=decodeAscii(bytes);
      return;
    }
    if (messageIdsTo == null) {
      messageIdsTo=decodeAscii(bytes);
      return;
    }
    if (consumer == null) {
      consumer=StringCodec.UTF8.decodeKey(bytes);
      return;
    }
    set(Long.parseLong(decodeAscii(bytes)));
  }
  @Override public void set(  long integer){
    if (count == null) {
      count=integer;
      return;
    }
    if (consumer != null) {
      consumerMessageCount.put(consumer,integer);
      consumer=null;
    }
  }
  @Override public void complete(  int depth){
    if (depth == 0) {
      Range<String> range=messageIdsFrom != null && messageIdsTo != null ? Range.create(messageIdsFrom,messageIdsTo) : Range.unbounded();
      output=new PendingMessages(count == null ? 0 : count,range,consumerMessageCount);
    }
  }
}
