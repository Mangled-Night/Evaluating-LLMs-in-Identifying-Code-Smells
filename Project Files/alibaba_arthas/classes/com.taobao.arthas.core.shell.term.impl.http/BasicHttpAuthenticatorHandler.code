/** 
 * @author hengyunabc 2021-03-03
 */
public final class BasicHttpAuthenticatorHandler extends ChannelDuplexHandler {
  private static final Logger logger=LoggerFactory.getLogger(BasicHttpAuthenticatorHandler.class);
  private HttpSessionManager httpSessionManager;
  private SecurityAuthenticator securityAuthenticator=ArthasBootstrap.getInstance().getSecurityAuthenticator();
  public BasicHttpAuthenticatorHandler(  HttpSessionManager httpSessionManager){
    this.httpSessionManager=httpSessionManager;
  }
  @Override public void channelRead(  ChannelHandlerContext ctx,  Object msg) throws Exception {
    if (!securityAuthenticator.needLogin()) {
      ctx.fireChannelRead(msg);
      return;
    }
    boolean authed=false;
    if (msg instanceof HttpRequest) {
      HttpRequest httpRequest=(HttpRequest)msg;
      HttpSession session=httpSessionManager.getOrCreateHttpSession(ctx,httpRequest);
      if (session != null && session.getAttribute(ArthasConstants.SUBJECT_KEY) != null) {
        authed=true;
      }
      Principal principal=null;
      if (!authed) {
        principal=extractBasicAuthSubject(httpRequest);
        if (principal == null) {
          principal=extractBasicAuthSubjectFromUrl(httpRequest);
        }
      }
      if (!authed && principal == null) {
        principal=AuthUtils.localPrincipal(ctx);
      }
      Subject subject=securityAuthenticator.login(principal);
      if (subject != null) {
        authed=true;
        if (session != null) {
          session.setAttribute(ArthasConstants.SUBJECT_KEY,subject);
        }
      }
      if (!authed) {
        HttpResponse response=new DefaultHttpResponse(HttpVersion.HTTP_1_1,HttpResponseStatus.UNAUTHORIZED);
        response.headers().set(HttpHeaderNames.WWW_AUTHENTICATE,"Basic realm=\"arthas webconsole\"");
        response.headers().set(HttpHeaderNames.CONTENT_TYPE,"text/plain");
        response.headers().set(HttpHeaderNames.CONTENT_LENGTH,0);
        ctx.writeAndFlush(response);
        ctx.channel().close();
        return;
      }
    }
    ctx.fireChannelRead(msg);
  }
  @Override public void write(  ChannelHandlerContext ctx,  Object msg,  ChannelPromise promise) throws Exception {
    if (msg instanceof HttpResponse) {
      HttpResponse response=(HttpResponse)msg;
      Attribute<HttpSession> attribute=ctx.channel().attr(HttpSessionManager.SESSION_KEY);
      HttpSession session=attribute.get();
      if (session != null) {
        HttpSessionManager.setSessionCookie(response,session);
      }
    }
    super.write(ctx,msg,promise);
  }
  /** 
 * 从url参数里提取 ?username=hello&password=world
 * @param request
 * @return
 */
  protected static BasicPrincipal extractBasicAuthSubjectFromUrl(  HttpRequest request){
    QueryStringDecoder queryDecoder=new QueryStringDecoder(request.uri());
    Map<String,List<String>> parameters=queryDecoder.parameters();
    List<String> passwords=parameters.get(ArthasConstants.PASSWORD_KEY);
    if (passwords == null || passwords.size() == 0) {
      return null;
    }
    String password=passwords.get(0);
    String username=ArthasConstants.DEFAULT_USERNAME;
    List<String> usernames=parameters.get(ArthasConstants.USERNAME_KEY);
    if (usernames != null && !usernames.isEmpty()) {
      username=usernames.get(0);
    }
    BasicPrincipal principal=new BasicPrincipal(username,password);
    logger.debug("Extracted Basic Auth principal from url: {}",principal);
    return principal;
  }
  /** 
 * Extracts the username and password details from the HTTP basic header Authorization. <p/> This requires that the <tt>Authorization</tt> HTTP header is provided, and its using Basic. Currently Digest is <b>not</b> supported.
 * @return {@link HttpPrincipal} with username and password details, or<tt>null</tt> if not possible to extract
 */
  protected static BasicPrincipal extractBasicAuthSubject(  HttpRequest request){
    String auth=request.headers().get(HttpHeaderNames.AUTHORIZATION);
    if (auth != null) {
      String constraint=StringUtils.before(auth," ");
      if (constraint != null) {
        if ("Basic".equalsIgnoreCase(constraint.trim())) {
          String decoded=StringUtils.after(auth," ");
          if (decoded == null) {
            logger.error("Extracted Basic Auth principal failed, bad auth String: {}",auth);
            return null;
          }
          ByteBuf buf=Unpooled.wrappedBuffer(decoded.getBytes());
          ByteBuf out=Base64.decode(buf);
          String userAndPw=out.toString(Charset.defaultCharset());
          String username=StringUtils.before(userAndPw,":");
          String password=StringUtils.after(userAndPw,":");
          BasicPrincipal principal=new BasicPrincipal(username,password);
          logger.debug("Extracted Basic Auth principal from HTTP header: {}",principal);
          return principal;
        }
      }
    }
    return null;
  }
}
