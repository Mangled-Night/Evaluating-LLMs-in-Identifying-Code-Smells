/** 
 * The  {@code DijkstraUndirectedSP} class represents a data type for solvingthe single-source shortest paths problem in edge-weighted graphs where the edge weights are non-negative. <p> This implementation uses Dijkstra's algorithm with a binary heap. The constructor takes &Theta;(<em>E</em> log <em>V</em>) time in the worst case, where <em>V</em> is the number of vertices and <em>E</em> is the number of edges. Each instance method takes &Theta;(1) time. It uses &Theta;(<em>V</em>) extra space (not including the edge-weighted graph). <p> For additional documentation, see <a href="https://algs4.cs.princeton.edu/44sp">Section 4.4</a> of <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne. See  {@link DijkstraSP} for a version on edge-weighted digraphs.<p> This correctly computes shortest paths if all arithmetic performed is without floating-point rounding error or arithmetic overflow. This is the case if all edge weights are integers and if none of the intermediate results exceeds 2<sup>52</sup>. Since all intermediate results are sums of edge weights, they are bounded by <em>V C</em>, where <em>V</em> is the number of vertices and <em>C</em> is the maximum weight of any edge. <p>
 * @author Robert Sedgewick
 * @author Kevin Wayne
 * @author Nate Liu
 */
public class DijkstraUndirectedSP {
  private double[] distTo;
  private Edge[] edgeTo;
  private IndexMinPQ<Double> pq;
  /** 
 * Computes a shortest-paths tree from the source vertex  {@code s} to everyother vertex in the edge-weighted graph  {@code G}.
 * @param G the edge-weighted digraph
 * @param s the source vertex
 * @throws IllegalArgumentException if an edge weight is negative
 * @throws IllegalArgumentException unless {@code 0 <= s < V}
 */
  public DijkstraUndirectedSP(  EdgeWeightedGraph G,  int s){
    for (    Edge e : G.edges()) {
      if (e.weight() < 0)       throw new IllegalArgumentException("edge " + e + " has negative weight");
    }
    distTo=new double[G.V()];
    edgeTo=new Edge[G.V()];
    validateVertex(s);
    for (int v=0; v < G.V(); v++)     distTo[v]=Double.POSITIVE_INFINITY;
    distTo[s]=0.0;
    pq=new IndexMinPQ<Double>(G.V());
    pq.insert(s,distTo[s]);
    while (!pq.isEmpty()) {
      int v=pq.delMin();
      for (      Edge e : G.adj(v))       relax(e,v);
    }
    assert check(G,s);
  }
  private void relax(  Edge e,  int v){
    int w=e.other(v);
    if (distTo[w] > distTo[v] + e.weight()) {
      distTo[w]=distTo[v] + e.weight();
      edgeTo[w]=e;
      if (pq.contains(w))       pq.decreaseKey(w,distTo[w]);
 else       pq.insert(w,distTo[w]);
    }
  }
  /** 
 * Returns the length of a shortest path between the source vertex  {@code s} andvertex  {@code v}.
 * @param v the destination vertex
 * @return the length of a shortest path between the source vertex {@code s} andthe vertex  {@code v};  {@code Double.POSITIVE_INFINITY} if no such path
 * @throws IllegalArgumentException unless {@code 0 <= v < V}
 */
  public double distTo(  int v){
    validateVertex(v);
    return distTo[v];
  }
  /** 
 * Returns true if there is a path between the source vertex  {@code s} andvertex  {@code v}.
 * @param v the destination vertex
 * @return {@code true} if there is a path between the source vertex{@code s} to vertex {@code v};  {@code false} otherwise
 * @throws IllegalArgumentException unless {@code 0 <= v < V}
 */
  public boolean hasPathTo(  int v){
    validateVertex(v);
    return distTo[v] < Double.POSITIVE_INFINITY;
  }
  /** 
 * Returns a shortest path between the source vertex  {@code s} and vertex {@code v}.
 * @param v the destination vertex
 * @return a shortest path between the source vertex {@code s} and vertex {@code v}; {@code null} if no such path
 * @throws IllegalArgumentException unless {@code 0 <= v < V}
 */
  public Iterable<Edge> pathTo(  int v){
    validateVertex(v);
    if (!hasPathTo(v))     return null;
    Stack<Edge> path=new Stack<Edge>();
    int x=v;
    for (Edge e=edgeTo[v]; e != null; e=edgeTo[x]) {
      path.push(e);
      x=e.other(x);
    }
    return path;
  }
  private boolean check(  EdgeWeightedGraph G,  int s){
    for (    Edge e : G.edges()) {
      if (e.weight() < 0) {
        System.err.println("negative edge weight detected");
        return false;
      }
    }
    if (distTo[s] != 0.0 || edgeTo[s] != null) {
      System.err.println("distTo[s] and edgeTo[s] inconsistent");
      return false;
    }
    for (int v=0; v < G.V(); v++) {
      if (v == s)       continue;
      if (edgeTo[v] == null && distTo[v] != Double.POSITIVE_INFINITY) {
        System.err.println("distTo[] and edgeTo[] inconsistent");
        return false;
      }
    }
    for (int v=0; v < G.V(); v++) {
      for (      Edge e : G.adj(v)) {
        int w=e.other(v);
        if (distTo[v] + e.weight() < distTo[w]) {
          System.err.println("edge " + e + " not relaxed");
          return false;
        }
      }
    }
    for (int w=0; w < G.V(); w++) {
      if (edgeTo[w] == null)       continue;
      Edge e=edgeTo[w];
      if (w != e.either() && w != e.other(e.either()))       return false;
      int v=e.other(w);
      if (distTo[v] + e.weight() != distTo[w]) {
        System.err.println("edge " + e + " on shortest path not tight");
        return false;
      }
    }
    return true;
  }
  private void validateVertex(  int v){
    int V=distTo.length;
    if (v < 0 || v >= V)     throw new IllegalArgumentException("vertex " + v + " is not between 0 and "+ (V - 1));
  }
  /** 
 * Unit tests the  {@code DijkstraUndirectedSP} data type.
 * @param args the command-line arguments
 */
  public static void main(  String[] args){
    In in=new In(args[0]);
    EdgeWeightedGraph G=new EdgeWeightedGraph(in);
    int s=Integer.parseInt(args[1]);
    DijkstraUndirectedSP sp=new DijkstraUndirectedSP(G,s);
    for (int t=0; t < G.V(); t++) {
      if (sp.hasPathTo(t)) {
        StdOut.printf("%d to %d (%.2f)  ",s,t,sp.distTo(t));
        for (        Edge e : sp.pathTo(t)) {
          StdOut.print(e + "   ");
        }
        StdOut.println();
      }
 else {
        StdOut.printf("%d to %d         no path\n",s,t);
      }
    }
  }
}
