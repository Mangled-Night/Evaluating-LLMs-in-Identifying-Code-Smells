public final class MapIterator implements Iterator<Location> {
  private int numRecords;
  private final Location loc;
  private MemoryBlock currentPage=null;
  private int recordsInPage=0;
  private Object pageBaseObject;
  private long offsetInPage;
  private boolean destructive=false;
  private UnsafeSorterSpillReader reader=null;
  private MapIterator(  int numRecords,  Location loc,  boolean destructive){
    this.numRecords=numRecords;
    this.loc=loc;
    this.destructive=destructive;
    if (destructive) {
      destructiveIterator=this;
    }
  }
  private void advanceToNextPage(){
synchronized (this) {
      int nextIdx=dataPages.indexOf(currentPage) + 1;
      if (destructive && currentPage != null) {
        dataPages.remove(currentPage);
        freePage(currentPage);
        nextIdx--;
      }
      if (dataPages.size() > nextIdx) {
        currentPage=dataPages.get(nextIdx);
        pageBaseObject=currentPage.getBaseObject();
        offsetInPage=currentPage.getBaseOffset();
        recordsInPage=Platform.getInt(pageBaseObject,offsetInPage);
        offsetInPage+=4;
      }
 else {
        currentPage=null;
        if (reader != null) {
          File file=spillWriters.removeFirst().getFile();
          if (file != null && file.exists()) {
            if (!file.delete()) {
              logger.error("Was unable to delete spill file {}",file.getAbsolutePath());
            }
          }
        }
        try {
          Closeables.close(reader,false);
          if (spillWriters.size() > 0) {
            reader=spillWriters.getFirst().getReader(serializerManager);
          }
          recordsInPage=-1;
        }
 catch (        IOException e) {
          Platform.throwException(e);
        }
      }
    }
  }
  @Override public boolean hasNext(){
    if (numRecords == 0) {
      if (reader != null) {
        File file=spillWriters.removeFirst().getFile();
        if (file != null && file.exists()) {
          if (!file.delete()) {
            logger.error("Was unable to delete spill file {}",file.getAbsolutePath());
          }
        }
      }
    }
    return numRecords > 0;
  }
  @Override public Location next(){
    if (recordsInPage == 0) {
      advanceToNextPage();
    }
    numRecords--;
    if (currentPage != null) {
      int totalLength=Platform.getInt(pageBaseObject,offsetInPage);
      loc.with(currentPage,offsetInPage);
      offsetInPage+=4 + totalLength + 8;
      recordsInPage--;
      return loc;
    }
 else {
      assert (reader != null);
      if (!reader.hasNext()) {
        advanceToNextPage();
      }
      try {
        reader.loadNext();
      }
 catch (      IOException e) {
        try {
          reader.close();
        }
 catch (        IOException e2) {
          logger.error("Error while closing spill reader",e2);
        }
        Platform.throwException(e);
      }
      loc.with(reader.getBaseObject(),reader.getBaseOffset(),reader.getRecordLength());
      return loc;
    }
  }
  public long spill(  long numBytes) throws IOException {
synchronized (this) {
      if (!destructive || dataPages.size() == 1) {
        return 0L;
      }
      long released=0L;
      while (dataPages.size() > 0) {
        MemoryBlock block=dataPages.getLast();
        if (block == currentPage) {
          break;
        }
        Object base=block.getBaseObject();
        long offset=block.getBaseOffset();
        int numRecords=Platform.getInt(base,offset);
        offset+=4;
        final UnsafeSorterSpillWriter writer=new UnsafeSorterSpillWriter(blockManager,32 * 1024,numRecords);
        while (numRecords > 0) {
          int length=Platform.getInt(base,offset);
          writer.write(base,offset + 4,length,0);
          offset+=4 + length + 8;
          numRecords--;
        }
        writer.close();
        spillWriters.add(writer);
        dataPages.removeLast();
        released+=block.size();
        freePage(block);
        if (released >= numBytes) {
          break;
        }
      }
      return released;
    }
  }
  @Override public void remove(){
    throw new UnsupportedOperationException();
  }
}
