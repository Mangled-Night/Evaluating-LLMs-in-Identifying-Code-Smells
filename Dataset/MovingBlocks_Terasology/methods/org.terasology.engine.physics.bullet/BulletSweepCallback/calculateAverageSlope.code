@Override public float calculateAverageSlope(float originalSlope,float checkingOffset){
  Vector3f contactPoint=this.getHitPointWorld();
  float slope=1f;
  boolean foundSlope=false;
  Vector3f fromWorld=new Vector3f(contactPoint);
  fromWorld.y+=0.2f;
  Vector3f toWorld=new Vector3f(contactPoint);
  toWorld.y-=0.2f;
  ClosestRayResultCallback resultCallback=new ClosestRayResultCallback(fromWorld,toWorld);
  Matrix4f from=new Matrix4f().setTranslation(fromWorld);
  Matrix4f to=new Matrix4f().setTranslation(toWorld);
  Matrix4f targetTransform=this.getHitCollisionObject().getWorldTransform();
  btDiscreteDynamicsWorld.rayTestSingle(from,to,this.getHitCollisionObject(),this.getHitCollisionObject().getCollisionShape(),targetTransform,resultCallback);
  if (resultCallback.hasHit()) {
    foundSlope=true;
    Vector3f result=new Vector3f();
    resultCallback.getHitNormalWorld(result);
    slope=Math.min(slope,result.dot(0,1,0));
  }
  Vector3f secondTraceOffset=new Vector3f();
  this.getHitNormalWorld(secondTraceOffset);
  secondTraceOffset.y=0;
  secondTraceOffset.normalize();
  secondTraceOffset.mul(checkingOffset);
  fromWorld.add(secondTraceOffset);
  toWorld.add(secondTraceOffset);
  resultCallback=new ClosestRayResultCallback(fromWorld,toWorld);
  from=new Matrix4f().setTranslation(fromWorld);
  to=new Matrix4f().setTranslation(toWorld);
  targetTransform=this.getHitCollisionObject().getWorldTransform();
  btDiscreteDynamicsWorld.rayTestSingle(from,to,this.getHitCollisionObject(),this.getHitCollisionObject().getCollisionShape(),targetTransform,resultCallback);
  if (resultCallback.hasHit()) {
    foundSlope=true;
    Vector3f hitNormal=new Vector3f();
    resultCallback.getHitNormalWorld(hitNormal);
    slope=Math.min(slope,hitNormal.dot(0,1,0));
  }
  if (!foundSlope) {
    slope=originalSlope;
  }
  resultCallback.dispose();
  return slope;
}
