static class CommandMatches {
  private final List<String> matches=new ArrayList<>();
  private CommandMatches(  List<String> matches){
    this.matches.addAll(matches);
  }
  public static CommandMatches forCommand(  String command,  List<CommandDetail> commandDetails){
    return new CommandMatches(calculateMatches(command,commandDetails));
  }
  private static List<String> calculateMatches(  String command,  List<CommandDetail> commandDetails){
    return commandDetails.stream().filter(commandDetail -> calculateStringDistance(commandDetail.getName().toLowerCase(),command.toLowerCase()) <= DEFAULT_MAX_DISTANCE).map(CommandDetail::getName).map(String::toUpperCase).sorted(CommandMatches::calculateStringDistance).collect(Collectors.toList());
  }
  public boolean hasMatches(){
    return !matches.isEmpty();
  }
  @Override public String toString(){
    return LettuceStrings.collectionToDelimitedString(matches,", ","","");
  }
  /** 
 * Calculate the distance between the given two Strings according to the Levenshtein algorithm.
 * @param s1 the first String
 * @param s2 the second String
 * @return the distance value
 */
  private static int calculateStringDistance(  String s1,  String s2){
    if (s1.length() == 0) {
      return s2.length();
    }
    if (s2.length() == 0) {
      return s1.length();
    }
    int d[][]=new int[s1.length() + 1][s2.length() + 1];
    for (int i=0; i <= s1.length(); i++) {
      d[i][0]=i;
    }
    for (int j=0; j <= s2.length(); j++) {
      d[0][j]=j;
    }
    for (int i=1; i <= s1.length(); i++) {
      char s_i=s1.charAt(i - 1);
      for (int j=1; j <= s2.length(); j++) {
        int cost;
        char t_j=s2.charAt(j - 1);
        if (s_i == t_j) {
          cost=0;
        }
 else {
          cost=1;
        }
        d[i][j]=Math.min(Math.min(d[i - 1][j] + 1,d[i][j - 1] + 1),d[i - 1][j - 1] + cost);
      }
    }
    return d[s1.length()][s2.length()];
  }
}
