/** 
 * @author mycat
 */
public final class RouteResultset implements Serializable {
  private String statement;
  private final int sqlType;
  private RouteResultsetNode[] nodes;
  private Set<String> subTables;
  private SQLStatement sqlStatement;
  private int limitStart;
  private boolean cacheAble;
  private String primaryKey;
  private int limitSize;
  private SQLMerge sqlMerge;
  private boolean callStatement=false;
  private boolean globalTableFlag=false;
  private boolean isFinishedRoute=false;
  private boolean autocommit=true;
  private boolean isLoadData=false;
  private Boolean canRunInReadDB;
  private Boolean runOnSlave=null;
  private Map<String,Integer> dataNodeSlotMap=new HashMap<>();
  private boolean selectForUpdate;
  private boolean autoIncrement;
  private Map<String,List<String>> subTableMaps;
  public boolean isSelectForUpdate(){
    return selectForUpdate;
  }
  public void setSelectForUpdate(  boolean selectForUpdate){
    this.selectForUpdate=selectForUpdate;
  }
  private List<String> tables;
  public List<String> getTables(){
    return tables;
  }
  public void setTables(  List<String> tables){
    this.tables=tables;
  }
  public Map<String,Integer> getDataNodeSlotMap(){
    return dataNodeSlotMap;
  }
  public void setDataNodeSlotMap(  Map<String,Integer> dataNodeSlotMap){
    this.dataNodeSlotMap=dataNodeSlotMap;
  }
  public Boolean getRunOnSlave(){
    return runOnSlave;
  }
  public String getRunOnSlaveDebugInfo(){
    return runOnSlave == null ? "default" : Boolean.toString(runOnSlave);
  }
  public void setRunOnSlave(  Boolean runOnSlave){
    this.runOnSlave=runOnSlave;
  }
  private Procedure procedure;
  public Procedure getProcedure(){
    return procedure;
  }
  public void setProcedure(  Procedure procedure){
    this.procedure=procedure;
  }
  public boolean isLoadData(){
    return isLoadData;
  }
  public void setLoadData(  boolean isLoadData){
    this.isLoadData=isLoadData;
  }
  public boolean isFinishedRoute(){
    return isFinishedRoute;
  }
  public void setFinishedRoute(  boolean isFinishedRoute){
    this.isFinishedRoute=isFinishedRoute;
  }
  public boolean isGlobalTable(){
    return globalTableFlag;
  }
  public void setGlobalTable(  boolean globalTableFlag){
    this.globalTableFlag=globalTableFlag;
  }
  public RouteResultset(  String stmt,  int sqlType){
    this.statement=stmt;
    this.limitSize=-1;
    this.sqlType=sqlType;
  }
  public void resetNodes(){
    if (nodes != null) {
      for (      RouteResultsetNode node : nodes) {
        node.resetStatement();
      }
    }
  }
  public void copyLimitToNodes(){
    if (nodes != null) {
      for (      RouteResultsetNode node : nodes) {
        if (node.getLimitSize() == -1 && node.getLimitStart() == 0) {
          node.setLimitStart(limitStart);
          node.setLimitSize(limitSize);
        }
      }
    }
  }
  public SQLMerge getSqlMerge(){
    return sqlMerge;
  }
  public boolean isCacheAble(){
    return cacheAble;
  }
  public void setCacheAble(  boolean cacheAble){
    this.cacheAble=cacheAble;
  }
  public boolean needMerge(){
    return limitSize > 0 || sqlMerge != null;
  }
  public int getSqlType(){
    return sqlType;
  }
  public boolean isHasAggrColumn(){
    return (sqlMerge != null) && sqlMerge.isHasAggrColumn();
  }
  public int getLimitStart(){
    return limitStart;
  }
  public String[] getGroupByCols(){
    return (sqlMerge != null) ? sqlMerge.getGroupByCols() : null;
  }
  private SQLMerge createSQLMergeIfNull(){
    if (sqlMerge == null) {
      sqlMerge=new SQLMerge();
    }
    return sqlMerge;
  }
  public Map<String,Integer> getMergeCols(){
    return (sqlMerge != null) ? sqlMerge.getMergeCols() : null;
  }
  public void setLimitStart(  int limitStart){
    this.limitStart=limitStart;
  }
  public String getPrimaryKey(){
    return primaryKey;
  }
  public boolean hasPrimaryKeyToCache(){
    return primaryKey != null;
  }
  public void setPrimaryKey(  String primaryKey){
    if (!primaryKey.contains(".")) {
      throw new java.lang.IllegalArgumentException("must be table.primarykey fomat :" + primaryKey);
    }
    this.primaryKey=primaryKey;
  }
  /** 
 * return primary key items ,first is table name ,seconds is primary key
 * @return
 */
  public String[] getPrimaryKeyItems(){
    return primaryKey.split("\\.");
  }
  public void setOrderByCols(  LinkedHashMap<String,Integer> orderByCols){
    if (orderByCols != null && !orderByCols.isEmpty()) {
      createSQLMergeIfNull().setOrderByCols(orderByCols);
    }
  }
  public void setHasAggrColumn(  boolean hasAggrColumn){
    if (hasAggrColumn) {
      createSQLMergeIfNull().setHasAggrColumn(true);
    }
  }
  public void setGroupByCols(  String[] groupByCols){
    if (groupByCols != null && groupByCols.length > 0) {
      createSQLMergeIfNull().setGroupByCols(groupByCols);
    }
  }
  public void setMergeCols(  Map<String,Integer> mergeCols){
    if (mergeCols != null && !mergeCols.isEmpty()) {
      createSQLMergeIfNull().setMergeCols(mergeCols);
    }
  }
  public LinkedHashMap<String,Integer> getOrderByCols(){
    return (sqlMerge != null) ? sqlMerge.getOrderByCols() : null;
  }
  public String getStatement(){
    return statement;
  }
  public RouteResultsetNode[] getNodes(){
    return nodes;
  }
  public void setNodes(  RouteResultsetNode[] nodes){
    if (nodes != null) {
      int nodeSize=nodes.length;
      for (      RouteResultsetNode node : nodes) {
        node.setTotalNodeSize(nodeSize);
      }
    }
    this.nodes=nodes;
  }
  /** 
 * @return -1 if no limit
 */
  public int getLimitSize(){
    return limitSize;
  }
  public void setLimitSize(  int limitSize){
    this.limitSize=limitSize;
  }
  public void setStatement(  String statement){
    this.statement=statement;
  }
  public boolean isCallStatement(){
    return callStatement;
  }
  public void setCallStatement(  boolean callStatement){
    this.callStatement=callStatement;
    if (nodes != null) {
      for (      RouteResultsetNode node : nodes) {
        node.setCallStatement(callStatement);
      }
    }
  }
  public void changeNodeSqlAfterAddLimit(  SchemaConfig schemaConfig,  String sourceDbType,  String sql,  int offset,  int count,  boolean isNeedConvert){
    if (nodes != null) {
      Map<String,String> dataNodeDbTypeMap=schemaConfig.getDataNodeDbTypeMap();
      Map<String,String> sqlMapCache=new HashMap<>();
      for (      RouteResultsetNode node : nodes) {
        String dbType=dataNodeDbTypeMap.get(node.getName());
        if (dbType.equalsIgnoreCase("mysql")) {
          node.setStatement(sql);
        }
 else         if (sqlMapCache.containsKey(dbType)) {
          node.setStatement(sqlMapCache.get(dbType));
        }
 else         if (isNeedConvert) {
          String nativeSql=PageSQLUtil.convertLimitToNativePageSql(dbType,sql,offset,count);
          sqlMapCache.put(dbType,nativeSql);
          node.setStatement(nativeSql);
        }
 else {
          node.setStatement(sql);
        }
        node.setLimitStart(offset);
        node.setLimitSize(count);
      }
    }
  }
  public boolean isAutocommit(){
    return autocommit;
  }
  public void setAutocommit(  boolean autocommit){
    this.autocommit=autocommit;
  }
  public Boolean getCanRunInReadDB(){
    return canRunInReadDB;
  }
  public void setCanRunInReadDB(  Boolean canRunInReadDB){
    this.canRunInReadDB=canRunInReadDB;
  }
  public HavingCols getHavingCols(){
    return (sqlMerge != null) ? sqlMerge.getHavingCols() : null;
  }
  public void setSubTables(  Set<String> subTables){
    this.subTables=subTables;
  }
  public void setHavings(  HavingCols havings){
    if (havings != null) {
      createSQLMergeIfNull().setHavingCols(havings);
    }
  }
  public void setHavingColsName(  Object[] names){
    if (names != null && names.length > 0) {
      createSQLMergeIfNull().setHavingColsName(names);
    }
  }
  public SQLStatement getSqlStatement(){
    return this.sqlStatement;
  }
  public void setSqlStatement(  SQLStatement sqlStatement){
    this.sqlStatement=sqlStatement;
  }
  public Set<String> getSubTables(){
    return this.subTables;
  }
  public boolean isDistTable(){
    if (this.getSubTables() != null && !this.getSubTables().isEmpty()) {
      return true;
    }
    return false;
  }
  @Override public String toString(){
    StringBuilder s=new StringBuilder();
    s.append(statement).append(", route={");
    if (nodes != null) {
      for (int i=0; i < nodes.length; ++i) {
        s.append("\n ").append(FormatUtil.format(i + 1,3));
        s.append(" -> ").append(nodes[i]);
      }
    }
    s.append("\n}");
    return s.toString();
  }
  public void setAutoIncrement(  boolean b){
    autoIncrement=b;
  }
  public boolean getAutoIncrement(){
    return autoIncrement;
  }
  public Map<String,List<String>> getSubTableMaps(){
    return subTableMaps;
  }
  public void setSubTableMaps(  Map<String,List<String>> subTableMaps){
    this.subTableMaps=subTableMaps;
  }
  /** 
 * 合并路由节点相同的节点
 */
  public void mergeSameNode(){
    Map<String,RouteResultsetNode> mapNodes=new HashMap<>(64);
    for (    RouteResultsetNode node : nodes) {
      if (mapNodes.containsKey(node.getName())) {
        RouteResultsetNode tmpNode=mapNodes.get(node.getName());
        tmpNode.setStatement(tmpNode.getStatement() + ";" + node.getStatement());
      }
 else {
        mapNodes.put(node.getName(),node);
      }
    }
    RouteResultsetNode[] newNodes=new RouteResultsetNode[mapNodes.size()];
    int i=0;
    for (    Entry<String,RouteResultsetNode> entry : mapNodes.entrySet()) {
      newNodes[i++]=entry.getValue();
    }
    this.setNodes(newNodes);
  }
}
