/** 
 * Load partition views from a collection of  {@link RedisURI}s and return the view per  {@link RedisURI}. Partitions contain an ordered list of  {@link RedisClusterNode}s. The sort key is latency. Nodes with lower latency come first.
 * @param seed collection of {@link RedisURI}s
 * @param connectTimeout connect timeout
 * @param discovery {@code true} to discover additional nodes
 * @return mapping between {@link RedisURI} and {@link Partitions}
 */
@Override public CompletionStage<Map<RedisURI,Partitions>> loadViews(Iterable<RedisURI> seed,Duration connectTimeout,boolean discovery){
  if (!isEventLoopActive()) {
    return CompletableFuture.completedFuture(Collections.emptyMap());
  }
  long commandTimeoutNs=getCommandTimeoutNs(seed);
  ConnectionTracker tracker=new ConnectionTracker();
  long connectionTimeout=commandTimeoutNs + connectTimeout.toNanos();
  openConnections(tracker,seed,connectionTimeout,TimeUnit.NANOSECONDS);
  CompletableFuture<NodeTopologyViews> composition=tracker.whenComplete(map -> {
    return new Connections(clientResources,map);
  }
).thenCompose(connections -> {
    Requests requestedTopology=connections.requestTopology(commandTimeoutNs,TimeUnit.NANOSECONDS);
    Requests requestedInfo=connections.requestInfo(commandTimeoutNs,TimeUnit.NANOSECONDS);
    return CompletableFuture.allOf(requestedTopology.allCompleted(),requestedInfo.allCompleted()).thenApplyAsync(ignore -> getNodeSpecificViews(requestedTopology,requestedInfo),clientResources.eventExecutorGroup()).thenCompose(views -> {
      if (discovery && isEventLoopActive()) {
        Set<RedisURI> allKnownUris=views.getClusterNodes();
        Set<RedisURI> discoveredNodes=difference(allKnownUris,toSet(seed));
        if (discoveredNodes.isEmpty()) {
          return CompletableFuture.completedFuture(views);
        }
        openConnections(tracker,discoveredNodes,connectionTimeout,TimeUnit.NANOSECONDS);
        return tracker.whenComplete(map -> {
          return new Connections(clientResources,map).retainAll(discoveredNodes);
        }
).thenCompose(newConnections -> {
          Requests additionalTopology=newConnections.requestTopology(commandTimeoutNs,TimeUnit.NANOSECONDS).mergeWith(requestedTopology);
          Requests additionalInfo=newConnections.requestInfo(commandTimeoutNs,TimeUnit.NANOSECONDS).mergeWith(requestedInfo);
          return CompletableFuture.allOf(additionalTopology.allCompleted(),additionalInfo.allCompleted()).thenApplyAsync(ignore2 -> getNodeSpecificViews(additionalTopology,additionalInfo),clientResources.eventExecutorGroup());
        }
);
      }
      return CompletableFuture.completedFuture(views);
    }
).whenComplete((ignore,throwable) -> {
      if (throwable != null) {
        try {
          tracker.close();
        }
 catch (        Exception e) {
          logger.debug("Cannot close ClusterTopologyRefresh connections",e);
        }
      }
    }
).thenCompose((it) -> tracker.close().thenApply(ignore -> it)).thenCompose(it -> {
      if (it.isEmpty()) {
        Exception exception=tryFail(requestedTopology,tracker,seed);
        return Futures.failed(exception);
      }
      return CompletableFuture.completedFuture(it);
    }
);
  }
);
  return composition.thenApply(NodeTopologyViews::toMap);
}
