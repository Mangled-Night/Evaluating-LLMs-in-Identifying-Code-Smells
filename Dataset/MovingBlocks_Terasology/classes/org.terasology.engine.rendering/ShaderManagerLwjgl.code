/** 
 * Provides support for loading and applying shaders.
 */
public class ShaderManagerLwjgl implements ShaderManager {
  private static final Logger logger=LoggerFactory.getLogger(ShaderManagerLwjgl.class);
  private GLSLMaterial activeMaterial;
  private Set<GLSLMaterial> progamaticShaders=Sets.newHashSet();
  public ShaderManagerLwjgl(){
  }
  @Override public void initShaders(){
    logCapabilities();
    addShaderProgram("default");
    addShaderProgram("blockSelection");
    addShaderProgram("particle");
  }
  private void logCapabilities(){
    logger.info("Loading Terasology shader manager...");
    logger.info("LWJGL: {} / {}",Version.getVersion(),Platform.get().getName());
    logger.info("GL_VENDOR: {}",GL11.glGetString(GL11.GL_VENDOR));
    logger.info("GL_RENDERER: {}",GL11.glGetString(GL11.GL_RENDERER));
    logger.info("GL_VERSION: {}",GL11.glGetString(GL11.GL_VERSION));
    logger.info("SHADING_LANGUAGE VERSION: {}",GL11.glGetString(GL20.GL_SHADING_LANGUAGE_VERSION));
    int[] extension=new int[1];
    GL30.glGetIntegerv(GL30.GL_NUM_EXTENSIONS,extension);
    int extsPerLine=8;
    if (extension[0] > 0) {
      StringBuilder bldr=new StringBuilder();
      for (int i=1; i < extension[0]; i++) {
        if (i % extsPerLine == 0) {
          logger.info("EXTENSIONS: {}",bldr);
          bldr.setLength(0);
        }
 else {
          bldr.append(" ");
        }
        bldr.append(GL30.glGetStringi(GL30.GL_EXTENSIONS,i));
      }
      if (bldr.length() > 0) {
        logger.info("EXTENSIONS: {}",bldr);
      }
    }
  }
  @Override public void setActiveMaterial(  Material material){
    GLSLMaterial glslMaterial=(GLSLMaterial)material;
    if (!glslMaterial.equals(activeMaterial)) {
      activeMaterial=glslMaterial;
    }
  }
  @Override public void bindTexture(  int slot,  Texture texture){
    if (activeMaterial != null && !activeMaterial.isDisposed()) {
      GL13.glActiveTexture(GL13.GL_TEXTURE0 + slot);
      GL11.glBindTexture(GL11.GL_TEXTURE_2D,texture.getId());
      GL13.glActiveTexture(GL13.GL_TEXTURE0);
    }
  }
  @Override public Material getActiveMaterial(){
    return activeMaterial;
  }
  @Override public void recompileAllShaders(){
    AssetManager assetManager=CoreRegistry.get(AssetManager.class);
    assetManager.getLoadedAssets(Shader.class).forEach(Shader::recompile);
    assetManager.getLoadedAssets(Material.class).forEach(Material::recompile);
    activeMaterial=null;
  }
  public GLSLMaterial addShaderProgram(  String title){
    return addShaderProgram(title,"engine");
  }
  public GLSLMaterial addShaderProgram(  String title,  String providingModule){
    String uri=providingModule + ":" + title;
    Optional<? extends Shader> shader=Assets.getShader(uri);
    checkState(shader.isPresent(),"Failed to resolve %s",uri);
    shader.get().recompile();
    GLSLMaterial material=(GLSLMaterial)Assets.generateAsset(new ResourceUrn(providingModule + ":prog." + title),new MaterialData(shader.get()),Material.class);
    progamaticShaders.add(material);
    return material;
  }
  @Override public void disableShader(){
    GL20.glUseProgram(0);
    activeMaterial=null;
  }
}
