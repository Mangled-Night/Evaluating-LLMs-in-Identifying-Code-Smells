/** 
 * Perform an in-place update on the component if the specified component class is present. <p> If this contains a component of the given class the transformation function 'f' is applied to that component. Otherwise, function 'f' is <strong>not</strong> called. <p> This is a functional convenience method to abstract over retrieving and saving a component for modification. Given an update function  {@code ItemComponent updateItem(ItemComponent component)} that takes a component andreturns the modified component the component update can be written as concise as: <pre> {@code EntityRef item = entityManager.create("CoreAdvancedAssets:door"); item.updateComponent(ItemComponent.class, MyItemHandler::updateItem);}</pre> The same effect can be achieved by extracting and saving the component manually: <pre> {@code EntityRef item = entityManager.create("CoreAdvancedAssets:door"); ItemComponent doorItemComp = item.getComponent(ItemComponent.class); updateItem(doorItemComp); item.saveComponent(doorItemComp);}</pre> <p> If the transformation function  {@code f} returns {@code null} the component will be removed from this container.This can be useful in cases where updating the component leads to a state where it becomes obsolete and should be removed. <p> To create or update a component on this container, see  {@link MutableComponentContainer#upsertComponent(Class,Function)}
 * @param componentClass component class to update
 * @param f transformation function used to compute the updated component; returning {@code null} removesthe component
 * @param < T > type of the component to update
 * @see MutableComponentContainer#upsertComponent(Class,Function)
 */
default <T extends Component>void updateComponent(Class<T> componentClass,Function<T,T> f){
  if (hasComponent(componentClass)) {
    T component=f.apply(getComponent(componentClass));
    if (component == null) {
      removeComponent(componentClass);
    }
 else {
      saveComponent(component);
    }
  }
}
