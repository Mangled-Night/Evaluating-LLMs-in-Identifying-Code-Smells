public class IoT {
  private static final long TIMEOUT=10 * 60 * 1000;
private interface IotScenario {
    void iotScenario(    XMPPTCPConnection dataThingConnection,    XMPPTCPConnection readingThingConnection) throws Exception ;
  }
  public static void iotScenario(  String dataThingJidString,  String dataThingPassword,  String readingThingJidString,  String readingThingPassword,  IotScenario scenario) throws Exception {
    final EntityBareJid dataThingJid=JidCreate.entityBareFrom(dataThingJidString);
    final EntityBareJid readingThingJid=JidCreate.entityBareFrom(readingThingJidString);
    final XMPPTCPConnectionConfiguration dataThingConnectionConfiguration=XMPPTCPConnectionConfiguration.builder().setUsernameAndPassword(dataThingJid.getLocalpart(),dataThingPassword).setXmppDomain(dataThingJid.asDomainBareJid()).setSecurityMode(SecurityMode.disabled).enableDefaultDebugger().build();
    final XMPPTCPConnectionConfiguration readingThingConnectionConfiguration=XMPPTCPConnectionConfiguration.builder().setUsernameAndPassword(readingThingJid.getLocalpart(),readingThingPassword).setXmppDomain(readingThingJid.asDomainBareJid()).setSecurityMode(SecurityMode.disabled).enableDefaultDebugger().build();
    final XMPPTCPConnection dataThingConnection=new XMPPTCPConnection(dataThingConnectionConfiguration);
    final XMPPTCPConnection readingThingConnection=new XMPPTCPConnection(readingThingConnectionConfiguration);
    dataThingConnection.setReplyTimeout(TIMEOUT);
    readingThingConnection.setReplyTimeout(TIMEOUT);
    dataThingConnection.setUseStreamManagement(false);
    readingThingConnection.setUseStreamManagement(false);
    try {
      dataThingConnection.connect().login();
      readingThingConnection.connect().login();
      scenario.iotScenario(dataThingConnection,readingThingConnection);
    }
  finally {
      dataThingConnection.disconnect();
      readingThingConnection.disconnect();
    }
  }
  public static void iotReadOutScenario(  String dataThingJidString,  String dataThingPassword,  String readingThingJidString,  String readingThingPassword) throws Exception {
    iotScenario(dataThingJidString,dataThingPassword,readingThingJidString,readingThingPassword,READ_OUT_SCENARIO);
  }
  public static final IotScenario READ_OUT_SCENARIO=new IotScenario(){
    @Override public void iotScenario(    XMPPTCPConnection dataThingConnection,    XMPPTCPConnection readingThingConnection) throws TimeoutException, Exception {
      ThingState dataThingState=actAsDataThing(dataThingConnection);
      final SimpleResultSyncPoint syncPoint=new SimpleResultSyncPoint();
      dataThingState.setThingStateChangeListener(new AbstractThingStateChangeListener(){
        @Override public void owned(        BareJid jid){
          syncPoint.signal();
        }
      }
);
      syncPoint.waitForResult(TIMEOUT);
      printStatus("OWNED - Thing now owned by " + dataThingState.getOwner());
      IoTProvisioningManager readingThingProvisioningManager=IoTProvisioningManager.getInstanceFor(readingThingConnection);
      readingThingProvisioningManager.sendFriendshipRequestIfRequired(dataThingConnection.getUser().asBareJid());
      Roster dataThingRoster=Roster.getInstanceFor(dataThingConnection);
      RosterUtil.waitUntilOtherEntityIsSubscribed(dataThingRoster,readingThingConnection.getUser().asBareJid(),TIMEOUT);
      printStatus("FRIENDSHIP ACCEPTED - Trying to read out data");
      IoTDataManager readingThingDataManager=IoTDataManager.getInstanceFor(readingThingConnection);
      List<IoTFieldsExtension> values=readingThingDataManager.requestMomentaryValuesReadOut(dataThingConnection.getUser());
      if (values.size() != 1) {
        throw new IllegalStateException("Unexpected number of values returned: " + values.size());
      }
      IoTFieldsExtension field=values.get(0);
      printStatus("DATA READ-OUT SUCCESS: " + field.toXML());
      printStatus("IoT SCENARIO FINISHED SUCCESSFULLY");
    }
  }
;
  public static void iotOwnerApprovesFriendScenario(  String dataThingJidString,  String dataThingPassword,  String readingThingJidString,  String readingThingPassword) throws Exception {
    iotScenario(dataThingJidString,dataThingPassword,readingThingJidString,readingThingPassword,OWNER_APPROVES_FRIEND_SCENARIO);
  }
  public static final IotScenario OWNER_APPROVES_FRIEND_SCENARIO=new IotScenario(){
    @Override public void iotScenario(    XMPPTCPConnection dataThingConnection,    XMPPTCPConnection readingThingConnection) throws TimeoutException, Exception {
      RosterUtil.ensureNotSubscribedToEachOther(dataThingConnection,readingThingConnection);
      final BareJid dataThingBareJid=dataThingConnection.getUser().asBareJid();
      final BareJid readingThingBareJid=readingThingConnection.getUser().asBareJid();
      final ThingState dataThingState=actAsDataThing(dataThingConnection);
      printStatus("WAITING for 'claimed' notification. Please claim thing now");
      final SimpleResultSyncPoint syncPoint=new SimpleResultSyncPoint();
      dataThingState.setThingStateChangeListener(new AbstractThingStateChangeListener(){
        @Override public void owned(        BareJid jid){
          syncPoint.signal();
        }
      }
);
      syncPoint.waitForResult(TIMEOUT);
      printStatus("OWNED - Thing now owned by " + dataThingState.getOwner());
      final SimpleResultSyncPoint friendshipApprovedSyncPoint=new SimpleResultSyncPoint();
      final IoTProvisioningManager readingThingProvisioningManager=IoTProvisioningManager.getInstanceFor(readingThingConnection);
      final BecameFriendListener becameFriendListener=new BecameFriendListener(){
        @Override public void becameFriend(        BareJid jid,        Presence presence){
          if (jid.equals(dataThingBareJid)) {
            friendshipApprovedSyncPoint.signal();
          }
        }
      }
;
      readingThingProvisioningManager.addBecameFriendListener(becameFriendListener);
      try {
        readingThingProvisioningManager.sendFriendshipRequestIfRequired(dataThingConnection.getUser().asBareJid());
        friendshipApprovedSyncPoint.waitForResult(TIMEOUT);
      }
  finally {
        readingThingProvisioningManager.removeBecameFriendListener(becameFriendListener);
      }
      printStatus("FRIENDSHIP APPROVED - ReadingThing " + readingThingBareJid + " is now a friend of DataThing "+ dataThingBareJid);
    }
  }
;
  private static ThingState actAsDataThing(  XMPPTCPConnection connection) throws XMPPException, SmackException, InterruptedException {
    final String key=StringUtils.randomString(12);
    final String sn=StringUtils.randomString(12);
    Thing dataThing=Thing.builder().setKey(key).setSerialNumber(sn).setManufacturer("IgniteRealtime").setModel("Smack").setVersion("0.1").setMomentaryReadOutRequestHandler(new ThingMomentaryReadOutRequest(){
      @Override public void momentaryReadOutRequest(      ThingMomentaryReadOutResult callback){
        IoTDataField.IntField field=new IntField("timestamp",(int)(System.currentTimeMillis() / 1000));
        callback.momentaryReadOut(Collections.singletonList(field));
      }
    }
).build();
    IoTDiscoveryManager iotDiscoveryManager=IoTDiscoveryManager.getInstanceFor(connection);
    ThingState state=IoTDiscoveryIntegrationTest.registerThing(iotDiscoveryManager,dataThing);
    printStatus("SUCCESS: Thing registered:" + dataThing);
    return state;
  }
  private static void printStatus(  CharSequence status){
    System.out.println(status);
  }
  public static void main(  String[] args) throws Exception {
    if (args.length != 4) {
      throw new IllegalArgumentException();
    }
    iotOwnerApprovesFriendScenario(args[0],args[1],args[2],args[3]);
  }
}
