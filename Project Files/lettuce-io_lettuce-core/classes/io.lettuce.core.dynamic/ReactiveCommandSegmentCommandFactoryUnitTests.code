/** 
 * @author Mark Paluch
 */
@ExtendWith(MockitoExtension.class) class ReactiveCommandSegmentCommandFactoryUnitTests {
  private CodecAwareOutputFactoryResolver outputFactoryResolver=new CodecAwareOutputFactoryResolver(new OutputRegistryCommandOutputFactoryResolver(new OutputRegistry()),StringCodec.UTF8);
  @Test void commandCreationWithTimeoutShouldFail(){
    try {
      createCommand("get",ReactiveWithTimeout.class,String.class,Timeout.class);
      fail("Missing CommandCreationException");
    }
 catch (    CommandCreationException e) {
      assertThat(e).hasMessageContaining("Reactive command methods do not support Timeout parameters");
    }
  }
  @Test void shouldResolveNonStreamingOutput(){
    RedisCommand<?,?,?> command=createCommand("getOne",ReactiveWithTimeout.class,String.class);
    assertThat(command.getOutput()).isNotInstanceOf(StreamingOutput.class);
  }
  @Test void shouldResolveStreamingOutput(){
    RedisCommand<?,?,?> command=createCommand("getMany",ReactiveWithTimeout.class,String.class);
    assertThat(command.getOutput()).isInstanceOf(StreamingOutput.class);
  }
  RedisCommand<?,?,?> createCommand(  String methodName,  Class<?> interfaceClass,  Class<?>... parameterTypes){
    Method method=ReflectionUtils.findMethod(interfaceClass,methodName,parameterTypes);
    CommandMethod commandMethod=DeclaredCommandMethod.create(method);
    AnnotationCommandSegmentFactory segmentFactory=new AnnotationCommandSegmentFactory();
    CommandSegments commandSegments=segmentFactory.createCommandSegments(commandMethod);
    ReactiveCommandSegmentCommandFactory factory=new ReactiveCommandSegmentCommandFactory(commandSegments,commandMethod,new StringCodec(),outputFactoryResolver);
    return factory.createCommand(new Object[]{"foo"});
  }
private static interface ReactiveWithTimeout {
    Publisher<String> get(    String key,    Timeout timeout);
    Mono<String> getOne(    String key);
    Flux<String> getMany(    String key);
  }
}
