/** 
 * Properties provide an easy mechanism for clients to share data. Each property has a String name, and a value that is a Java primitive (int, long, float, double, boolean) or any Serializable object (a Java object is Serializable when it implements the Serializable interface).
 */
public class JivePropertiesExtension implements ExtensionElement {
  /** 
 * Namespace used to store stanza properties.
 */
  public static final String NAMESPACE="http://www.jivesoftware.com/xmlns/xmpp/properties";
  public static final String ELEMENT="properties";
  public static final QName QNAME=new QName(NAMESPACE,ELEMENT);
  private static final Logger LOGGER=Logger.getLogger(JivePropertiesExtension.class.getName());
  private final Map<String,Object> properties;
  public JivePropertiesExtension(){
    properties=new HashMap<>();
  }
  public JivePropertiesExtension(  Map<String,Object> properties){
    this.properties=properties;
  }
  /** 
 * Returns the stanza property with the specified name or <code>null</code> if the property doesn't exist. Property values that were originally primitives will be returned as their object equivalent. For example, an int property will be returned as an Integer, a double as a Double, etc.
 * @param name the name of the property.
 * @return the property, or <code>null</code> if the property doesn't exist.
 */
  public synchronized Object getProperty(  String name){
    if (properties == null) {
      return null;
    }
    return properties.get(name);
  }
  /** 
 * Sets a property with an Object as the value. The value must be Serializable or an IllegalArgumentException will be thrown.
 * @param name the name of the property.
 * @param value the value of the property.
 */
  public synchronized void setProperty(  String name,  Object value){
    if (!(value instanceof Serializable)) {
      throw new IllegalArgumentException("Value must be serializable");
    }
    properties.put(name,value);
  }
  /** 
 * Deletes a property.
 * @param name the name of the property to delete.
 */
  public synchronized void deleteProperty(  String name){
    if (properties == null) {
      return;
    }
    properties.remove(name);
  }
  /** 
 * Returns an unmodifiable collection of all the property names that are set.
 * @return all property names.
 */
  public synchronized Collection<String> getPropertyNames(){
    if (properties == null) {
      return Collections.emptySet();
    }
    return Collections.unmodifiableSet(new HashSet<>(properties.keySet()));
  }
  /** 
 * Returns an unmodifiable map of all properties.
 * @return all properties.
 */
  public synchronized Map<String,Object> getProperties(){
    if (properties == null) {
      return Collections.emptyMap();
    }
    return Collections.unmodifiableMap(new HashMap<>(properties));
  }
  @Override public String getElementName(){
    return ELEMENT;
  }
  @Override public String getNamespace(){
    return NAMESPACE;
  }
  @Override public CharSequence toXML(  org.jivesoftware.smack.packet.XmlEnvironment enclosingNamespace){
    XmlStringBuilder xml=new XmlStringBuilder(this);
    xml.rightAngleBracket();
    for (    String name : getPropertyNames()) {
      Object value=getProperty(name);
      xml.openElement("property");
      xml.element("name",name);
      xml.halfOpenElement("value");
      String type;
      String valueStr;
      if (value instanceof Integer) {
        type="integer";
        valueStr=Integer.toString((Integer)value);
      }
 else       if (value instanceof Long) {
        type="long";
        valueStr=Long.toString((Long)value);
      }
 else       if (value instanceof Float) {
        type="float";
        valueStr=Float.toString((Float)value);
      }
 else       if (value instanceof Double) {
        type="double";
        valueStr=Double.toString((Double)value);
      }
 else       if (value instanceof Boolean) {
        type="boolean";
        valueStr=Boolean.toString((Boolean)value);
      }
 else       if (value instanceof String) {
        type="string";
        valueStr=(String)value;
      }
 else {
        try (ByteArrayOutputStream byteStream=new ByteArrayOutputStream();ObjectOutputStream out=new ObjectOutputStream(byteStream)){
          out.writeObject(value);
          type="java-object";
          valueStr=Base64.encodeToString(byteStream.toByteArray());
        }
 catch (        Exception e) {
          LOGGER.log(Level.SEVERE,"Error encoding java object",e);
          type="java-object";
          valueStr="Serializing error: " + e.getMessage();
        }
      }
      xml.attribute("type",type);
      xml.rightAngleBracket();
      xml.escape(valueStr);
      xml.closeElement("value");
      xml.closeElement("property");
    }
    xml.closeElement(this);
    return xml;
  }
  /** 
 * Return a Jive properties extensions of the given message.
 * @param message the message to return the extension from.
 * @return a Jive properties extension or null.
 * @since 4.2
 */
  public static JivePropertiesExtension from(  Message message){
    return message.getExtension(JivePropertiesExtension.class);
  }
}
