/** 
 * The  {@code DepthFirstSearch} class represents a data type fordetermining the vertices connected to a given source vertex <em>s</em> in an undirected graph. For versions that find the paths, see {@link DepthFirstPaths} and {@link BreadthFirstPaths}. <p> This implementation uses depth-first search. See  {@link NonrecursiveDFS} for a non-recursive version.The constructor takes &Theta;(<em>V</em> + <em>E</em>) time in the worst case, where <em>V</em> is the number of vertices and <em>E</em> is the number of edges. Each instance method takes &Theta;(1) time. It uses &Theta;(<em>V</em>) extra space (not including the graph). <p> For additional documentation, see <a href="https://algs4.cs.princeton.edu/41graph">Section 4.1</a> of <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
 * @author Robert Sedgewick
 * @author Kevin Wayne
 */
public class DepthFirstSearch {
  private boolean[] marked;
  private int count;
  /** 
 * Computes the vertices in graph  {@code G} that areconnected to the source vertex  {@code s}.
 * @param G the graph
 * @param s the source vertex
 * @throws IllegalArgumentException unless {@code 0 <= s < V}
 */
  public DepthFirstSearch(  Graph G,  int s){
    marked=new boolean[G.V()];
    validateVertex(s);
    dfs(G,s);
  }
  private void dfs(  Graph G,  int v){
    count++;
    marked[v]=true;
    for (    int w : G.adj(v)) {
      if (!marked[w]) {
        dfs(G,w);
      }
    }
  }
  /** 
 * Is there a path between the source vertex  {@code s} and vertex {@code v}?
 * @param v the vertex
 * @return {@code true} if there is a path, {@code false} otherwise
 * @throws IllegalArgumentException unless {@code 0 <= v < V}
 */
  public boolean marked(  int v){
    validateVertex(v);
    return marked[v];
  }
  /** 
 * Returns the number of vertices connected to the source vertex  {@code s}.
 * @return the number of vertices connected to the source vertex {@code s}
 */
  public int count(){
    return count;
  }
  private void validateVertex(  int v){
    int V=marked.length;
    if (v < 0 || v >= V)     throw new IllegalArgumentException("vertex " + v + " is not between 0 and "+ (V - 1));
  }
  /** 
 * Unit tests the  {@code DepthFirstSearch} data type.
 * @param args the command-line arguments
 */
  public static void main(  String[] args){
    In in=new In(args[0]);
    Graph G=new Graph(in);
    int s=Integer.parseInt(args[1]);
    DepthFirstSearch search=new DepthFirstSearch(G,s);
    for (int v=0; v < G.V(); v++) {
      if (search.marked(v))       StdOut.print(v + " ");
    }
    StdOut.println();
    if (search.count() != G.V())     StdOut.println("NOT connected");
 else     StdOut.println("connected");
  }
}
