public void updateRenderableRegion(ViewDistance newViewDistance,int newChunkLods,Vector3i newCenter){
  this.viewDistanceSetting=newViewDistance;
  this.center=new Vector3i(delay(center.x,newCenter.x),delay(center.y,newCenter.y),delay(center.z,newCenter.z));
  this.chunkLods=newChunkLods;
  this.nearby.pos=center;
  Vector3i viewDistance=new Vector3i(newViewDistance.getChunkDistance()).div(2);
  Vector3i altViewDistance=viewDistance.add(1 - Math.abs(viewDistance.x % 2),1 - Math.abs(viewDistance.y % 2),1 - Math.abs(viewDistance.z % 2),new Vector3i());
  BlockRegion newPossiblyLoadedRegion=new BlockRegion(newCenter).expand(viewDistance);
  BlockRegion newProbablyLoadedRegion=new BlockRegion(newPossiblyLoadedRegion).expand(-1,-1,-1);
  BlockRegion[] newLodRegions=new BlockRegion[newChunkLods == 0 ? 0 : 1 + newChunkLods];
  while (chunks.size() < newLodRegions.length) {
    chunks.add(new ConcurrentHashMap<>());
  }
  while (chunks.size() > newLodRegions.length) {
    for (    LodChunk chunk : chunks.remove(chunks.size() - 1).values()) {
      chunk.disposeMesh();
    }
  }
  boolean lodRegionChange=newLodRegions.length != lodRegions.length;
  for (int i=0; i < newLodRegions.length; i++) {
    if (i == 0) {
      newLodRegions[i]=new BlockRegion(newPossiblyLoadedRegion);
    }
 else {
      newLodRegions[i]=new BlockRegion(scaleDown(center,i)).expand(altViewDistance);
    }
    Vector3i min=newLodRegions[i].getMin(new Vector3i());
    Vector3i max=newLodRegions[i].getMax(new Vector3i());
    newLodRegions[i].addToMin(-Math.abs(min.x % 2),-Math.abs(min.y % 2),-Math.abs(min.z % 2));
    newLodRegions[i].addToMax(1 - Math.abs(max.x % 2),1 - Math.abs(max.y % 2),1 - Math.abs(max.z % 2));
    if (!lodRegionChange && !newLodRegions[i].equals(lodRegions[i])) {
      lodRegionChange=true;
    }
  }
  if (lodRegionChange || !newProbablyLoadedRegion.equals(probablyLoadedRegion) || !newPossiblyLoadedRegion.equals(possiblyLoadedRegion)) {
    Set<Vector3ic> previouslyRequiredChunks=new HashSet<>(requiredChunks.keySet());
    for (    Vector3ic pos : previouslyRequiredChunks) {
      int scale=requiredChunks.get(pos);
      boolean gone=false;
      boolean increased=false;
      while (scale < newLodRegions.length && !gone && !newLodRegions[scale].contains(scaleDown(pos,scale))) {
        LodChunk chunk=chunks.get(scale).get(new Vector3i(pos));
        if (chunk != null) {
          chunk.disposeMesh();
          chunks.get(scale).remove(new Vector3i(pos));
        }
        gone=((pos.x() | pos.y() | pos.z()) & (1 << scale)) != 0;
        scale++;
        increased=true;
      }
      if (gone || scale >= newLodRegions.length) {
        neededChunks.remove(pos);
        requiredChunks.remove(pos);
      }
 else       if (increased) {
        LodChunk chunk=chunks.get(scale).get(new Vector3i(pos));
        if (chunk != null) {
          requiredChunks.put(new Vector3i(pos),scale);
          chunk.hiddenness=0;
        }
 else {
          requiredChunks.remove(pos);
        }
      }
    }
    for (int scale=0; scale < newLodRegions.length; scale++) {
      for (      Vector3ic pos : newLodRegions[scale]) {
        if (scale == 0 && newProbablyLoadedRegion.contains(pos) || scale == 0 && newPossiblyLoadedRegion.contains(pos) && chunkProvider.isChunkReady(pos) || scale > 0 && newLodRegions[scale - 1].contains(pos.mul(2,new Vector3i()))) {
          continue;
        }
        Vector3i globalPos=pos.mul(1 << scale,new Vector3i());
        Integer previousScale=requiredChunks.get(globalPos);
        if (previousScale == null || previousScale > scale) {
          addChunk(globalPos,scale);
        }
      }
    }
  }
  lodRegions=newLodRegions;
  probablyLoadedRegion=newProbablyLoadedRegion;
  possiblyLoadedRegion=newPossiblyLoadedRegion;
}
