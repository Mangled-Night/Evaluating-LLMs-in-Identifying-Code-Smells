/** 
 * Create a new watchdog that adds to new connections to the supplied  {@link ChannelGroup} and establishes a new{@link Channel} when disconnected, while reconnect is true. The socketAddressSupplier can supply the reconnect address.
 * @param reconnectDelay reconnect delay, must not be {@code null}
 * @param clientOptions client options for the current connection, must not be {@code null}
 * @param bootstrap Configuration for new channels, must not be {@code null}
 * @param timer Timer used for delayed reconnect, must not be {@code null}
 * @param reconnectWorkers executor group for reconnect tasks, must not be {@code null}
 * @param socketAddressSupplier the socket address supplier to obtain an address for reconnection, may be {@code null}
 * @param reconnectionListener the reconnection listener, must not be {@code null}
 * @param connectionFacade the connection facade, must not be {@code null}
 * @param eventBus Event bus to emit reconnect events.
 * @param endpoint must not be {@code null}
 */
public ConnectionWatchdog(Delay reconnectDelay,ClientOptions clientOptions,Bootstrap bootstrap,Timer timer,EventExecutorGroup reconnectWorkers,Mono<SocketAddress> socketAddressSupplier,ReconnectionListener reconnectionListener,ConnectionFacade connectionFacade,EventBus eventBus,Endpoint endpoint){
  LettuceAssert.notNull(reconnectDelay,"Delay must not be null");
  LettuceAssert.notNull(clientOptions,"ClientOptions must not be null");
  LettuceAssert.notNull(bootstrap,"Bootstrap must not be null");
  LettuceAssert.notNull(timer,"Timer must not be null");
  LettuceAssert.notNull(reconnectWorkers,"ReconnectWorkers must not be null");
  LettuceAssert.notNull(socketAddressSupplier,"SocketAddressSupplier must not be null");
  LettuceAssert.notNull(reconnectionListener,"ReconnectionListener must not be null");
  LettuceAssert.notNull(connectionFacade,"ConnectionFacade must not be null");
  LettuceAssert.notNull(eventBus,"EventBus must not be null");
  LettuceAssert.notNull(endpoint,"Endpoint must not be null");
  this.reconnectDelay=reconnectDelay;
  this.bootstrap=bootstrap;
  this.timer=timer;
  this.reconnectWorkers=reconnectWorkers;
  this.reconnectionListener=reconnectionListener;
  this.reconnectSchedulerSync=new AtomicBoolean(false);
  this.eventBus=eventBus;
  this.redisUri=(String)bootstrap.config().attrs().get(ConnectionBuilder.REDIS_URI);
  this.epid=endpoint.getId();
  Mono<SocketAddress> wrappedSocketAddressSupplier=socketAddressSupplier.doOnNext(addr -> remoteAddress=addr).onErrorResume(t -> {
    if (logger.isDebugEnabled()) {
      logger.warn("Cannot retrieve current address from socketAddressSupplier: " + t.toString() + ", reusing cached address "+ remoteAddress,t);
    }
 else {
      logger.warn("Cannot retrieve current address from socketAddressSupplier: " + t.toString() + ", reusing cached address "+ remoteAddress);
    }
    return Mono.just(remoteAddress);
  }
);
  this.reconnectionHandler=new ReconnectionHandler(clientOptions,bootstrap,wrappedSocketAddressSupplier,timer,reconnectWorkers,connectionFacade);
  resetReconnectDelay();
}
