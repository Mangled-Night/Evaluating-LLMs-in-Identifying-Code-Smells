/** 
 * Return a  {@link ResolvableType} for the specified {@link Class}, using the full generic type information for assignability checks. For example:  {@code ResolvableType.forClass(MyArrayList.class)}.
 * @param sourceClass the source class ({@code null} is semantically equivalent to {@code Object.class} for typical usecases here}
 * @return a {@link ResolvableType} for the specified class
 * @see #forClass(Class,Class)
 * @see #forClassWithGenerics(Class,Class)
 */
public static ResolvableType forClass(Class<?> sourceClass){
  return new ResolvableType(sourceClass);
}
/** 
 * Return a  {@link ResolvableType} for the specified {@link Class} with a given implementation. For example:{@code ResolvableType.forClass(List.class, MyArrayList.class)}.
 * @param sourceClass the source class (must not be {@code null}
 * @param implementationClass the implementation class
 * @return a {@link ResolvableType} for the specified class backed by the given implementation class
 * @see #forClass(Class)
 * @see #forClassWithGenerics(Class,Class)
 */
public static ResolvableType forClass(Class<?> sourceClass,Class<?> implementationClass){
  LettuceAssert.notNull(sourceClass,"Source class must not be null");
  ResolvableType asType=forType(implementationClass).as(sourceClass);
  return (asType == NONE ? forType(sourceClass) : asType);
}
