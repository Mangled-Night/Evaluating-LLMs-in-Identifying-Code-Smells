/** 
 * heartbeat check for mysql connections
 * @author wuzhih
 */
public class ConnectionHeartBeatHandler implements ResponseHandler {
  private static final Logger LOGGER=LoggerFactory.getLogger(ConnectionHeartBeatHandler.class);
  protected final ReentrantLock lock=new ReentrantLock();
  private final ConcurrentHashMap<Long,HeartBeatCon> allCons=new ConcurrentHashMap<Long,HeartBeatCon>();
  public void doHeartBeat(  BackendConnection conn,  String sql){
    if (LOGGER.isDebugEnabled()) {
      LOGGER.debug("do heartbeat for con " + conn);
    }
    try {
      HeartBeatCon hbCon=new HeartBeatCon(conn);
      boolean notExist=(allCons.putIfAbsent(hbCon.conn.getId(),hbCon) == null);
      if (notExist) {
        conn.setResponseHandler(this);
        conn.query(sql);
      }
    }
 catch (    Exception e) {
      executeException(conn,e);
    }
  }
  /** 
 * remove timeout connections
 */
  public void abandTimeOuttedConns(){
    if (allCons.isEmpty()) {
      return;
    }
    Collection<BackendConnection> abandCons=new LinkedList<BackendConnection>();
    long curTime=System.currentTimeMillis();
    Iterator<Entry<Long,HeartBeatCon>> itors=allCons.entrySet().iterator();
    while (itors.hasNext()) {
      HeartBeatCon hbCon=itors.next().getValue();
      if (hbCon.timeOutTimestamp < curTime) {
        abandCons.add(hbCon.conn);
        itors.remove();
      }
    }
    if (!abandCons.isEmpty()) {
      for (      BackendConnection con : abandCons) {
        try {
          con.close("heartbeat timeout ");
        }
 catch (        Exception e) {
          LOGGER.warn("close err:" + e);
        }
      }
    }
  }
  @Override public void connectionAcquired(  BackendConnection conn){
  }
  @Override public void connectionError(  Throwable e,  BackendConnection conn){
  }
  @Override public void errorResponse(  byte[] data,  BackendConnection conn){
    removeFinished(conn);
    ErrorPacket err=new ErrorPacket();
    err.read(data);
    LOGGER.warn("errorResponse " + err.errno + " "+ new String(err.message));
    conn.release();
  }
  @Override public void okResponse(  byte[] ok,  BackendConnection conn){
    boolean executeResponse=conn.syncAndExcute();
    if (executeResponse) {
      removeFinished(conn);
      conn.release();
    }
  }
  @Override public void rowResponse(  byte[] row,  BackendConnection conn){
  }
  @Override public void rowEofResponse(  byte[] eof,  BackendConnection conn){
    removeFinished(conn);
    conn.release();
  }
  private void executeException(  BackendConnection c,  Throwable e){
    removeFinished(c);
    LOGGER.warn("executeException   ",e);
    c.close("heatbeat exception:" + e);
  }
  private void removeFinished(  BackendConnection con){
    Long id=((BackendConnection)con).getId();
    this.allCons.remove(id);
  }
  @Override public void writeQueueAvailable(){
  }
  @Override public void connectionClose(  BackendConnection conn,  String reason){
    removeFinished(conn);
    LOGGER.warn("connection closed " + conn + " reason:"+ reason);
  }
  @Override public void fieldEofResponse(  byte[] header,  List<byte[]> fields,  byte[] eof,  BackendConnection conn){
    if (LOGGER.isDebugEnabled()) {
      LOGGER.debug("received field eof  from " + conn);
    }
  }
}
