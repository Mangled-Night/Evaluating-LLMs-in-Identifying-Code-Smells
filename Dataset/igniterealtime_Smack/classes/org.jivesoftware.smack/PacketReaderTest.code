public class PacketReaderTest extends SmackTestCase {
  private int counter;
  private final Object mutex=new Object();
  /** 
 * Constructor for PacketReaderTest.
 * @param arg0 TODO javadoc me please
 */
  public PacketReaderTest(  String arg0){
    super(arg0);
    resetCounter();
  }
  private void resetCounter(){
synchronized (mutex) {
      counter=0;
    }
  }
  public void incCounter(){
synchronized (mutex) {
      counter++;
    }
  }
  private int valCounter(){
    int val;
synchronized (mutex) {
      val=counter;
    }
    return val;
  }
  /** 
 * Verify that when Smack receives a "not implemented IQ" answers with an IQ packet with error code 501.
 */
  public void testIQNotImplemented(){
    IQ iqPacket=new IQ(){
      public String getChildElementXML(){
        return "<query xmlns=\"my:ns:test\"/>";
      }
    }
;
    iqPacket.setTo(getFullJID(1));
    iqPacket.setType(IQ.Type.get);
    StanzaCollector collector=getConnection(0).createStanzaCollector(new PacketIDFilter(iqPacket.getStanzaId()));
    getConnection(0).sendStanza(iqPacket);
    IQ response=(IQ)collector.nextResult(SmackConfiguration.getPacketReplyTimeout());
    if (response == null) {
      fail("No response from the other user.");
    }
    assertEquals("The received IQ is not of type ERROR",IQ.Type.error,response.getType());
    assertEquals("The error code is not 501",501,response.getError().getCode());
    collector.cancel();
  }
  /** 
 * Tests that PacketReader adds new listeners and also removes them correctly.
 */
  public void testRemoveListener(){
    PacketListener listener=new PacketListener(){
      public void processStanza(      Packet packet){
      }
    }
;
    int listenersSize=getConnection(0).getPacketListeners().size();
    getConnection(0).addAsyncPacketListener(listener,new MockPacketFilter(true));
    assertEquals("Listener was not added",listenersSize + 1,getConnection(0).getPacketListeners().size());
    Message msg=new Message(getConnection(0).getUser(),Message.Type.normal);
    getConnection(1).sendStanza(msg);
    getConnection(0).removeAsyncPacketListener(listener);
    assertEquals("Listener was not removed",listenersSize,getConnection(0).getPacketListeners().size());
  }
  /** 
 * Checks that parser still works when receiving an error text with no description.
 */
  public void testErrorWithNoText(){
    Message packet=new Message();
    packet.setFrom(getFullJID(0));
    packet.setTo(getFullJID(1));
    packet.setBody("aloha");
    getConnection(1).addAsyncPacketListener(new PacketListener(){
      public void processStanza(      Packet packet){
        System.out.println(new Date() + " " + packet);
        Message message=new Message(packet.getFrom());
        message.setFrom(getFullJID(1));
        message.setBody("HELLO");
        getConnection(1).sendStanza(message);
      }
    }
,new StanzaTypeFilter(Message.class));
    StanzaCollector collector=getConnection(0).createStanzaCollector(new FromMatchesFilter(getFullJID(1)));
    getConnection(0).sendStanza(packet);
    assertNotNull("No message was received",collector.nextResult(1000));
    packet=new Message();
    packet.setFrom(getFullJID(0));
    packet.setTo(getFullJID(1));
    packet.setBody("aloha");
    packet.setError(new XMPPError(XMPPError.Condition.feature_not_implemented,null));
    getConnection(0).sendStanza(packet);
    assertNotNull("No message was received",collector.nextResult(1000));
  }
  /** 
 * Tests that PacketReader adds new listeners and also removes them correctly.
 */
  public void testFiltersRemotion(){
    resetCounter();
    int repeat=10;
    for (int j=0; j < repeat; j++) {
      PacketListener listener0=new PacketListener(){
        public void processStanza(        Packet packet){
          System.out.println("Packet Captured");
          incCounter();
        }
      }
;
      PacketFilter pf0=new PacketFilter(){
        public boolean accept(        Packet packet){
          System.out.println("Packet Filtered");
          incCounter();
          return true;
        }
      }
;
      PacketListener listener1=new PacketListener(){
        public void processStanza(        Packet packet){
          System.out.println("Packet Captured");
          incCounter();
        }
      }
;
      PacketFilter pf1=new PacketFilter(){
        public boolean accept(        Packet packet){
          System.out.println("Packet Filtered");
          incCounter();
          return true;
        }
      }
;
      getConnection(0).addAsyncPacketListener(listener0,pf0);
      getConnection(1).addAsyncPacketListener(listener1,pf1);
      Message msg0=new Message(getConnection(0).getUser(),Message.Type.normal);
      Message msg1=new Message(getConnection(1).getUser(),Message.Type.normal);
      for (int i=0; i < 5; i++) {
        getConnection(1).sendStanza(msg0);
        getConnection(0).sendStanza(msg1);
      }
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
      getConnection(0).removeAsyncPacketListener(listener0);
      getConnection(1).removeAsyncPacketListener(listener1);
      try {
        Thread.sleep(300);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
      for (int i=0; i < 10; i++) {
        getConnection(0).sendStanza(msg1);
        getConnection(1).sendStanza(msg0);
      }
      try {
        Thread.sleep(100);
      }
 catch (      InterruptedException e) {
        e.printStackTrace();
      }
    }
    System.out.println(valCounter());
    assertEquals(valCounter(),repeat * 2 * 10);
  }
  protected int getMaxConnections(){
    return 2;
  }
}
