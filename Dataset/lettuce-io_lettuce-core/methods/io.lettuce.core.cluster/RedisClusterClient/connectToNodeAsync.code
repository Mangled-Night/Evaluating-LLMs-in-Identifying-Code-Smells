/** 
 * Create a connection to a redis socket address.
 * @param codec Use this codec to encode/decode keys and values, must not be {@code null}
 * @param nodeId the nodeId
 * @param clusterWriter global cluster writer
 * @param socketAddressSupplier supplier for the socket address
 * @param < K > Key type
 * @param < V > Value type
 * @return A new connection
 */
<K,V>ConnectionFuture<StatefulRedisConnection<K,V>> connectToNodeAsync(RedisCodec<K,V> codec,String nodeId,RedisChannelWriter clusterWriter,Mono<SocketAddress> socketAddressSupplier){
  assertNotNull(codec);
  assertNotEmpty(initialUris);
  LettuceAssert.notNull(socketAddressSupplier,"SocketAddressSupplier must not be null");
  ClusterNodeEndpoint endpoint=new ClusterNodeEndpoint(getClusterClientOptions(),getResources(),clusterWriter);
  RedisChannelWriter writer=endpoint;
  if (CommandExpiryWriter.isSupported(getClusterClientOptions())) {
    writer=new CommandExpiryWriter(writer,getClusterClientOptions(),getResources());
  }
  if (CommandListenerWriter.isSupported(getCommandListeners())) {
    writer=new CommandListenerWriter(writer,getCommandListeners());
  }
  StatefulRedisConnectionImpl<K,V> connection=newStatefulRedisConnection(writer,endpoint,codec,getFirstUri().getTimeout());
  ConnectionFuture<StatefulRedisConnection<K,V>> connectionFuture=connectStatefulAsync(connection,endpoint,getFirstUri(),socketAddressSupplier,() -> new CommandHandler(getClusterClientOptions(),getResources(),endpoint));
  return connectionFuture.whenComplete((conn,throwable) -> {
    if (throwable != null) {
      connection.closeAsync();
    }
  }
);
}
@Override public <K,V>ConnectionFuture<StatefulRedisConnection<K,V>> connectToNodeAsync(RedisCodec<K,V> codec,SocketAddress socketAddress){
  return RedisClusterClient.this.connectToNodeAsync(codec,socketAddress.toString(),null,Mono.just(socketAddress));
}
