@Override public void renderOverlay(){
  if (config.getRendering().getDebug().isRenderEntityBoundingBoxes()) {
    GL33.glDepthFunc(GL33.GL_ALWAYS);
    Vector3f cameraPosition=worldRenderer.getActiveCamera().getPosition();
    Vector3f worldPos=new Vector3f();
    Vector3f worldPositionCameraSpace=new Vector3f();
    worldPos.sub(cameraPosition,worldPositionCameraSpace);
    Matrix4f matrixCameraSpace=new Matrix4f().translationRotateScale(worldPositionCameraSpace,new Quaternionf(),1.0f);
    Matrix4f modelViewMatrix=new Matrix4f(worldRenderer.getActiveCamera().getViewMatrix()).mul(matrixCameraSpace);
    material.setMatrix4("projectionMatrix",worldRenderer.getActiveCamera().getProjectionMatrix());
    material.setMatrix4("modelViewMatrix",modelViewMatrix,true);
    int index=0;
    meshData.reallocate(0,0);
    meshData.indices.rewind();
    meshData.position.rewind();
    meshData.color0.rewind();
    Vector3f worldPosition=new Vector3f();
    Quaternionf worldRot=new Quaternionf();
    Matrix4f transform=new Matrix4f();
    AABBf bounds=new AABBf(0,0,0,0,0,0);
    for (    EntityRef entity : entityManager.getEntitiesWith(LocationComponent.class)) {
      LocationComponent location=entity.getComponent(LocationComponent.class);
      location.getWorldPosition(worldPosition);
      location.getWorldRotation(worldRot);
      BoxShapeComponent boxShapeComponent=entity.getComponent(BoxShapeComponent.class);
      if (boxShapeComponent != null) {
        bounds.set(0,0,0,0,0,0);
        bounds.expand(new Vector3f(boxShapeComponent.extents).div(2.0f));
        transform.translationRotateScale(worldPosition,worldRot,location.getWorldScale());
        bounds.transform(transform);
        index=addRenderBound(meshData,bounds,index);
      }
      CapsuleShapeComponent capsuleComponent=entity.getComponent(CapsuleShapeComponent.class);
      if (capsuleComponent != null) {
        bounds.set(0,0,0,0,0,0);
        bounds.expand(new Vector3f(capsuleComponent.radius,capsuleComponent.height / 2.0f,capsuleComponent.radius).div(2.0f));
        transform.translationRotateScale(worldPosition,worldRot,location.getWorldScale());
        bounds.transform(transform);
        index=addRenderBound(meshData,bounds,index);
      }
      CylinderShapeComponent cylinderShapeComponent=entity.getComponent(CylinderShapeComponent.class);
      if (cylinderShapeComponent != null) {
        bounds.set(0,0,0,0,0,0);
        bounds.expand(new Vector3f(cylinderShapeComponent.radius,cylinderShapeComponent.height / 2.0f,cylinderShapeComponent.radius).div(2.0f));
        transform.translationRotateScale(worldPosition,worldRot,location.getWorldScale());
        bounds.transform(transform);
        index=addRenderBound(meshData,bounds,index);
      }
      SphereShapeComponent sphereShapeComponent=entity.getComponent(SphereShapeComponent.class);
      if (sphereShapeComponent != null) {
        bounds.set(0,0,0,0,0,0);
        bounds.expand(new Vector3f(sphereShapeComponent.radius).div(2.0f));
        transform.translationRotateScale(worldPosition,worldRot,location.getWorldScale());
        bounds.transform(transform);
        index=addRenderBound(meshData,bounds,index);
      }
    }
    material.enable();
    mesh.reload(meshData);
    mesh.render();
    GL33.glDepthFunc(GL33.GL_LEQUAL);
  }
}
