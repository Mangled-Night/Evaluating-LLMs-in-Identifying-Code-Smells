/** 
 * @author coderczp-2014-12-8
 */
public class RowDataSorter extends RowDataPacketSorter {
  private volatile int total;
  private volatile int size;
  private volatile HeapItf heap;
  private volatile RowDataCmp cmp;
  private volatile boolean hasBuild;
  public RowDataSorter(  OrderCol[] orderCols){
    super(orderCols);
    this.cmp=new RowDataCmp(orderCols);
  }
  public synchronized void setLimit(  int start,  int size){
    if (start < 0) {
      start=0;
    }
    if (size <= 0) {
      this.total=this.size=Integer.MAX_VALUE;
    }
 else {
      this.total=start + size;
      this.size=size;
    }
    this.heap=new MaxHeap(cmp,total);
  }
  @Override public synchronized boolean addRow(  RowDataPacket row){
    if (heap.getData().size() < total) {
      heap.add(row);
      return true;
    }
    if (heap.getData().size() == total && hasBuild == false) {
      heap.buildHeap();
      hasBuild=true;
    }
    return heap.addIfRequired(row);
  }
  @Override public List<RowDataPacket> getSortedResult(){
    final List<RowDataPacket> data=heap.getData();
    if (data.size() < 2) {
      return data;
    }
    if (total - size > data.size()) {
      return Collections.emptyList();
    }
    if (!hasBuild) {
      heap.buildHeap();
    }
    heap.heapSort(this.size);
    return heap.getData();
  }
  public RowDataCmp getCmp(){
    return cmp;
  }
}
