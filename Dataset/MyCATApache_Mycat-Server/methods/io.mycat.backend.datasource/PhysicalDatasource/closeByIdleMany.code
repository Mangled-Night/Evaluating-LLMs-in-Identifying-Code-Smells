/** 
 * @param ildeCloseCount 首先，从已创建的连接中选择本次心跳需要关闭的空闲连接数（由当前连接连接数-减去配置的最小连接数。 然后依次关闭这些连接。由于连接空闲心跳检测与业务是同时并发的，在心跳关闭阶段，可能有连接被使用，导致需要关闭的空闲连接数减少. 所以每次关闭新连接时，先判断当前空闲连接数是否大于配置的最少空闲连接，如果为否，则结束本次关闭空闲连接操作。 该方法修改之前： 首先从ConnMap中获取 ildeCloseCount 个连接，然后关闭；在关闭中，可能又有连接被使用，导致可能多关闭一些链接， 导致相对频繁的创建新连接和关闭连接 该方法修改之后： ildeCloseCount 为预期要关闭的连接 使用循环操作，首先在关闭之前，先再一次判断是否需要关闭连接，然后每次从ConnMap中获取一个空闲连接，然后进行关闭 edit by dingw at 2017.06.16
 */
private void closeByIdleMany(int ildeCloseCount){
  LOGGER.info("too many ilde cons ,close some for datasouce  " + name);
  List<BackendConnection> readyCloseCons=new ArrayList<BackendConnection>(ildeCloseCount);
  for (  ConQueue queue : conMap.getAllConQueue()) {
    readyCloseCons.addAll(queue.getIdleConsToClose(ildeCloseCount));
    if (readyCloseCons.size() >= ildeCloseCount) {
      break;
    }
  }
  for (  BackendConnection idleCon : readyCloseCons) {
    if (idleCon.isBorrowed()) {
      LOGGER.warn("find idle con is using " + idleCon);
    }
    idleCon.close("too many idle con");
  }
}
