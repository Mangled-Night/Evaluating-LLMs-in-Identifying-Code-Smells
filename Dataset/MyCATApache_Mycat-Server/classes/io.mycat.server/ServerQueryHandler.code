/** 
 * @author mycat
 */
public class ServerQueryHandler implements FrontendQueryHandler {
  private static final Logger LOGGER=LoggerFactory.getLogger(ServerQueryHandler.class);
  private final ServerConnection source;
  protected Boolean readOnly;
  public void setReadOnly(  Boolean readOnly){
    this.readOnly=readOnly;
  }
  public ServerQueryHandler(  ServerConnection source){
    this.source=source;
  }
  @Override public void query(  String sql){
    ServerConnection c=this.source;
    if (LOGGER.isDebugEnabled()) {
      LOGGER.debug(new StringBuilder().append(c).append(sql).toString());
    }
    int rs=ServerParse.parse(sql);
    int sqlType=rs & 0xff;
switch (sqlType) {
case ServerParse.EXPLAIN:
      ExplainHandler.handle(sql,c,rs >>> 8);
    break;
case ServerParse.EXPLAIN2:
  Explain2Handler.handle(sql,c,rs >>> 8);
break;
case ServerParse.COMMAND:
CommandHandler.handle(sql,c,16);
break;
case ServerParse.SET:
SetHandler.handle(sql,c,rs >>> 8);
break;
case ServerParse.SHOW:
ShowHandler.handle(sql,c,rs >>> 8);
break;
case ServerParse.SELECT:
SelectHandler.handle(sql,c,rs >>> 8);
break;
case ServerParse.START:
StartHandler.handle(sql,c,rs >>> 8);
break;
case ServerParse.BEGIN:
BeginHandler.handle(sql,c);
break;
case ServerParse.SAVEPOINT:
SavepointHandler.handle(sql,c);
break;
case ServerParse.KILL:
KillHandler.handle(sql,rs >>> 8,c);
break;
case ServerParse.KILL_QUERY:
LOGGER.warn(new StringBuilder().append("Unsupported command:").append(sql).toString());
c.writeErrMessage(ErrorCode.ER_UNKNOWN_COM_ERROR,"Unsupported command");
break;
case ServerParse.USE:
UseHandler.handle(sql,c,rs >>> 8);
break;
case ServerParse.COMMIT:
c.commit();
break;
case ServerParse.ROLLBACK:
c.rollback();
break;
case ServerParse.HELP:
LOGGER.warn(new StringBuilder().append("Unsupported command:").append(sql).toString());
c.writeErrMessage(ErrorCode.ER_SYNTAX_ERROR,"Unsupported command");
break;
case ServerParse.MYSQL_CMD_COMMENT:
c.write(c.writeToBuffer(OkPacket.OK,c.allocate()));
break;
case ServerParse.MYSQL_COMMENT:
c.write(c.writeToBuffer(OkPacket.OK,c.allocate()));
break;
case ServerParse.LOAD_DATA_INFILE_SQL:
if (RouteService.isHintSql(sql) > -1) {
c.execute(sql,ServerParse.LOAD_DATA_INFILE_SQL);
}
 else {
c.loadDataInfileStart(sql);
}
break;
case ServerParse.MIGRATE:
{
try {
MigrateHandler.handle(sql,c);
}
 catch (Throwable e) {
e.printStackTrace();
String msg="Mycat is not connected to zookeeper!!\n";
msg+="Please start zookeeper and restart mycat so that this mycat can temporarily execute the migration command.If other mycat does not connect to this zookeeper, they will not be able to perceive changes in the migration task.\n";
msg+="After starting zookeeper,you can command tas follow:\n\nmigrate -table=schema.test -add=dn2,dn3 -force=true\n\nto perform the migration.\n";
LOGGER.error(e.getMessage());
LOGGER.error(msg);
c.writeErrMessage(ErrorCode.ER_UNKNOWN_ERROR,msg);
}
break;
}
case ServerParse.LOCK:
c.lockTable(sql);
break;
case ServerParse.UNLOCK:
c.unLockTable(sql);
break;
default :
if (readOnly) {
LOGGER.warn(new StringBuilder().append("User readonly:").append(sql).toString());
c.writeErrMessage(ErrorCode.ER_USER_READ_ONLY,"User readonly");
break;
}
c.execute(sql,rs & 0xff);
}
switch (sqlType) {
case ServerParse.SELECT:
case ServerParse.DELETE:
case ServerParse.UPDATE:
case ServerParse.INSERT:
case ServerParse.COMMAND:
break;
default :
c.setExecuteSql(null);
}
}
}
