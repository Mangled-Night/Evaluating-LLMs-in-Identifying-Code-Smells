@Override protected void doReload(SkeletalMeshData newData){
  try {
    GameThread.synch(() -> {
      this.data=newData;
      if (this.disposalAction.vao == 0) {
        this.disposalAction.vao=GL30.glGenVertexArrays();
        this.disposalAction.vbo=GL30.glGenBuffers();
        this.disposalAction.ebo=GL30.glGenBuffers();
      }
      GL30.glBindVertexArray(this.disposalAction.vao);
      GL30.glBindBuffer(GL30.GL_ARRAY_BUFFER,this.disposalAction.vbo);
      GL30.glEnableVertexAttribArray(StandardMeshData.VERTEX_INDEX);
      GL30.glVertexAttribPointer(StandardMeshData.VERTEX_INDEX,3,GL30.GL_FLOAT,false,VERTEX_NORMAL_SIZE,0);
      GL30.glEnableVertexAttribArray(StandardMeshData.NORMAL_INDEX);
      GL30.glVertexAttribPointer(StandardMeshData.NORMAL_INDEX,3,GL30.GL_FLOAT,false,VERTEX_NORMAL_SIZE,VERTEX_SIZE);
      GL30.glEnableVertexAttribArray(StandardMeshData.UV0_INDEX);
      GL30.glVertexAttribPointer(StandardMeshData.UV0_INDEX,2,GL30.GL_FLOAT,false,UV_SIZE,(long)VERTEX_NORMAL_SIZE * newData.getVertexCount());
      int payloadSize=(UV_SIZE + VERTEX_SIZE + NORMAL_SIZE) * newData.getVertexCount();
      ByteBuffer buffer=BufferUtils.createByteBuffer(payloadSize);
      buffer.position(newData.getVertexCount() * VERTEX_NORMAL_SIZE);
      for (      Vector2f uv : newData.getUVs()) {
        buffer.putFloat(uv.x);
        buffer.putFloat(uv.y);
      }
      buffer.flip();
      GL30.glBufferData(GL30.GL_ARRAY_BUFFER,buffer,GL30.GL_DYNAMIC_DRAW);
      IntBuffer indexBuffer=BufferUtils.createIntBuffer(newData.getIndices().size());
      indexBuffer.put(newData.getIndices().toArray());
      indexBuffer.flip();
      GL30.glBindBuffer(GL30.GL_ELEMENT_ARRAY_BUFFER,this.disposalAction.ebo);
      GL30.glBufferData(GL30.GL_ELEMENT_ARRAY_BUFFER,indexBuffer,GL30.GL_STATIC_DRAW);
      GL30.glBindVertexArray(0);
    }
);
  }
 catch (  InterruptedException e) {
    logger.error("Failed to reload {}",getUrn(),e);
  }
}
