/** 
 * Creates an FBO, allocating the underlying FrameBuffer and the desired attachments on the GPU. Check FBO create(String title, Dimensions dimensions, Type type ...) for more.
 * @param config A FboConfig object that stores information used for creating FBO.
 * @return The resuting FBO object wrapping a FrameBuffer and its attachments. Use getStatus() before use to verify completeness.
 */
public static FBO create(FboConfig config){
  return FBO.create(config.getName(),config.getDimensions(),config.getType(),config.hasDepthBuffer(),config.hasNormalBuffer(),config.hasLightBuffer(),config.hasStencilBuffer());
}
/** 
 * Creates an FBO, allocating the underlying FrameBuffer and the desired attachments on the GPU. Also checks the resulting FBO for completeness and logs errors and their error codes as necessary. Callers must check the returned FBO's status (see getStatus()). Only FBO with a Status.COMPLETE should be used. In what follows, the GL constants between parenthesis represent the (internal format, data type, filtering type) of a buffer. An FBO of Type.DEFAULT will have a 32 bit color buffer attached to it. (GL_RGBA, GL11.GL_UNSIGNED_BYTE, GL_LINEAR) An FBO of Type.HDR will have a 64 bit color buffer attached to it. (GL_RGBA, GL_HALF_FLOAT_ARB, GL_LINEAR) An FBO of Type.NO_COLOR will have -no- color buffer attached to it. If the creation process is successful (Status.COMPLETE) GPU memory has been allocated for the FrameBuffer and its attachments. However, the content of the attachments is undefined.
 * @param fboName A SimpleUri that can be used to uniquely identify the FBO.
 * @param dimensions A Dimensions object wrapping width and height of the FBO.
 * @param type Can be Type.DEFAULT, Type.HDR or Type.NO_COLOR
 * @param useDepthBuffer If true the FBO will have a 24 bit depth buffer attached to it. (GL_DEPTH_COMPONENT24, GL_UNSIGNED_INT, GL_NEAREST)
 * @param useNormalBuffer If true the FBO will have a 32 bit normals buffer attached to it. (GL_RGBA, GL_UNSIGNED_BYTE, GL_LINEAR)
 * @param useLightBuffer If true the FBO will have 32/64 bit light buffer attached to it, depending if Type is DEFAULT/HDR.(GL_RGBA/GL_RGBA16F_ARB, GL_UNSIGNED_BYTE/GL_HALF_FLOAT_ARB, GL_LINEAR)
 * @param useStencilBuffer If true the depth buffer will also have an 8 bit Stencil buffer associated with it.(GL_DEPTH24_STENCIL8_EXT, GL_UNSIGNED_INT_24_8_EXT, GL_NEAREST)
 * @return The resuting FBO object wrapping a FrameBuffer and its attachments. Use getStatus() before use to verify completeness.
 */
public static FBO create(SimpleUri fboName,Dimensions dimensions,Type type,boolean useDepthBuffer,boolean useNormalBuffer,boolean useLightBuffer,boolean useStencilBuffer){
  FBO fbo=new FBO(fboName,dimensions.width,dimensions.height);
  fbo.fboId=GL30.glGenFramebuffers();
  GL30.glBindFramebuffer(GL30.GL_FRAMEBUFFER,fbo.fboId);
  if (type != Type.NO_COLOR) {
    createColorBuffer(fbo,dimensions,type);
  }
  if (useNormalBuffer) {
    createNormalsBuffer(fbo,dimensions);
  }
  if (useLightBuffer) {
    createLightBuffer(fbo,dimensions,type);
  }
  if (useDepthBuffer) {
    createDepthBuffer(fbo,dimensions,useStencilBuffer);
  }
  GL11.glBindTexture(GL11.GL_TEXTURE_2D,0);
  IntBuffer bufferIds=BufferUtils.createIntBuffer(3);
  if (type != Type.NO_COLOR) {
    bufferIds.put(GL30.GL_COLOR_ATTACHMENT0);
  }
  if (useNormalBuffer) {
    bufferIds.put(GL30.GL_COLOR_ATTACHMENT1);
  }
  if (useLightBuffer) {
    bufferIds.put(GL30.GL_COLOR_ATTACHMENT2);
  }
  bufferIds.flip();
  if (bufferIds.limit() == 0) {
    GL11.glReadBuffer(GL11.GL_NONE);
    GL20.glDrawBuffers(GL11.GL_NONE);
  }
 else {
    GL20.glDrawBuffers(bufferIds);
  }
  verifyCompleteness(fboName,type,fbo);
  GL30.glBindFramebuffer(GL30.GL_FRAMEBUFFER,0);
  return fbo;
}
