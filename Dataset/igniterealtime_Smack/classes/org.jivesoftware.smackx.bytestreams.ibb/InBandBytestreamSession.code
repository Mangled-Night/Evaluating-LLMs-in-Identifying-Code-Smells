/** 
 * InBandBytestreamSession class represents an In-Band Bytestream session. <p> In-band bytestreams are bidirectional and this session encapsulates the streams for both directions. <p> Note that closing the In-Band Bytestream session will close both streams. If both streams are closed individually the session will be closed automatically once the second stream is closed. Use the  {@link #setCloseBothStreamsEnabled(boolean)} method if both streams should be closedautomatically if one of them is closed.
 * @author Henning Staib
 */
public class InBandBytestreamSession implements BytestreamSession {
  private static final Logger LOGGER=Logger.getLogger(InBandBytestreamSession.class.getName());
  static final String UNEXPECTED_IBB_SEQUENCE="Unexpected IBB sequence";
  private final XMPPConnection connection;
  private final Open byteStreamRequest;
  private IBBInputStream inputStream;
  private IBBOutputStream outputStream;
  private Jid remoteJID;
  private boolean closeBothStreamsEnabled=false;
  private boolean isClosed=false;
  /** 
 * Constructor.
 * @param connection the XMPP connection
 * @param byteStreamRequest the In-Band Bytestream open request for this session
 * @param remoteJID JID of the remote peer
 */
  protected InBandBytestreamSession(  XMPPConnection connection,  Open byteStreamRequest,  Jid remoteJID){
    this.connection=connection;
    this.byteStreamRequest=byteStreamRequest;
    this.remoteJID=remoteJID;
switch (byteStreamRequest.getStanza()) {
case IQ:
      this.inputStream=new IQIBBInputStream();
    this.outputStream=new IQIBBOutputStream();
  break;
case MESSAGE:
this.inputStream=new MessageIBBInputStream();
this.outputStream=new MessageIBBOutputStream();
break;
}
}
@Override public InputStream getInputStream(){
return this.inputStream;
}
@Override public OutputStream getOutputStream(){
return this.outputStream;
}
@Override public int getReadTimeout(){
return this.inputStream.readTimeout;
}
@Override public void setReadTimeout(int timeout){
if (timeout < 0) {
throw new IllegalArgumentException("Timeout must be >= 0");
}
this.inputStream.readTimeout=timeout;
}
/** 
 * Returns whether both streams should be closed automatically if one of the streams is closed. Default is <code>false</code>.
 * @return <code>true</code> if both streams will be closed if one of the streams is closed,<code>false</code> if both streams can be closed independently.
 */
public boolean isCloseBothStreamsEnabled(){
return closeBothStreamsEnabled;
}
/** 
 * Sets whether both streams should be closed automatically if one of the streams is closed. Default is <code>false</code>.
 * @param closeBothStreamsEnabled <code>true</code> if both streams should be closed if one ofthe streams is closed, <code>false</code> if both streams should be closed independently
 */
public void setCloseBothStreamsEnabled(boolean closeBothStreamsEnabled){
this.closeBothStreamsEnabled=closeBothStreamsEnabled;
}
@Override public void close() throws IOException {
closeByLocal(true);
closeByLocal(false);
}
/** 
 * This method is invoked if a request to close the In-Band Bytestream has been received.
 * @param closeRequest the close request from the remote peer
 * @throws NotConnectedException if the XMPP connection is not connected.
 * @throws InterruptedException if the calling thread was interrupted.
 */
protected void closeByPeer(Close closeRequest) throws NotConnectedException, InterruptedException {
this.inputStream.closeInternal();
this.inputStream.cleanup();
this.outputStream.closeInternal(false);
IQ confirmClose=IQ.createResultIQ(closeRequest);
this.connection.sendStanza(confirmClose);
}
/** 
 * This method is invoked if one of the streams has been closed locally, if an error occurred locally or if the whole session should be closed.
 * @param in do we want to close the Input- or OutputStream?
 * @throws IOException if an error occurs while sending the close request
 */
protected synchronized void closeByLocal(boolean in) throws IOException {
if (this.isClosed) {
return;
}
if (this.closeBothStreamsEnabled) {
this.inputStream.closeInternal();
this.outputStream.closeInternal(true);
}
 else {
if (in) {
this.inputStream.closeInternal();
}
 else {
this.outputStream.closeInternal(true);
}
}
if (this.inputStream.isClosed && this.outputStream.isClosed) {
this.isClosed=true;
Close close=new Close(this.byteStreamRequest.getSessionID());
close.setTo(this.remoteJID);
try {
connection.sendIqRequestAndWaitForResponse(close);
}
 catch (Exception e) {
IOException ioException=new IOException();
ioException.initCause(e);
throw ioException;
}
this.inputStream.cleanup();
InBandBytestreamManager.getByteStreamManager(this.connection).getSessions().remove(byteStreamRequest.getSessionID());
}
}
/** 
 * IBBInputStream class is the base implementation of an In-Band Bytestream input stream. Subclasses of this input stream must provide a stanza listener along with a stanza filter to collect the In-Band Bytestream data packets.
 */
private abstract class IBBInputStream extends InputStream {
private final StanzaListener dataPacketListener;
protected final BlockingQueue<DataPacketExtension> dataQueue=new LinkedBlockingQueue<DataPacketExtension>();
private byte[] buffer;
private int bufferPointer=-1;
private UInt16 expectedSeq=UInt16.MIN_VALUE;
private boolean isClosed=false;
private boolean closeInvoked=false;
private int readTimeout=0;
/** 
 * Constructor.
 */
protected IBBInputStream(){
this.dataPacketListener=getDataPacketListener();
connection.addSyncStanzaListener(this.dataPacketListener,getDataPacketFilter());
}
/** 
 * Returns the stanza listener that processes In-Band Bytestream data packets.
 * @return the data stanza listener
 */
protected abstract StanzaListener getDataPacketListener();
/** 
 * Returns the stanza filter that accepts In-Band Bytestream data packets.
 * @return the data stanza filter
 */
protected abstract StanzaFilter getDataPacketFilter();
@Override public synchronized int read() throws IOException {
checkClosed();
if (bufferPointer == -1 || bufferPointer >= buffer.length) {
if (!loadBuffer()) {
return -1;
}
}
return buffer[bufferPointer++] & 0xff;
}
@Override public synchronized int read(byte[] b,int off,int len) throws IOException {
if (b == null) {
throw new NullPointerException();
}
 else if ((off < 0) || (off > b.length) || (len < 0)|| ((off + len) > b.length)|| ((off + len) < 0)) {
throw new IndexOutOfBoundsException();
}
 else if (len == 0) {
return 0;
}
checkClosed();
if (bufferPointer == -1 || bufferPointer >= buffer.length) {
if (!loadBuffer()) {
return -1;
}
}
int bytesAvailable=buffer.length - bufferPointer;
if (len > bytesAvailable) {
len=bytesAvailable;
}
System.arraycopy(buffer,bufferPointer,b,off,len);
bufferPointer+=len;
return len;
}
@Override public synchronized int read(byte[] b) throws IOException {
return read(b,0,b.length);
}
/** 
 * This method blocks until a data stanza is received, the stream is closed or the current thread is interrupted.
 * @return <code>true</code> if data was received, otherwise <code>false</code>
 * @throws IOException if data packets are out of sequence
 */
private synchronized boolean loadBuffer() throws IOException {
DataPacketExtension data=null;
try {
if (this.readTimeout == 0) {
while (data == null) {
if (isClosed && this.dataQueue.isEmpty()) {
  return false;
}
data=this.dataQueue.poll(1000,TimeUnit.MILLISECONDS);
}
}
 else {
data=this.dataQueue.poll(this.readTimeout,TimeUnit.MILLISECONDS);
if (data == null) {
throw new SocketTimeoutException();
}
}
}
 catch (InterruptedException e) {
Thread.currentThread().interrupt();
return false;
}
final UInt16 dataSeq=data.getSeq();
if (!expectedSeq.equals(dataSeq)) {
InBandBytestreamSession.this.close();
String message=UNEXPECTED_IBB_SEQUENCE + " " + dataSeq+ " received, expected "+ expectedSeq;
throw new IOException(message);
}
expectedSeq=dataSeq.incrementedByOne();
buffer=data.getDecodedData();
bufferPointer=0;
return true;
}
/** 
 * Checks if this stream is closed and throws an IOException if necessary
 * @throws IOException if stream is closed and no data should be read anymore
 */
private void checkClosed() throws IOException {
if (closeInvoked) {
this.dataQueue.clear();
throw new IOException("Stream is closed");
}
}
@Override public boolean markSupported(){
return false;
}
@Override public void close() throws IOException {
if (closeInvoked) {
return;
}
this.closeInvoked=true;
InBandBytestreamSession.this.closeByLocal(true);
}
/** 
 * This method sets the close flag and removes the data stanza listener.
 */
private void closeInternal(){
if (isClosed) {
return;
}
isClosed=true;
}
/** 
 * Invoked if the session is closed.
 */
private void cleanup(){
connection.removeSyncStanzaListener(this.dataPacketListener);
}
}
/** 
 * IQIBBInputStream class implements IBBInputStream to be used with IQ stanzas encapsulating the data packets.
 */
private class IQIBBInputStream extends IBBInputStream {
@Override protected StanzaListener getDataPacketListener(){
return new StanzaListener(){
private UInt16 expectedSequence=UInt16.MIN_VALUE;
@Override public void processStanza(Stanza packet) throws NotConnectedException, InterruptedException {
final Data dataIq=(Data)packet;
DataPacketExtension data=dataIq.getDataPacketExtension();
final UInt16 seq=data.getSeq();
if (!expectedSequence.equals(seq)) {
String descriptiveEnTest=UNEXPECTED_IBB_SEQUENCE + " " + seq+ " received, expected "+ expectedSequence;
StanzaError stanzaError=StanzaError.getBuilder().setCondition(StanzaError.Condition.unexpected_request).setDescriptiveEnText(descriptiveEnTest).build();
IQ unexpectedRequest=IQ.createErrorResponse(dataIq,stanzaError);
connection.sendStanza(unexpectedRequest);
try {
  close();
}
 catch (IOException e) {
  LOGGER.log(Level.FINER,"Could not close session, because of IOException. Close reason: " + descriptiveEnTest);
}
return;
}
if (data.getDecodedData() == null) {
IQ badRequest=IQ.createErrorResponse((IQ)packet,StanzaError.Condition.bad_request);
connection.sendStanza(badRequest);
return;
}
expectedSequence=seq.incrementedByOne();
dataQueue.offer(data);
IQ confirmData=IQ.createResultIQ((IQ)packet);
connection.sendStanza(confirmData);
}
}
;
}
@Override protected StanzaFilter getDataPacketFilter(){
return new AndFilter(new StanzaTypeFilter(Data.class),new IBBDataPacketFilter());
}
}
/** 
 * MessageIBBInputStream class implements IBBInputStream to be used with message stanzas encapsulating the data packets.
 */
private class MessageIBBInputStream extends IBBInputStream {
@Override protected StanzaListener getDataPacketListener(){
return new StanzaListener(){
@Override public void processStanza(Stanza packet){
DataPacketExtension data=packet.getExtension(DataPacketExtension.class);
if (data.getDecodedData() == null) {
return;
}
dataQueue.offer(data);
}
}
;
}
@Override protected StanzaFilter getDataPacketFilter(){
return new AndFilter(new StanzaTypeFilter(Message.class),new IBBDataPacketFilter());
}
}
/** 
 * IBBDataPacketFilter class filters all packets from the remote peer of this session, containing an In-Band Bytestream data stanza extension whose session ID matches this sessions ID.
 */
private class IBBDataPacketFilter implements StanzaFilter {
@Override public boolean accept(Stanza packet){
if (!packet.getFrom().equals(remoteJID)) {
return false;
}
DataPacketExtension data;
if (packet instanceof Data) {
data=((Data)packet).getDataPacketExtension();
}
 else {
data=packet.getExtension(DataPacketExtension.class);
if (data == null) {
return false;
}
}
if (!data.getSessionID().equals(byteStreamRequest.getSessionID())) {
return false;
}
return true;
}
}
/** 
 * IBBOutputStream class is the base implementation of an In-Band Bytestream output stream. Subclasses of this output stream must provide a method to send data over XMPP stream.
 */
private abstract class IBBOutputStream extends OutputStream {
protected final byte[] buffer;
protected int bufferPointer=0;
protected UInt16 seq=UInt16.from(0);
protected boolean isClosed=false;
/** 
 * Constructor.
 */
private IBBOutputStream(){
this.buffer=new byte[byteStreamRequest.getBlockSize()];
}
/** 
 * Writes the given data stanza to the XMPP stream.
 * @param data the data packet
 * @throws IOException if an I/O error occurred while sending or if the stream is closed
 * @throws NotConnectedException if the XMPP connection is not connected.
 * @throws InterruptedException if the calling thread was interrupted.
 */
protected abstract void writeToXML(DataPacketExtension data) throws IOException, NotConnectedException, InterruptedException ;
@Override public synchronized void write(int b) throws IOException {
if (this.isClosed) {
throw new IOException("Stream is closed");
}
if (bufferPointer >= buffer.length) {
flushBuffer();
}
buffer[bufferPointer++]=(byte)b;
}
@Override public synchronized void write(byte[] b,int off,int len) throws IOException {
if (b == null) {
throw new NullPointerException();
}
 else if ((off < 0) || (off > b.length) || (len < 0)|| ((off + len) > b.length)|| ((off + len) < 0)) {
throw new IndexOutOfBoundsException();
}
 else if (len == 0) {
return;
}
if (this.isClosed) {
throw new IOException("Stream is closed");
}
if (len >= buffer.length) {
writeOut(b,off,buffer.length);
write(b,off + buffer.length,len - buffer.length);
}
 else {
writeOut(b,off,len);
}
}
@Override public synchronized void write(byte[] b) throws IOException {
write(b,0,b.length);
}
/** 
 * Fills the buffer with the given data and sends it over the XMPP stream if the buffers capacity has been reached. This method is only called from this class so it is assured that the amount of data to send is <= buffer capacity
 * @param b the data
 * @param off the data
 * @param len the number of bytes to write
 * @throws IOException if an I/O error occurred while sending or if the stream is closed
 */
private synchronized void writeOut(byte[] b,int off,int len) throws IOException {
if (this.isClosed) {
throw new IOException("Stream is closed");
}
int available=0;
if (len > buffer.length - bufferPointer) {
available=buffer.length - bufferPointer;
System.arraycopy(b,off,buffer,bufferPointer,available);
bufferPointer+=available;
flushBuffer();
}
System.arraycopy(b,off + available,buffer,bufferPointer,len - available);
bufferPointer+=len - available;
}
@Override public synchronized void flush() throws IOException {
if (this.isClosed) {
throw new IOException("Stream is closed");
}
flushBuffer();
}
private synchronized void flushBuffer() throws IOException {
if (bufferPointer == 0) {
return;
}
String enc=Base64.encodeToString(buffer,0,bufferPointer);
DataPacketExtension data=new DataPacketExtension(byteStreamRequest.getSessionID(),this.seq,enc);
try {
writeToXML(data);
}
 catch (InterruptedException|NotConnectedException e) {
IOException ioException=new IOException();
ioException.initCause(e);
throw ioException;
}
bufferPointer=0;
seq=seq.incrementedByOne();
}
@Override public void close() throws IOException {
if (isClosed) {
return;
}
InBandBytestreamSession.this.closeByLocal(false);
}
/** 
 * Sets the close flag and optionally flushes the stream.
 * @param flush if <code>true</code> flushes the stream
 */
protected void closeInternal(boolean flush){
if (this.isClosed) {
return;
}
this.isClosed=true;
try {
if (flush) {
flushBuffer();
}
}
 catch (IOException e) {
}
}
}
/** 
 * IQIBBOutputStream class implements IBBOutputStream to be used with IQ stanzas encapsulating the data packets.
 */
private class IQIBBOutputStream extends IBBOutputStream {
@Override protected synchronized void writeToXML(DataPacketExtension data) throws IOException {
IQ iq=new Data(data);
iq.setTo(remoteJID);
try {
connection.sendIqRequestAndWaitForResponse(iq);
}
 catch (Exception e) {
if (!this.isClosed) {
InBandBytestreamSession.this.close();
IOException ioException=new IOException();
ioException.initCause(e);
throw ioException;
}
}
}
}
/** 
 * MessageIBBOutputStream class implements IBBOutputStream to be used with message stanzas encapsulating the data packets.
 */
private class MessageIBBOutputStream extends IBBOutputStream {
@Override protected synchronized void writeToXML(DataPacketExtension data) throws NotConnectedException, InterruptedException {
Message message=StanzaBuilder.buildMessage().to(remoteJID).addExtension(data).build();
connection.sendStanza(message);
}
}
/** 
 * Process IQ stanza.
 * @param data TODO javadoc me please
 * @throws NotConnectedException if the XMPP connection is not connected.
 * @throws InterruptedException if the calling thread was interrupted.
 * @throws NotLoggedInException if the XMPP connection is not authenticated.
 */
public void processIQPacket(Data data) throws NotConnectedException, InterruptedException, NotLoggedInException {
inputStream.dataPacketListener.processStanza(data);
}
}
