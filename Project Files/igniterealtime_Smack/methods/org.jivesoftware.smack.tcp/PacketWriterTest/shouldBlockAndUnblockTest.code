/** 
 * Make sure that stanza writer does block once the queue reaches {@link PacketWriter#QUEUE_SIZE} and that{@link PacketWriter#sendStanza(org.jivesoftware.smack.tcp.packet.Packet)} does unblock after theinterrupt.
 * @throws InterruptedException if the calling thread was interrupted.
 * @throws BrokenBarrierException in case of a broken barrier.
 * @throws NotConnectedException if the XMPP connection is not connected.
 * @throws XmppStringprepException if the provided string is invalid.
 * @throws SecurityException if there was a security violation.
 * @throws NoSuchFieldException if there is no such field.
 * @throws IllegalAccessException if there was an illegal access.
 * @throws IllegalArgumentException if an illegal argument was given.
 */
@Test public void shouldBlockAndUnblockTest() throws InterruptedException, BrokenBarrierException, NotConnectedException, XmppStringprepException, NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException {
  XMPPTCPConnection connection=new XMPPTCPConnection("user","pass","example.org");
  Field readerField=AbstractXMPPConnection.class.getDeclaredField("reader");
  readerField.setAccessible(true);
  readerField.set(connection,DUMMY_READER);
  final PacketWriter pw=connection.packetWriter;
  BlockingStringWriter blockingStringWriter=new BlockingStringWriter();
  connection.setWriter(blockingStringWriter);
  connection.packetWriter.init();
  for (int i=0; i < XMPPTCPConnection.PacketWriter.QUEUE_SIZE + 1; i++) {
    pw.sendStreamElement(StanzaBuilder.buildMessage().build());
  }
  final CyclicBarrier barrier=new CyclicBarrier(2);
  final AtomicReference<Exception> unexpectedThreadExceptionReference=new AtomicReference<>();
  final AtomicReference<Exception> expectedThreadExceptionReference=new AtomicReference<>();
  shutdown=false;
  prematureUnblocked=false;
  Thread t=new Thread(new Runnable(){
    @Override public void run(){
      try {
        barrier.await();
        pw.sendStreamElement(StanzaBuilder.buildMessage().build());
        if (!shutdown) {
          prematureUnblocked=true;
        }
      }
 catch (      InterruptedException|SmackException.NotConnectedException e) {
        expectedThreadExceptionReference.set(e);
      }
catch (      BrokenBarrierException e) {
        unexpectedThreadExceptionReference.set(e);
      }
      try {
        barrier.await();
      }
 catch (      InterruptedException|BrokenBarrierException e) {
        unexpectedThreadExceptionReference.set(e);
      }
    }
  }
);
  t.start();
  barrier.await();
  Thread.sleep(250);
  pw.shutdown(false);
  shutdown=true;
  barrier.await();
  t.join(60000);
  Exception unexpectedThreadException=unexpectedThreadExceptionReference.get();
  try {
    if (prematureUnblocked) {
      String failureMessage="Should not unblock before the thread got shutdown.";
      if (unexpectedThreadException != null) {
        String stacktrace=ExceptionUtil.getStackTrace(unexpectedThreadException);
        failureMessage+=" Unexpected thread exception thrown: " + unexpectedThreadException + "\n"+ stacktrace;
      }
      fail(failureMessage);
    }
 else     if (unexpectedThreadException != null) {
      String stacktrace=ExceptionUtil.getStackTrace(unexpectedThreadException);
      fail("Unexpected thread exception: " + unexpectedThreadException + "\n"+ stacktrace);
    }
    assertNotNull(expectedThreadExceptionReference.get(),"Did not encounter expected exception on sendStreamElement()");
  }
  finally {
    blockingStringWriter.unblock();
  }
}
