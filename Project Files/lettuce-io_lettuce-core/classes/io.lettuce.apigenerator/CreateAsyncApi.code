/** 
 * Create async API based on the templates.
 * @author Mark Paluch
 */
class CreateAsyncApi {
  public static final Set<String> KEEP_METHOD_RESULT_TYPE=LettuceSets.unmodifiableSet("shutdown","debugOom","debugSegfault","digest","close","isOpen","BaseRedisCommands.reset","getStatefulConnection","setAutoFlushCommands","flushCommands");
  /** 
 * Mutate type comment.
 * @return
 */
  Function<String,String> commentMutator(){
    return s -> s.replaceAll("\\$\\{intent\\}","Asynchronous executed commands") + "* @generated by " + getClass().getName()+ "\r\n ";
  }
  /** 
 * Mutate type to async result.
 * @return
 */
  Function<MethodDeclaration,Type> methodTypeMutator(){
    return method -> CompilationUnitFactory.createParametrizedType("RedisFuture",method.getType().toString());
  }
  /** 
 * Supply additional imports.
 * @return
 */
  Supplier<List<String>> importSupplier(){
    return () -> Collections.singletonList("io.lettuce.core.RedisFuture");
  }
  @ParameterizedTest @MethodSource("arguments") void createInterface(  String argument) throws Exception {
    createFactory(argument).createInterface();
  }
  static List<String> arguments(){
    return Arrays.asList(Constants.TEMPLATE_NAMES);
  }
  private CompilationUnitFactory createFactory(  String templateName){
    String targetName=templateName.replace("Commands","AsyncCommands");
    File templateFile=new File(Constants.TEMPLATES,"io/lettuce/core/api/" + templateName + ".java");
    String targetPackage;
    if (templateName.contains("RedisSentinel")) {
      targetPackage="io.lettuce.core.sentinel.api.async";
    }
 else {
      targetPackage="io.lettuce.core.api.async";
    }
    CompilationUnitFactory factory=new CompilationUnitFactory(templateFile,Constants.SOURCES,targetPackage,targetName,commentMutator(),methodTypeMutator(),methodDeclaration -> true,importSupplier(),null,Function.identity());
    factory.keepMethodSignaturesFor(KEEP_METHOD_RESULT_TYPE);
    return factory;
  }
}
