/** 
 * Builder entry points for  {@link AclSetuserArgs}.
 */
public static class Builder {
  /** 
 * Utility constructor.
 */
  private Builder(){
  }
  /** 
 * Creates new  {@link AclSetuserArgs} and set user active.
 * @return new {@link AclSetuserArgs} and set user active.
 * @see AclSetuserArgs#on()
 */
  public static AclSetuserArgs on(){
    return new AclSetuserArgs().on();
  }
  /** 
 * Creates new  {@link AclSetuserArgs} and set user inactive.
 * @return new {@link AclSetuserArgs} and set user inactive.
 * @see AclSetuserArgs#off()
 */
  public static AclSetuserArgs off(){
    return new AclSetuserArgs().off();
  }
  /** 
 * Creates new  {@link AclSetuserArgs} and adds accessible key pattern.
 * @param keyPattern accessible key pattern
 * @return new {@link AclSetuserArgs} and adds accessible key pattern.
 * @see AclSetuserArgs#keyPattern(String)
 */
  public static AclSetuserArgs keyPattern(  String keyPattern){
    return new AclSetuserArgs().keyPattern(keyPattern);
  }
  /** 
 * Creates new  {@link AclSetuserArgs} and allows the user to access all the keys.
 * @return new {@link AclSetuserArgs} and allows the user to access all the keys.
 * @see AclSetuserArgs#allKeys()
 */
  public static AclSetuserArgs allKeys(){
    return new AclSetuserArgs().allKeys();
  }
  /** 
 * Creates new  {@link AclSetuserArgs} and removes all the key patterns from the list of key patterns the user canaccess.
 * @return new {@link AclSetuserArgs} and removes all the key patterns from the list of key patterns the user canaccess.
 * @see AclSetuserArgs#resetKeys()
 */
  public static AclSetuserArgs resetKeys(){
    return new AclSetuserArgs().resetKeys();
  }
  /** 
 * Creates new  {@link AclSetuserArgs} and adds accessible channel pattern.
 * @param channelPattern accessible channel pattern
 * @return new {@link AclSetuserArgs} and adds accessible channel pattern.
 * @see AclSetuserArgs#channelPattern(String)
 */
  public static AclSetuserArgs channelPattern(  String channelPattern){
    return new AclSetuserArgs().channelPattern(channelPattern);
  }
  /** 
 * Creates new  {@link AclSetuserArgs} and allows the user to access all the Pub/Sub channels.
 * @return new {@link AclSetuserArgs} and allows the user to access all the Pub/Sub channels.
 * @see AclSetuserArgs#allChannels()
 */
  public static AclSetuserArgs allChannels(){
    return new AclSetuserArgs().allChannels();
  }
  /** 
 * Creates new  {@link AclSetuserArgs} and removes all channel patterns from the list of Pub/Sub channel patterns theuser can access.
 * @return new {@link AclSetuserArgs} and removes all channel patterns from the list of Pub/Sub channel patterns theuser can access.
 * @see AclSetuserArgs#resetChannels()
 */
  public static AclSetuserArgs resetChannels(){
    return new AclSetuserArgs().resetChannels();
  }
  /** 
 * Creates new  {@link AclSetuserArgs} and adds this command to the list of the commands the user can call.
 * @param command accessible command
 * @return new {@link AclSetuserArgs} and adds this command to the list of the commands the user can call.
 * @see AclSetuserArgs#addCommand(CommandType)
 */
  public static AclSetuserArgs addCommand(  CommandType command){
    return new AclSetuserArgs().addCommand(command);
  }
  /** 
 * Creates new  {@link AclSetuserArgs} and adds the specified command to the list of the commands the user can execute.
 * @param command accessible command
 * @param subCommand accessible subcommand
 * @return new {@link AclSetuserArgs} and adds the specified command to the list of the commands the user can execute.
 * @see AclSetuserArgs#addCommand(CommandType,ProtocolKeyword)
 */
  public static AclSetuserArgs addCommand(  CommandType command,  ProtocolKeyword subCommand){
    return new AclSetuserArgs().addCommand(command,subCommand);
  }
  /** 
 * Creates new  {@link AclSetuserArgs} and adds all the commands there are in the server.
 * @return new {@link AclSetuserArgs} and adds all the commands there are in the server.
 * @see AclSetuserArgs#allCommands()
 */
  public static AclSetuserArgs allCommands(){
    return new AclSetuserArgs().allCommands();
  }
  /** 
 * Creates new  {@link AclSetuserArgs} and removes this command to the list of the commands the user can call.
 * @param command inaccessible command
 * @return new {@link AclSetuserArgs} and removes this command to the list of the commands the user can call.
 * @see AclSetuserArgs#removeCommand(CommandType)
 */
  public static AclSetuserArgs removeCommand(  CommandType command){
    return new AclSetuserArgs().removeCommand(command);
  }
  /** 
 * Creates new  {@link AclSetuserArgs} and removes the specified command to the list of the commands the user canexecute.
 * @param command inaccessible command
 * @param subCommand inaccessible subcommand
 * @return new {@link AclSetuserArgs} and removes the specified command to the list of the commands the user canexecute.
 * @see AclSetuserArgs#removeCommand(CommandType,ProtocolKeyword)
 */
  public static AclSetuserArgs removeCommand(  CommandType command,  ProtocolKeyword subCommand){
    return new AclSetuserArgs().removeCommand(command,subCommand);
  }
  /** 
 * Creates new  {@link AclSetuserArgs} and removes all the commands the user can execute.
 * @return new {@link AclSetuserArgs} and removes all the commands the user can execute.
 * @see AclSetuserArgs#noCommands()
 */
  public static AclSetuserArgs noCommands(){
    return new AclSetuserArgs().noCommands();
  }
  /** 
 * Creates new  {@link AclSetuserArgs} and adds all the commands in the specified category to the list of commands theuser is able to execute.
 * @param category specified category
 * @return new {@link AclSetuserArgs} and adds all the commands in the specified category to the list of commands theuser is able to execute.
 * @see AclSetuserArgs#addCategory(AclCategory)
 */
  public static AclSetuserArgs addCategory(  AclCategory category){
    return new AclSetuserArgs().addCategory(category);
  }
  /** 
 * Creates new  {@link AclSetuserArgs} and removes all the commands in the specified category to the list of commands theuser is able to execute.
 * @param category specified category
 * @return new {@link AclSetuserArgs} and removes all the commands in the specified category to the list of commands theuser is able to execute.
 * @see AclSetuserArgs#removeCategory(AclCategory)
 */
  public static AclSetuserArgs removeCategory(  AclCategory category){
    return new AclSetuserArgs().removeCategory(category);
  }
  /** 
 * Creates new  {@link AclSetuserArgs} and sets the user as a "no password".
 * @return new {@link AclSetuserArgs} and sets the user as a "no password".
 * @see AclSetuserArgs#nopass()
 */
  public static AclSetuserArgs nopass(){
    return new AclSetuserArgs().nopass();
  }
  /** 
 * Creates new  {@link AclSetuserArgs} and sets the user as having no associated passwords.
 * @return new {@link AclSetuserArgs} and sets the user as having no associated passwords.
 * @see AclSetuserArgs#resetpass()
 */
  public static AclSetuserArgs resetpass(){
    return new AclSetuserArgs().resetpass();
  }
  /** 
 * Creates new  {@link AclSetuserArgs} and adds the specified clear text password as an hashed password in the list ofthe users passwords.
 * @param password clear text password
 * @return new {@link AclSetuserArgs} and adds the specified clear text password as an hashed password in the list ofthe users passwords.
 * @see AclSetuserArgs#addPassword(String)
 */
  public static AclSetuserArgs addPassword(  String password){
    return new AclSetuserArgs().addPassword(password);
  }
  /** 
 * Creates new  {@link AclSetuserArgs} and adds the specified hashed password to the list of user passwords.
 * @param hashedPassword hashed password
 * @return new {@link AclSetuserArgs} and adds the specified hashed password to the list of user passwords.
 * @see AclSetuserArgs#addHashedPassword(String)
 */
  public static AclSetuserArgs addHashedPassword(  String hashedPassword){
    return new AclSetuserArgs().addHashedPassword(hashedPassword);
  }
  /** 
 * Creates new  {@link AclSetuserArgs} and removes the specified clear text password as an hashed password in the list ofthe users passwords.
 * @param password clear text password
 * @return new {@link AclSetuserArgs} and removes the specified clear text password as an hashed password in the list ofthe users passwords.
 * @see AclSetuserArgs#removePassword(String)
 */
  public static AclSetuserArgs removePassword(  String password){
    return new AclSetuserArgs().removePassword(password);
  }
  /** 
 * Creates new  {@link AclSetuserArgs} and removes the specified hashed password to the list of user passwords.
 * @param hashedPassword hashed password
 * @return new {@link AclSetuserArgs} and removes the specified hashed password to the list of user passwords.
 * @see AclSetuserArgs#removeHashedPassword(String)
 */
  public static AclSetuserArgs removeHashedPassword(  String hashedPassword){
    return new AclSetuserArgs().removeHashedPassword(hashedPassword);
  }
  /** 
 * Creates new  {@link AclSetuserArgs} and removes any capability from the user.
 * @return new {@link AclSetuserArgs} and removes any capability from the user.
 * @see AclSetuserArgs#reset()
 */
  public static AclSetuserArgs reset(){
    return new AclSetuserArgs().reset();
  }
}
/** 
 * Builder entry points for  {@link BitFieldArgs}.
 */
public static class Builder {
  /** 
 * Utility constructor.
 */
  private Builder(){
  }
  /** 
 * Create a new  {@code GET} subcommand.
 * @param bitFieldType the bit field type, must not be {@code null}.
 * @param offset bitfield offset
 * @return a new {@code GET} subcommand for the given {@code bitFieldType} and {@code offset}.
 */
  public static BitFieldArgs get(  BitFieldType bitFieldType,  int offset){
    return new BitFieldArgs().get(bitFieldType,offset);
  }
  /** 
 * Create a new  {@code GET} subcommand.
 * @param bitFieldType the bit field type, must not be {@code null}.
 * @param offset bitfield offset, must not be {@code null}.
 * @return a new {@code GET} subcommand for the given {@code bitFieldType} and {@code offset}.
 * @since 4.3
 */
  public static BitFieldArgs get(  BitFieldType bitFieldType,  Offset offset){
    return new BitFieldArgs().get(bitFieldType,offset);
  }
  /** 
 * Create a new  {@code SET} subcommand.
 * @param bitFieldType the bit field type, must not be {@code null}.
 * @param offset bitfield offset
 * @param value the value
 * @return a new {@code SET} subcommand for the given {@code bitFieldType},  {@code offset} and {@code value}.
 */
  public static BitFieldArgs set(  BitFieldType bitFieldType,  int offset,  long value){
    return new BitFieldArgs().set(bitFieldType,offset,value);
  }
  /** 
 * Create a new  {@code SET} subcommand.
 * @param bitFieldType the bit field type, must not be {@code null}.
 * @param offset bitfield offset, must not be {@code null}.
 * @param value the value
 * @return a new {@code SET} subcommand for the given {@code bitFieldType},  {@code offset} and {@code value}.
 * @since 4.3
 */
  public static BitFieldArgs set(  BitFieldType bitFieldType,  Offset offset,  long value){
    return new BitFieldArgs().set(bitFieldType,offset,value);
  }
  /** 
 * Create a new  {@code INCRBY} subcommand.
 * @param bitFieldType the bit field type, must not be {@code null}.
 * @param offset bitfield offset
 * @param value the value
 * @return a new {@code INCRBY} subcommand for the given {@code bitFieldType},  {@code offset} and {@code value} .
 */
  public static BitFieldArgs incrBy(  BitFieldType bitFieldType,  int offset,  long value){
    return new BitFieldArgs().incrBy(bitFieldType,offset,value);
  }
  /** 
 * Create a new  {@code INCRBY} subcommand.
 * @param bitFieldType the bit field type, must not be {@code null}.
 * @param offset bitfield offset, must not be {@code null}.
 * @param value the value
 * @return a new {@code INCRBY} subcommand for the given {@code bitFieldType},  {@code offset} and {@code value} .
 * @since 4.3
 */
  public static BitFieldArgs incrBy(  BitFieldType bitFieldType,  Offset offset,  long value){
    return new BitFieldArgs().incrBy(bitFieldType,offset,value);
  }
  /** 
 * Adds a new  {@code OVERFLOW} subcommand.
 * @param overflowType type of overflow, must not be {@code null}.
 * @return a new {@code OVERFLOW} subcommand for the given {@code overflowType}.
 */
  public static BitFieldArgs overflow(  OverflowType overflowType){
    return new BitFieldArgs().overflow(overflowType);
  }
}
/** 
 * Builder for  {@link ClientOptions}.
 */
public static class Builder {
  private boolean autoReconnect=DEFAULT_AUTO_RECONNECT;
  private boolean cancelCommandsOnReconnectFailure=DEFAULT_CANCEL_CMD_RECONNECT_FAIL;
  private DecodeBufferPolicy decodeBufferPolicy=DecodeBufferPolicies.ratio(DEFAULT_BUFFER_USAGE_RATIO);
  private DisconnectedBehavior disconnectedBehavior=DEFAULT_DISCONNECTED_BEHAVIOR;
  private boolean pingBeforeActivateConnection=DEFAULT_PING_BEFORE_ACTIVATE_CONNECTION;
  private ProtocolVersion protocolVersion;
  private boolean publishOnScheduler=DEFAULT_PUBLISH_ON_SCHEDULER;
  private int requestQueueSize=DEFAULT_REQUEST_QUEUE_SIZE;
  private Charset scriptCharset=DEFAULT_SCRIPT_CHARSET;
  private SocketOptions socketOptions=DEFAULT_SOCKET_OPTIONS;
  private SslOptions sslOptions=DEFAULT_SSL_OPTIONS;
  private boolean suspendReconnectOnProtocolFailure=DEFAULT_SUSPEND_RECONNECT_PROTO_FAIL;
  private TimeoutOptions timeoutOptions=DEFAULT_TIMEOUT_OPTIONS;
  protected Builder(){
  }
  /** 
 * Enables or disables auto reconnection on connection loss. Defaults to  {@code true}. See {@link #DEFAULT_AUTO_RECONNECT}.
 * @param autoReconnect true/false
 * @return {@code this}
 */
  public Builder autoReconnect(  boolean autoReconnect){
    this.autoReconnect=autoReconnect;
    return this;
  }
  /** 
 * Allows cancelling queued commands in case a reconnect fails.Defaults to  {@code false}. See {@link #DEFAULT_CANCEL_CMD_RECONNECT_FAIL}. <b>This flag is deprecated and should not be used as it can lead to race conditions and protocol offsets. The reason is that it internally calls reset() which causes a protocol offset.</b> See  {@link StatefulConnection#reset}
 * @param cancelCommandsOnReconnectFailure true/false
 * @return {@code this}
 * @deprecated since 6.2, to be removed with 7.0. This feature is unsafe and may cause protocol offsets if true (i.e.Redis commands are completed with previous command values).
 */
  @Deprecated public Builder cancelCommandsOnReconnectFailure(  boolean cancelCommandsOnReconnectFailure){
    this.cancelCommandsOnReconnectFailure=cancelCommandsOnReconnectFailure;
    return this;
  }
  /** 
 * Buffer usage ratio for  {@link io.lettuce.core.protocol.CommandHandler}. This ratio controls how often bytes are discarded during decoding. In particular, when buffer usage reaches  {@code bufferUsageRatio / bufferUsageRatio + 1}. E.g. setting  {@code bufferUsageRatio} to {@literal 3}, will discard read bytes once the buffer usage reaches 75 percent. See  {@link #DEFAULT_BUFFER_USAGE_RATIO}.
 * @param bufferUsageRatio the buffer usage ratio. Must be between {@code 0} and {@code 2^31-1}, typically a value between 1 and 10 representing 50% to 90%.
 * @return {@code this}
 * @since 5.2
 * @deprecated since 6.0 in favor of {@link DecodeBufferPolicy}.
 */
  @Deprecated public Builder bufferUsageRatio(  int bufferUsageRatio){
    this.decodeBufferPolicy=DecodeBufferPolicies.ratio(bufferUsageRatio);
    return this;
  }
  /** 
 * Set the policy to discard read bytes from the decoding aggregation buffer to reclaim memory.
 * @param policy the policy to use in {@link io.lettuce.core.protocol.CommandHandler}
 * @return {@code this}
 * @since 6.0
 * @see DecodeBufferPolicies
 */
  public Builder decodeBufferPolicy(  DecodeBufferPolicy policy){
    LettuceAssert.notNull(policy,"DecodeBufferPolicy must not be null");
    this.decodeBufferPolicy=policy;
    return this;
  }
  /** 
 * Sets the behavior for command invocation when connections are in a disconnected state. Defaults to  {@code true}. See {@link #DEFAULT_DISCONNECTED_BEHAVIOR}.
 * @param disconnectedBehavior must not be {@code null}.
 * @return {@code this}
 */
  public Builder disconnectedBehavior(  DisconnectedBehavior disconnectedBehavior){
    LettuceAssert.notNull(disconnectedBehavior,"DisconnectedBehavior must not be null");
    this.disconnectedBehavior=disconnectedBehavior;
    return this;
  }
  /** 
 * Perform a lightweight  {@literal PING} connection handshake when establishing a Redis connection. If {@code true}(default is  {@code true},  {@link #DEFAULT_PING_BEFORE_ACTIVATE_CONNECTION}), every connection and reconnect will issue a  {@literal PING} command and await its response before the connection is activated and enabled for use. If thecheck fails, the connect/reconnect is treated as a failure. This option has no effect unless forced to use the RESP 2 protocol version. RESP 3/protocol discovery performs a  {@code HELLO} handshake.<p> The  {@literal PING} handshake validates whether the other end of the connected socket is a service that behaves likea Redis server.
 * @param pingBeforeActivateConnection true/false
 * @return {@code this}
 */
  public Builder pingBeforeActivateConnection(  boolean pingBeforeActivateConnection){
    this.pingBeforeActivateConnection=pingBeforeActivateConnection;
    return this;
  }
  /** 
 * Sets the  {@link ProtocolVersion} to use. Defaults to {@literal RESP3}. See  {@link #DEFAULT_PROTOCOL_VERSION}.
 * @param protocolVersion version to use.
 * @return {@code this}
 * @since 6.0
 * @see ProtocolVersion#newestSupported()
 */
  public Builder protocolVersion(  ProtocolVersion protocolVersion){
    this.protocolVersion=protocolVersion;
    return this;
  }
  /** 
 * Use a dedicated  {@link reactor.core.scheduler.Scheduler} to emit reactive data signals. Enabling this option can beuseful for reactive sequences that require a significant amount of processing with a single/a few Redis connections. <p> A single Redis connection operates on a single thread. Operations that require a significant amount of processing can lead to a single-threaded-like behavior for all consumers of the Redis connection. When enabled, data signals will be emitted using a different thread served by  {@link ClientResources#eventExecutorGroup()}. Defaults to  {@code false} ,see  {@link #DEFAULT_PUBLISH_ON_SCHEDULER}.
 * @param publishOnScheduler true/false
 * @return {@code this}
 * @since 5.2
 * @see org.reactivestreams.Subscriber#onNext(Object)
 * @see ClientResources#eventExecutorGroup()
 */
  public Builder publishOnScheduler(  boolean publishOnScheduler){
    this.publishOnScheduler=publishOnScheduler;
    return this;
  }
  /** 
 * Set the per-connection request queue size. The command invocation will lead to a  {@link RedisException} if the queuesize is exceeded. Setting the  {@code requestQueueSize} to a lower value will lead earlier to exceptions duringoverload or while the connection is in a disconnected state. A higher value means hitting the boundary will take longer to occur, but more requests will potentially be queued up and more heap space is used. Defaults to {@link Integer#MAX_VALUE}. See  {@link #DEFAULT_REQUEST_QUEUE_SIZE}.
 * @param requestQueueSize the queue size.
 * @return {@code this}
 */
  public Builder requestQueueSize(  int requestQueueSize){
    this.requestQueueSize=requestQueueSize;
    return this;
  }
  /** 
 * Sets the Lua script  {@link Charset} to use to encode {@link String scripts} to {@code byte[]}. Defaults to {@link StandardCharsets#UTF_8}. See  {@link #DEFAULT_SCRIPT_CHARSET}.
 * @param scriptCharset must not be {@code null}.
 * @return {@code this}
 * @since 6.0
 */
  public Builder scriptCharset(  Charset scriptCharset){
    LettuceAssert.notNull(scriptCharset,"ScriptCharset must not be null");
    this.scriptCharset=scriptCharset;
    return this;
  }
  /** 
 * Sets the low-level  {@link SocketOptions} for the connections kept to Redis servers. See{@link #DEFAULT_SOCKET_OPTIONS}.
 * @param socketOptions must not be {@code null}.
 * @return {@code this}
 */
  public Builder socketOptions(  SocketOptions socketOptions){
    LettuceAssert.notNull(socketOptions,"SocketOptions must not be null");
    this.socketOptions=socketOptions;
    return this;
  }
  /** 
 * Sets the  {@link SslOptions} for SSL connections kept to Redis servers. See {@link #DEFAULT_SSL_OPTIONS}.
 * @param sslOptions must not be {@code null}.
 * @return {@code this}
 */
  public Builder sslOptions(  SslOptions sslOptions){
    LettuceAssert.notNull(sslOptions,"SslOptions must not be null");
    this.sslOptions=sslOptions;
    return this;
  }
  /** 
 * Suspends reconnect when reconnects run into protocol failures (SSL verification, PING before connect fails). Defaults to  {@code false}. See  {@link #DEFAULT_SUSPEND_RECONNECT_PROTO_FAIL}.
 * @param suspendReconnectOnProtocolFailure true/false
 * @return {@code this}
 */
  public Builder suspendReconnectOnProtocolFailure(  boolean suspendReconnectOnProtocolFailure){
    this.suspendReconnectOnProtocolFailure=suspendReconnectOnProtocolFailure;
    return this;
  }
  /** 
 * Sets the  {@link TimeoutOptions} to expire and cancel commands. See {@link #DEFAULT_TIMEOUT_OPTIONS}.
 * @param timeoutOptions must not be {@code null}.
 * @return {@code this}
 * @since 5.1
 */
  public Builder timeoutOptions(  TimeoutOptions timeoutOptions){
    LettuceAssert.notNull(timeoutOptions,"TimeoutOptions must not be null");
    this.timeoutOptions=timeoutOptions;
    return this;
  }
  /** 
 * Create a new instance of  {@link ClientOptions}.
 * @return new instance of {@link ClientOptions}
 */
  public ClientOptions build(){
    return new ClientOptions(this);
  }
}
/** 
 * Builder entry points for  {@link CopyArgs}.
 */
public static class Builder {
  /** 
 * Utility constructor.
 */
  private Builder(){
  }
  /** 
 * Creates new  {@link CopyArgs} and sets {@literal DB}.
 * @return new {@link CopyArgs} with {@literal DB} set.
 */
  public static CopyArgs destinationDb(  long destinationDb){
    return new CopyArgs().destinationDb(destinationDb);
  }
  /** 
 * Creates new  {@link CopyArgs} and sets {@literal REPLACE}.
 * @return new {@link CopyArgs} with {@literal REPLACE} set.
 */
  public static CopyArgs replace(  boolean replace){
    return new CopyArgs().replace(replace);
  }
}
/** 
 * Builder entry points for  {@link ExpireArgs}.
 */
public static class Builder {
  /** 
 * Utility constructor.
 */
  private Builder(){
  }
  /** 
 * Creates new  {@link ExpireArgs} and sets {@literal NX}.
 * @return new {@link ExpireArgs} with {@literal NX} set.
 */
  public static ExpireArgs nx(){
    return new ExpireArgs().nx();
  }
  /** 
 * Creates new  {@link ExpireArgs} and sets {@literal XX}.
 * @return new {@link ExpireArgs} with {@literal XX} set.
 */
  public static ExpireArgs xx(){
    return new ExpireArgs().xx();
  }
  /** 
 * Creates new  {@link ExpireArgs} and sets {@literal GT}.
 * @return new {@link ExpireArgs} with {@literal GT} set.
 */
  public static ExpireArgs gt(){
    return new ExpireArgs().gt();
  }
  /** 
 * Creates new  {@link ExpireArgs} and sets {@literal LT}.
 * @return new {@link ExpireArgs} with {@literal LT} set.
 */
  public static ExpireArgs lt(){
    return new ExpireArgs().lt();
  }
}
/** 
 * Builder entry points for  {@link ScanArgs}.
 */
public static class Builder {
  /** 
 * Utility constructor.
 */
  private Builder(){
  }
  /** 
 * Creates new  {@link GeoAddArgs} and enabling {@literal NX}.
 * @return new {@link GeoAddArgs} with {@literal NX} enabled.
 * @see GeoAddArgs#nx()
 */
  public static GeoAddArgs nx(){
    return new GeoAddArgs().nx();
  }
  /** 
 * Creates new  {@link GeoAddArgs} and enabling {@literal XX}.
 * @return new {@link GeoAddArgs} with {@literal XX} enabled.
 * @see GeoAddArgs#xx()
 */
  public static GeoAddArgs xx(){
    return new GeoAddArgs().xx();
  }
  /** 
 * Creates new  {@link GeoAddArgs} and enabling {@literal CH}.
 * @return new {@link GeoAddArgs} with {@literal CH} enabled.
 * @see GeoAddArgs#ch()
 */
  public static GeoAddArgs ch(){
    return new GeoAddArgs().ch();
  }
}
/** 
 * Builder entry points for  {@link GeoArgs}.
 */
public static class Builder {
  /** 
 * Utility constructor.
 */
  private Builder(){
  }
  /** 
 * Creates new  {@link GeoArgs} with {@literal WITHDIST} enabled.
 * @return new {@link GeoArgs} with {@literal WITHDIST} enabled.
 * @see GeoArgs#withDistance()
 */
  public static GeoArgs distance(){
    return new GeoArgs().withDistance();
  }
  /** 
 * Creates new  {@link GeoArgs} with {@literal WITHCOORD} enabled.
 * @return new {@link GeoArgs} with {@literal WITHCOORD} enabled.
 * @see GeoArgs#withCoordinates()
 */
  public static GeoArgs coordinates(){
    return new GeoArgs().withCoordinates();
  }
  /** 
 * Creates new  {@link GeoArgs} with {@literal WITHHASH} enabled.
 * @return new {@link GeoArgs} with {@literal WITHHASH} enabled.
 * @see GeoArgs#withHash()
 */
  public static GeoArgs hash(){
    return new GeoArgs().withHash();
  }
  /** 
 * Creates new  {@link GeoArgs} with distance, coordinates and hash enabled.
 * @return new {@link GeoArgs} with {@literal WITHDIST},  {@literal WITHCOORD},  {@literal WITHHASH} enabled.
 * @see GeoArgs#withDistance()
 * @see GeoArgs#withCoordinates()
 * @see GeoArgs#withHash()
 */
  public static GeoArgs full(){
    return new GeoArgs().withDistance().withCoordinates().withHash();
  }
  /** 
 * Creates new  {@link GeoArgs} with {@literal COUNT} set.
 * @param count number greater 0.
 * @return new {@link GeoArgs} with {@literal COUNT} set.
 * @see GeoArgs#withCount(long)
 */
  public static GeoArgs count(  long count){
    return new GeoArgs().withCount(count);
  }
}
/** 
 * Builder entry points for  {@link GeoRadiusStoreArgs}.
 */
public static class Builder {
  /** 
 * Utility constructor.
 */
  private Builder(){
  }
  /** 
 * Creates new  {@link GeoRadiusStoreArgs} with {@literal STORE} enabled.
 * @param key must not be {@code null}.
 * @return new {@link GeoRadiusStoreArgs} with {@literal STORE} enabled.
 * @see GeoRadiusStoreArgs#withStore(Object)
 */
  public static <K>GeoRadiusStoreArgs store(  K key){
    return new GeoRadiusStoreArgs<>().withStore(key);
  }
  /** 
 * Creates new  {@link GeoRadiusStoreArgs} with {@literal STOREDIST} enabled.
 * @param key must not be {@code null}.
 * @return new {@link GeoRadiusStoreArgs} with {@literal STOREDIST} enabled.
 * @see GeoRadiusStoreArgs#withStoreDist(Object)
 */
  public static <K>GeoRadiusStoreArgs withStoreDist(  K key){
    return new GeoRadiusStoreArgs<>().withStoreDist(key);
  }
  /** 
 * Creates new  {@link GeoRadiusStoreArgs} with {@literal COUNT} set.
 * @param count number greater 0.
 * @return new {@link GeoRadiusStoreArgs} with {@literal COUNT} set.
 * @see GeoRadiusStoreArgs#withStoreDist(Object)
 */
  public static <K>GeoRadiusStoreArgs count(  long count){
    return new GeoRadiusStoreArgs<>().withCount(count);
  }
}
/** 
 * Builder entry points for  {@link GetExArgs}.
 */
public static class Builder {
  /** 
 * Utility constructor.
 */
  private Builder(){
  }
  /** 
 * Creates new  {@link GetExArgs} and enable {@literal EX}.
 * @param timeout expire time in seconds.
 * @return new {@link GetExArgs} with {@literal EX} enabled.
 * @see GetExArgs#ex(long)
 */
  public static GetExArgs ex(  long timeout){
    return new GetExArgs().ex(timeout);
  }
  /** 
 * Creates new  {@link GetExArgs} and enable {@literal EX}.
 * @param timeout expire time in seconds.
 * @return new {@link GetExArgs} with {@literal EX} enabled.
 * @see GetExArgs#ex(long)
 * @since 6.1
 */
  public static GetExArgs ex(  Duration timeout){
    return new GetExArgs().ex(timeout);
  }
  /** 
 * Creates new  {@link GetExArgs} and enable {@literal EXAT}.
 * @param timestamp the timestamp type: posix time in seconds.
 * @return new {@link GetExArgs} with {@literal EXAT} enabled.
 * @see GetExArgs#exAt(long)
 */
  public static GetExArgs exAt(  long timestamp){
    return new GetExArgs().exAt(timestamp);
  }
  /** 
 * Creates new  {@link GetExArgs} and enable {@literal EXAT}.
 * @param timestamp the timestamp type: posix time in seconds.
 * @return new {@link GetExArgs} with {@literal EXAT} enabled.
 * @see GetExArgs#exAt(Date)
 * @since 6.1
 */
  public static GetExArgs exAt(  Date timestamp){
    return new GetExArgs().exAt(timestamp);
  }
  /** 
 * Creates new  {@link GetExArgs} and enable {@literal EXAT}.
 * @param timestamp the timestamp type: posix time in seconds.
 * @return new {@link GetExArgs} with {@literal EXAT} enabled.
 * @see GetExArgs#exAt(Instant)
 * @since 6.1
 */
  public static GetExArgs exAt(  Instant timestamp){
    return new GetExArgs().exAt(timestamp);
  }
  /** 
 * Creates new  {@link GetExArgs} and enable {@literal PX}.
 * @param timeout expire time in milliseconds.
 * @return new {@link GetExArgs} with {@literal PX} enabled.
 * @see GetExArgs#px(long)
 */
  public static GetExArgs px(  long timeout){
    return new GetExArgs().px(timeout);
  }
  /** 
 * Creates new  {@link GetExArgs} and enable {@literal PX}.
 * @param timeout expire time in milliseconds.
 * @return new {@link GetExArgs} with {@literal PX} enabled.
 * @see GetExArgs#px(long)
 * @since 6.1
 */
  public static GetExArgs px(  Duration timeout){
    return new GetExArgs().px(timeout);
  }
  /** 
 * Creates new  {@link GetExArgs} and enable {@literal PXAT}.
 * @param timestamp the timestamp type: posix time.
 * @return new {@link GetExArgs} with {@literal PXAT} enabled.
 * @see GetExArgs#pxAt(long)
 */
  public static GetExArgs pxAt(  long timestamp){
    return new GetExArgs().pxAt(timestamp);
  }
  /** 
 * Creates new  {@link GetExArgs} and enable {@literal PXAT}.
 * @param timestamp the timestamp type: posix time.
 * @return new {@link GetExArgs} with {@literal PXAT} enabled.
 * @see GetExArgs#pxAt(Date)
 * @since 6.1
 */
  public static GetExArgs pxAt(  Date timestamp){
    return new GetExArgs().pxAt(timestamp);
  }
  /** 
 * Creates new  {@link GetExArgs} and enable {@literal PXAT}.
 * @param timestamp the timestamp type: posix time.
 * @return new {@link GetExArgs} with {@literal PXAT} enabled.
 * @see GetExArgs#pxAt(Instant)
 * @since 6.1
 */
  public static GetExArgs pxAt(  Instant timestamp){
    return new GetExArgs().pxAt(timestamp);
  }
  /** 
 * Creates new  {@link GetExArgs} and enable {@literal PERSIST}.
 * @return new {@link GetExArgs} with {@literal PERSIST} enabled.
 * @see GetExArgs#persist()
 */
  public static GetExArgs persist(){
    return new GetExArgs().persist();
  }
}
public static class Builder {
  /** 
 * Utility constructor.
 */
  private Builder(){
  }
  /** 
 * Creates new  {@link ScanArgs} with {@literal LIMIT} set.
 * @param count number of elements to scan
 * @return new {@link ScanArgs} with {@literal LIMIT} set.
 * @see KeyScanArgs#limit(long)
 */
  public static KeyScanArgs limit(  long count){
    return new KeyScanArgs().limit(count);
  }
  /** 
 * Creates new  {@link ScanArgs} with {@literal MATCH} set.
 * @param matches the filter.
 * @return new {@link ScanArgs} with {@literal MATCH} set.
 * @see KeyScanArgs#match(String)
 */
  public static KeyScanArgs matches(  String matches){
    return new KeyScanArgs().match(matches);
  }
  /** 
 * Creates new  {@link ScanArgs} with {@literal TYPE} set.
 * @param type the filter.
 * @return new {@link ScanArgs} with {@literal TYPE} set.
 * @see KeyScanArgs#type(String)
 */
  public static KeyScanArgs type(  String type){
    return new KeyScanArgs().type(type);
  }
}
/** 
 * Builder entry points for  {@link KillArgs}.
 */
public static class Builder {
  /** 
 * Utility constructor.
 */
  private Builder(){
  }
  /** 
 * Creates new  {@link KillArgs} and enabling {@literal SKIPME YES}.
 * @return new {@link KillArgs} with {@literal SKIPME YES} enabled.
 * @see KillArgs#skipme()
 */
  public static KillArgs skipme(){
    return new KillArgs().skipme();
  }
  /** 
 * Creates new  {@link KillArgs} setting {@literal ADDR} (Remote Address).
 * @param addr must not be {@code null}.
 * @return new {@link KillArgs} with {@literal ADDR} set.
 * @see KillArgs#addr(String)
 */
  public static KillArgs addr(  String addr){
    return new KillArgs().addr(addr);
  }
  /** 
 * Creates new  {@link KillArgs} setting {@literal LADDR} (Local Address).
 * @param laddr must not be {@code null}.
 * @return new {@link KillArgs} with {@literal LADDR} set.
 * @see KillArgs#laddr(String)
 */
  public static KillArgs laddr(  String laddr){
    return new KillArgs().laddr(laddr);
  }
  /** 
 * Creates new  {@link KillArgs} setting {@literal ID}.
 * @param id client id.
 * @return new {@link KillArgs} with {@literal ID} set.
 * @see KillArgs#id(long)
 */
  public static KillArgs id(  long id){
    return new KillArgs().id(id);
  }
  /** 
 * Creates new  {@link KillArgs} setting {@literal TYPE PUBSUB}.
 * @return new {@link KillArgs} with {@literal TYPE PUBSUB} set.
 * @see KillArgs#type(Type)
 */
  public static KillArgs typePubsub(){
    return new KillArgs().type(Type.PUBSUB);
  }
  /** 
 * Creates new  {@link KillArgs} setting {@literal TYPE NORMAL}.
 * @return new {@link KillArgs} with {@literal TYPE NORMAL} set.
 * @see KillArgs#type(Type)
 */
  public static KillArgs typeNormal(){
    return new KillArgs().type(Type.NORMAL);
  }
  /** 
 * Creates new  {@link KillArgs} setting {@literal TYPE MASTER}.
 * @return new {@link KillArgs} with {@literal TYPE MASTER} set.
 * @see KillArgs#type(Type)
 * @since 5.0.4
 */
  public static KillArgs typeMaster(){
    return new KillArgs().type(Type.MASTER);
  }
  /** 
 * Creates new  {@link KillArgs} setting {@literal TYPE SLAVE}.
 * @return new {@link KillArgs} with {@literal TYPE SLAVE} set.
 * @see KillArgs#type(Type)
 */
  public static KillArgs typeSlave(){
    return new KillArgs().type(Type.SLAVE);
  }
  /** 
 * Creates new  {@link KillArgs} setting {@literal USER}.
 * @return new {@link KillArgs} with {@literal USER} set.
 * @see KillArgs#user(String)
 * @since 6.1
 */
  public static KillArgs user(  String username){
    return new KillArgs().user(username);
  }
}
/** 
 * Builder entry points for  {@link LMoveArgs}.
 */
public static class Builder {
  /** 
 * Utility constructor.
 */
  private Builder(){
  }
  /** 
 * Creates new  {@link LMoveArgs} setting with {@code LEFT} {@code LEFT} directions.
 * @return new {@link LMoveArgs} with args set.
 */
  public static LMoveArgs leftLeft(){
    return new LMoveArgs(CommandKeyword.LEFT,CommandKeyword.LEFT);
  }
  /** 
 * Creates new  {@link LMoveArgs} setting with {@code LEFT} {@code RIGHT} directions.
 * @return new {@link LMoveArgs} with args set.
 */
  public static LMoveArgs leftRight(){
    return new LMoveArgs(CommandKeyword.LEFT,CommandKeyword.RIGHT);
  }
  /** 
 * Creates new  {@link LMoveArgs} setting with {@code RIGHT} {@code LEFT} directions.
 * @return new {@link LMoveArgs} with args set.
 */
  public static LMoveArgs rightLeft(){
    return new LMoveArgs(CommandKeyword.RIGHT,CommandKeyword.LEFT);
  }
  /** 
 * Creates new  {@link LMoveArgs} setting with {@code RIGHT} {@code RIGHT} directions.
 * @return new {@link LMoveArgs} with args set.
 */
  public static LMoveArgs rightRight(){
    return new LMoveArgs(CommandKeyword.RIGHT,CommandKeyword.RIGHT);
  }
}
/** 
 * Builder entry points for  {@link LMPopArgs}.
 */
public static class Builder {
  /** 
 * Utility constructor.
 */
  private Builder(){
  }
  /** 
 * Creates new  {@link LMPopArgs} setting with {@code LEFT} direction.
 * @return new {@link LMPopArgs} with args set.
 */
  public static LMPopArgs left(){
    return new LMPopArgs(CommandKeyword.LEFT,null);
  }
  /** 
 * Creates new  {@link LMPopArgs} setting with {@code RIGHT} direction.
 * @return new {@link LMPopArgs} with args set.
 */
  public static LMPopArgs right(){
    return new LMPopArgs(CommandKeyword.RIGHT,null);
  }
}
/** 
 * Builder entry points for  {@link LPosArgs}.
 */
public static class Builder {
  /** 
 * Utility constructor.
 */
  private Builder(){
  }
  /** 
 * Creates new empty  {@link LPosArgs}.
 * @return new {@link LPosArgs}.
 * @see LPosArgs#maxlen(long)
 */
  public static LPosArgs empty(){
    return new LPosArgs();
  }
  /** 
 * Creates new  {@link LPosArgs} and setting {@literal MAXLEN}.
 * @return new {@link LPosArgs} with {@literal MAXLEN} set.
 * @see LPosArgs#maxlen(long)
 */
  public static LPosArgs maxlen(  long count){
    return new LPosArgs().maxlen(count);
  }
  /** 
 * Creates new  {@link LPosArgs} and setting {@literal RANK}.
 * @return new {@link LPosArgs} with {@literal RANK} set.
 * @see LPosArgs#rank(long)
 */
  public static LPosArgs rank(  long rank){
    return new LPosArgs().rank(rank);
  }
}
/** 
 * Builder entry points for  {@link MigrateArgs}.
 */
public static class Builder {
  /** 
 * Utility constructor.
 */
  private Builder(){
  }
  /** 
 * Creates new  {@link MigrateArgs} and enabling {@literal COPY}.
 * @return new {@link MigrateArgs} with {@literal COPY} enabled.
 * @see MigrateArgs#copy()
 */
  public static <K>MigrateArgs<K> copy(){
    return new MigrateArgs<K>().copy();
  }
  /** 
 * Creates new  {@link MigrateArgs} and enabling {@literal REPLACE}.
 * @return new {@link MigrateArgs} with {@literal REPLACE} enabled.
 * @see MigrateArgs#replace()
 */
  public static <K>MigrateArgs<K> replace(){
    return new MigrateArgs<K>().replace();
  }
  /** 
 * Creates new  {@link MigrateArgs} setting a {@code key} to migrate.
 * @param key must not be {@code null}.
 * @return new {@link MigrateArgs} for {@code key} to migrate.
 * @see MigrateArgs#key(Object)
 */
  public static <K>MigrateArgs<K> key(  K key){
    return new MigrateArgs<K>().key(key);
  }
  /** 
 * Creates new  {@link MigrateArgs} setting {@code keys} to migrate.
 * @param keys must not be {@code null}.
 * @return new {@link MigrateArgs} for {@code keys} to migrate.
 * @see MigrateArgs#keys(Object[])
 */
  @SafeVarargs public static <K>MigrateArgs<K> keys(  K... keys){
    return new MigrateArgs<K>().keys(keys);
  }
  /** 
 * Creates new  {@link MigrateArgs} setting {@code keys} to migrate.
 * @param keys must not be {@code null}.
 * @return new {@link MigrateArgs} for {@code keys} to migrate.
 * @see MigrateArgs#keys(Iterable)
 */
  public static <K>MigrateArgs<K> keys(  Iterable<K> keys){
    return new MigrateArgs<K>().keys(keys);
  }
  /** 
 * Creates new  {@link MigrateArgs} with {@code AUTH} (target authentication) enabled.
 * @return new {@link MigrateArgs} with {@code AUTH} (target authentication) enabled.
 * @since 4.4.5
 * @see MigrateArgs#auth(CharSequence)
 */
  public static <K>MigrateArgs<K> auth(  CharSequence password){
    return new MigrateArgs<K>().auth(password);
  }
  /** 
 * Creates new  {@link MigrateArgs} with {@code AUTH2} (target authentication) enabled.
 * @return new {@link MigrateArgs} with {@code AUTH2} (target authentication) enabled.
 * @since 6.1
 * @see MigrateArgs#auth2(CharSequence,CharSequence)
 */
  public static <K>MigrateArgs<K> auth2(  CharSequence username,  CharSequence password){
    return new MigrateArgs<K>().auth2(username,password);
  }
  /** 
 * Creates new  {@link MigrateArgs} with {@code AUTH} (target authentication) enabled.
 * @return new {@link MigrateArgs} with {@code AUTH} (target authentication) enabled.
 * @since 4.4.5
 * @see MigrateArgs#auth(char[])
 */
  public static <K>MigrateArgs<K> auth(  char[] password){
    return new MigrateArgs<K>().auth(password);
  }
}
/** 
 * Builder for Redis URI.
 */
public static class Builder {
  private String host;
  private String socket;
  private String sentinelMasterId;
  private int port=DEFAULT_REDIS_PORT;
  private int database;
  private String clientName;
  private String username;
  private char[] password;
  private RedisCredentialsProvider credentialsProvider;
  private char[] sentinelPassword;
  private boolean ssl=false;
  private SslVerifyMode verifyMode=SslVerifyMode.FULL;
  private boolean startTls=false;
  private Duration timeout=DEFAULT_TIMEOUT_DURATION;
  private final List<RedisURI> sentinels=new ArrayList<>();
  private Builder(){
  }
  /** 
 * Set Redis socket. Creates a new builder.
 * @param socket the host name
 * @return new builder with Redis socket.
 */
  public static Builder socket(  String socket){
    LettuceAssert.notNull(socket,"Socket must not be null");
    Builder builder=RedisURI.builder();
    builder.socket=socket;
    return builder;
  }
  /** 
 * Set Redis host. Creates a new builder.
 * @param host the host name
 * @return new builder with Redis host/port.
 */
  public static Builder redis(  String host){
    return redis(host,DEFAULT_REDIS_PORT);
  }
  /** 
 * Set Redis host and port. Creates a new builder
 * @param host the host name
 * @param port the port
 * @return new builder with Redis host/port.
 */
  public static Builder redis(  String host,  int port){
    LettuceAssert.notEmpty(host,"Host must not be empty");
    LettuceAssert.isTrue(isValidPort(port),() -> String.format("Port out of range: %s",port));
    Builder builder=RedisURI.builder();
    return builder.withHost(host).withPort(port);
  }
  /** 
 * Set Sentinel host. Creates a new builder.
 * @param host the host name
 * @return new builder with Sentinel host/port.
 */
  public static Builder sentinel(  String host){
    LettuceAssert.notEmpty(host,"Host must not be empty");
    Builder builder=RedisURI.builder();
    return builder.withSentinel(host);
  }
  /** 
 * Set Sentinel host and port. Creates a new builder.
 * @param host the host name
 * @param port the port
 * @return new builder with Sentinel host/port.
 */
  public static Builder sentinel(  String host,  int port){
    LettuceAssert.notEmpty(host,"Host must not be empty");
    LettuceAssert.isTrue(isValidPort(port),() -> String.format("Port out of range: %s",port));
    Builder builder=RedisURI.builder();
    return builder.withSentinel(host,port);
  }
  /** 
 * Set Sentinel host and master id. Creates a new builder.
 * @param host the host name
 * @param masterId sentinel master id
 * @return new builder with Sentinel host/port.
 */
  public static Builder sentinel(  String host,  String masterId){
    return sentinel(host,DEFAULT_SENTINEL_PORT,masterId);
  }
  /** 
 * Set Sentinel host, port and master id. Creates a new builder.
 * @param host the host name
 * @param port the port
 * @param masterId sentinel master id
 * @return new builder with Sentinel host/port.
 */
  public static Builder sentinel(  String host,  int port,  String masterId){
    return sentinel(host,port,masterId,null);
  }
  /** 
 * Set Sentinel host, port, master id and Sentinel authentication. Creates a new builder.
 * @param host the host name
 * @param port the port
 * @param masterId sentinel master id
 * @param password the Sentinel password (supported since Redis 5.0.1)
 * @return new builder with Sentinel host/port.
 * @deprecated since 6.0, use {@link #sentinel(String,int,String)} and{@link #withAuthentication(String,CharSequence)} instead.
 */
  @Deprecated public static Builder sentinel(  String host,  int port,  String masterId,  CharSequence password){
    LettuceAssert.notEmpty(host,"Host must not be empty");
    LettuceAssert.isTrue(isValidPort(port),() -> String.format("Port out of range: %s",port));
    Builder builder=RedisURI.builder();
    if (password != null) {
      builder.sentinelPassword=password.toString().toCharArray();
    }
    return builder.withSentinelMasterId(masterId).withSentinel(host,port);
  }
  /** 
 * Add a withSentinel host to the existing builder.
 * @param host the host name
 * @return the builder
 */
  public Builder withSentinel(  String host){
    return withSentinel(host,DEFAULT_SENTINEL_PORT);
  }
  /** 
 * Add a withSentinel host/port to the existing builder.
 * @param host the host name
 * @param port the port
 * @return the builder
 */
  public Builder withSentinel(  String host,  int port){
    if (this.sentinelPassword != null) {
      return withSentinel(host,port,new String(this.sentinelPassword));
    }
    return withSentinel(host,port,null);
  }
  /** 
 * Add a withSentinel host/port and Sentinel authentication to the existing builder.
 * @param host the host name
 * @param port the port
 * @param password the Sentinel password (supported since Redis 5.0.1)
 * @return the builder
 * @since 5.2
 */
  public Builder withSentinel(  String host,  int port,  CharSequence password){
    LettuceAssert.assertState(this.host == null,"Cannot use with Redis mode.");
    LettuceAssert.notEmpty(host,"Host must not be empty");
    LettuceAssert.isTrue(isValidPort(port),() -> String.format("Port out of range: %s",port));
    RedisURI redisURI=RedisURI.create(host,port);
    if (password != null) {
      redisURI.setPassword(password);
    }
    return withSentinel(redisURI);
  }
  /** 
 * Add a withSentinel RedisURI to the existing builder.
 * @param redisURI the sentinel URI
 * @return the builder
 * @since 5.2
 */
  public Builder withSentinel(  RedisURI redisURI){
    LettuceAssert.notNull(redisURI,"Redis URI must not be null");
    sentinels.add(redisURI);
    return this;
  }
  /** 
 * Adds host information to the builder. Does only affect Redis URI, cannot be used with Sentinel connections.
 * @param host the port
 * @return the builder
 */
  public Builder withHost(  String host){
    LettuceAssert.assertState(this.sentinels.isEmpty(),"Sentinels are non-empty. Cannot use in Sentinel mode.");
    LettuceAssert.notEmpty(host,"Host must not be empty");
    this.host=host;
    return this;
  }
  /** 
 * Adds port information to the builder. Does only affect Redis URI, cannot be used with Sentinel connections.
 * @param port the port
 * @return the builder
 */
  public Builder withPort(  int port){
    LettuceAssert.assertState(this.host != null,"Host is null. Cannot use in Sentinel mode.");
    LettuceAssert.isTrue(isValidPort(port),() -> String.format("Port out of range: %s",port));
    this.port=port;
    return this;
  }
  /** 
 * Apply authentication from another  {@link RedisURI}. The SSL settings of the  {@code source} URI will be applied tothis URI. That is in particular SSL usage, peer verification and StartTLS.
 * @param source must not be {@code null}.
 * @since 6.0
 * @return the builder
 */
  public Builder withSsl(  RedisURI source){
    LettuceAssert.notNull(source,"Source RedisURI must not be null");
    withSsl(source.isSsl());
    withVerifyPeer(source.getVerifyMode());
    withStartTls(source.isStartTls());
    return this;
  }
  /** 
 * Adds ssl information to the builder. Sets SSL also for already configured Redis Sentinel nodes.
 * @param ssl {@code true} if use SSL
 * @return the builder
 */
  public Builder withSsl(  boolean ssl){
    this.ssl=ssl;
    this.sentinels.forEach(it -> it.setSsl(ssl));
    return this;
  }
  /** 
 * Enables/disables StartTLS when using SSL. Sets StartTLS also for already configured Redis Sentinel nodes.
 * @param startTls {@code true} if use StartTLS
 * @return the builder
 */
  public Builder withStartTls(  boolean startTls){
    this.startTls=startTls;
    this.sentinels.forEach(it -> it.setStartTls(startTls));
    return this;
  }
  /** 
 * Enables/disables peer verification. Sets peer verification also for already configured Redis Sentinel nodes.
 * @param verifyPeer {@code true} to verify hosts when using SSL
 * @return the builder
 */
  public Builder withVerifyPeer(  boolean verifyPeer){
    return withVerifyPeer(verifyPeer ? SslVerifyMode.FULL : SslVerifyMode.NONE);
  }
  /** 
 * Configures peer verification mode. Sets peer verification also for already configured Redis Sentinel nodes.
 * @param verifyMode the mode to verify hosts when using SSL
 * @return the builder
 * @since 6.1
 */
  public Builder withVerifyPeer(  SslVerifyMode verifyMode){
    LettuceAssert.notNull(verifyMode,"VerifyMode must not be null");
    this.verifyMode=verifyMode;
    this.sentinels.forEach(it -> it.setVerifyPeer(verifyMode));
    return this;
  }
  /** 
 * Configures the database number.
 * @param database the database number
 * @return the builder
 */
  public Builder withDatabase(  int database){
    LettuceAssert.isTrue(database >= 0,() -> "Invalid database number: " + database);
    this.database=database;
    return this;
  }
  /** 
 * Configures a client name.
 * @param clientName the client name
 * @return the builder
 */
  public Builder withClientName(  String clientName){
    LettuceAssert.notNull(clientName,"Client name must not be null");
    this.clientName=clientName;
    return this;
  }
  /** 
 * Configures authentication.
 * @param username the user name
 * @param password the password name
 * @return the builder
 * @since 6.0
 */
  public Builder withAuthentication(  String username,  CharSequence password){
    LettuceAssert.notNull(username,"User name must not be null");
    LettuceAssert.notNull(password,"Password must not be null");
    this.username=username;
    return withPassword(password);
  }
  /** 
 * Apply authentication from another  {@link RedisURI}. The authentication settings of the  {@code source} URI will beapplied to this builder.
 * @param source must not be {@code null}.
 * @since 6.0
 */
  public Builder withAuthentication(  RedisURI source){
    LettuceAssert.notNull(source,"Source RedisURI must not be null");
    if (source.credentialsProvider != null) {
      return withAuthentication(source.getCredentialsProvider());
    }
    this.username=source.getUsername();
    return withPassword(source.getPassword());
  }
  /** 
 * Configures authentication.
 * @param username the user name
 * @param password the password name
 * @return the builder
 * @since 6.0
 */
  public Builder withAuthentication(  String username,  char[] password){
    LettuceAssert.notNull(username,"User name must not be null");
    LettuceAssert.notNull(password,"Password must not be null");
    this.username=username;
    return withPassword(password);
  }
  /** 
 * Configures authentication.
 * @param credentialsProvider must not be {@code null}.
 * @since 6.2
 */
  public Builder withAuthentication(  RedisCredentialsProvider credentialsProvider){
    LettuceAssert.notNull(credentialsProvider,"RedisCredentialsProvider must not be null");
    this.credentialsProvider=credentialsProvider;
    return this;
  }
  /** 
 * Configures authentication. <p> This method is deprecated as of Lettuce 6.0. The reason is that  {@link String} has a strong caching affinity and theJVM cannot easily GC  {@code String} instances. Therefore, we suggest using either {@code char[]} or a custom{@link CharSequence} (e.g. {@link StringBuilder} or netty's {@link io.netty.util.AsciiString}).
 * @param password the password
 * @return the builder
 * @deprecated since 6.0. Use {@link #withPassword(CharSequence)} or {@link #withPassword(char[])} to avoid Stringcaching.
 */
  @Deprecated public Builder withPassword(  String password){
    LettuceAssert.notNull(password,"Password must not be null");
    return withPassword(password.toCharArray());
  }
  /** 
 * Configures authentication.
 * @param password the password
 * @return the builder
 * @since 6.0
 */
  public Builder withPassword(  CharSequence password){
    LettuceAssert.notNull(password,"Password must not be null");
    char[] chars=new char[password.length()];
    for (int i=0; i < password.length(); i++) {
      chars[i]=password.charAt(i);
    }
    return withPassword(chars);
  }
  /** 
 * Configures authentication.
 * @param password the password
 * @return the builder
 * @since 4.4
 */
  public Builder withPassword(  char[] password){
    this.password=password == null ? null : Arrays.copyOf(password,password.length);
    return this;
  }
  /** 
 * Configures a timeout.
 * @param timeout must not be {@code null} or negative.
 * @return the builder
 */
  public Builder withTimeout(  Duration timeout){
    LettuceAssert.notNull(timeout,"Timeout must not be null");
    LettuceAssert.notNull(!timeout.isNegative(),"Timeout must be greater or equal 0");
    this.timeout=timeout;
    return this;
  }
  /** 
 * Configures a sentinel master Id.
 * @param sentinelMasterId sentinel master id, must not be empty or {@code null}
 * @return the builder
 */
  public Builder withSentinelMasterId(  String sentinelMasterId){
    LettuceAssert.notEmpty(sentinelMasterId,"Sentinel master id must not empty");
    this.sentinelMasterId=sentinelMasterId;
    return this;
  }
  /** 
 * @return the RedisURI.
 */
  public RedisURI build(){
    if (sentinels.isEmpty() && LettuceStrings.isEmpty(host) && LettuceStrings.isEmpty(socket)) {
      throw new IllegalStateException("Cannot build a RedisURI. One of the following must be provided Host, Socket or Sentinel");
    }
    RedisURI redisURI=new RedisURI();
    redisURI.setHost(host);
    redisURI.setPort(port);
    if (credentialsProvider != null) {
      redisURI.setCredentialsProvider(credentialsProvider);
    }
 else {
      redisURI.setUsername(username);
      if (password != null) {
        redisURI.setPassword(password);
      }
    }
    redisURI.setDatabase(database);
    redisURI.setClientName(clientName);
    redisURI.setSentinelMasterId(sentinelMasterId);
    for (    RedisURI sentinel : sentinels) {
      sentinel.setTimeout(timeout);
      redisURI.getSentinels().add(sentinel);
    }
    redisURI.setSocket(socket);
    redisURI.setSsl(ssl);
    redisURI.setStartTls(startTls);
    redisURI.setVerifyPeer(verifyMode);
    redisURI.setTimeout(timeout);
    return redisURI;
  }
}
/** 
 * Builder entry points for  {@link XAddArgs}.
 */
public static class Builder {
  /** 
 * Utility constructor.
 */
  private Builder(){
  }
  /** 
 * Creates new  {@link RestoreArgs} and set the TTL.
 * @return new {@link RestoreArgs} with min idle time set.
 * @see RestoreArgs#ttl(long)
 */
  public static RestoreArgs ttl(  long milliseconds){
    return new RestoreArgs().ttl(milliseconds);
  }
  /** 
 * Creates new  {@link RestoreArgs} and set the minimum idle time.
 * @return new {@link RestoreArgs} with min idle time set.
 * @see RestoreArgs#ttl(Duration)
 */
  public static RestoreArgs ttl(  Duration ttl){
    LettuceAssert.notNull(ttl,"Time to live must not be null");
    return ttl(ttl.toMillis());
  }
}
/** 
 * Builder entry points for  {@link ScanArgs}.
 */
public static class Builder {
  /** 
 * Utility constructor.
 */
  private Builder(){
  }
  /** 
 * Creates new  {@link ScanArgs} with {@literal LIMIT} set.
 * @param count number of elements to scan
 * @return new {@link ScanArgs} with {@literal LIMIT} set.
 * @see ScanArgs#limit(long)
 */
  public static ScanArgs limit(  long count){
    return new ScanArgs().limit(count);
  }
  /** 
 * Creates new  {@link ScanArgs} with {@literal MATCH} set.
 * @param matches the filter.
 * @return new {@link ScanArgs} with {@literal MATCH} set.
 * @see ScanArgs#match(String)
 */
  public static ScanArgs matches(  String matches){
    return new ScanArgs().match(matches);
  }
  /** 
 * Creates new  {@link ScanArgs} with {@literal MATCH} set.
 * @param matches the filter.
 * @return new {@link ScanArgs} with {@literal MATCH} set.
 * @since 6.0.4
 * @see ScanArgs#match(byte[])
 */
  public static ScanArgs matches(  byte[] matches){
    return new ScanArgs().match(matches);
  }
}
/** 
 * Builder entry points for  {@link SetArgs}.
 */
public static class Builder {
  /** 
 * Utility constructor.
 */
  private Builder(){
  }
  /** 
 * Creates new  {@link SetArgs} and enable {@literal EX}.
 * @param timeout expire time in seconds.
 * @return new {@link SetArgs} with {@literal EX} enabled.
 * @see SetArgs#ex(long)
 */
  public static SetArgs ex(  long timeout){
    return new SetArgs().ex(timeout);
  }
  /** 
 * Creates new  {@link SetArgs} and enable {@literal EX}.
 * @param timeout expire time in seconds.
 * @return new {@link SetArgs} with {@literal EX} enabled.
 * @see SetArgs#ex(long)
 * @since 6.1
 */
  public static SetArgs ex(  Duration timeout){
    return new SetArgs().ex(timeout);
  }
  /** 
 * Creates new  {@link SetArgs} and enable {@literal EXAT}.
 * @param timestamp the timestamp type: posix time in seconds.
 * @return new {@link SetArgs} with {@literal EXAT} enabled.
 * @see SetArgs#exAt(long)
 */
  public static SetArgs exAt(  long timestamp){
    return new SetArgs().exAt(timestamp);
  }
  /** 
 * Creates new  {@link SetArgs} and enable {@literal EXAT}.
 * @param timestamp the timestamp type: posix time in seconds.
 * @return new {@link SetArgs} with {@literal EXAT} enabled.
 * @see SetArgs#exAt(Date)
 * @since 6.1
 */
  public static SetArgs exAt(  Date timestamp){
    return new SetArgs().exAt(timestamp);
  }
  /** 
 * Creates new  {@link SetArgs} and enable {@literal EXAT}.
 * @param timestamp the timestamp type: posix time in seconds.
 * @return new {@link SetArgs} with {@literal EXAT} enabled.
 * @see SetArgs#exAt(Instant)
 * @since 6.1
 */
  public static SetArgs exAt(  Instant timestamp){
    return new SetArgs().exAt(timestamp);
  }
  /** 
 * Creates new  {@link SetArgs} and enable {@literal PX}.
 * @param timeout expire time in milliseconds.
 * @return new {@link SetArgs} with {@literal PX} enabled.
 * @see SetArgs#px(long)
 */
  public static SetArgs px(  long timeout){
    return new SetArgs().px(timeout);
  }
  /** 
 * Creates new  {@link SetArgs} and enable {@literal PX}.
 * @param timeout expire time in milliseconds.
 * @return new {@link SetArgs} with {@literal PX} enabled.
 * @see SetArgs#px(long)
 * @since 6.1
 */
  public static SetArgs px(  Duration timeout){
    return new SetArgs().px(timeout);
  }
  /** 
 * Creates new  {@link SetArgs} and enable {@literal PXAT}.
 * @param timestamp the timestamp type: posix time.
 * @return new {@link SetArgs} with {@literal PXAT} enabled.
 * @see SetArgs#pxAt(long)
 */
  public static SetArgs pxAt(  long timestamp){
    return new SetArgs().pxAt(timestamp);
  }
  /** 
 * Creates new  {@link SetArgs} and enable {@literal PXAT}.
 * @param timestamp the timestamp type: posix time.
 * @return new {@link SetArgs} with {@literal PXAT} enabled.
 * @see SetArgs#pxAt(Date)
 * @since 6.1
 */
  public static SetArgs pxAt(  Date timestamp){
    return new SetArgs().pxAt(timestamp);
  }
  /** 
 * Creates new  {@link SetArgs} and enable {@literal PXAT}.
 * @param timestamp the timestamp type: posix time.
 * @return new {@link SetArgs} with {@literal PXAT} enabled.
 * @see SetArgs#pxAt(Instant)
 * @since 6.1
 */
  public static SetArgs pxAt(  Instant timestamp){
    return new SetArgs().pxAt(timestamp);
  }
  /** 
 * Creates new  {@link SetArgs} and enable {@literal NX}.
 * @return new {@link SetArgs} with {@literal NX} enabled.
 * @see SetArgs#nx()
 */
  public static SetArgs nx(){
    return new SetArgs().nx();
  }
  /** 
 * Creates new  {@link SetArgs} and enable {@literal XX}.
 * @return new {@link SetArgs} with {@literal XX} enabled.
 * @see SetArgs#xx()
 */
  public static SetArgs xx(){
    return new SetArgs().xx();
  }
  /** 
 * Creates new  {@link SetArgs} and enable {@literal KEEPTTL}.
 * @return new {@link SetArgs} with {@literal KEEPTTL} enabled.
 * @see SetArgs#keepttl()
 * @since 5.3
 */
  public static SetArgs keepttl(){
    return new SetArgs().keepttl();
  }
}
/** 
 * Builder entry points for  {@link ShutdownArgs}.
 */
public static class Builder {
  /** 
 * Utility constructor.
 */
  private Builder(){
  }
  /** 
 * Creates new  {@link ShutdownArgs} and setting {@literal SAVE}.
 * @return new {@link ShutdownArgs} with {@literal SAVE} set.
 * @see ShutdownArgs#save(boolean)
 */
  public static ShutdownArgs save(  boolean save){
    return new ShutdownArgs().save(save);
  }
  /** 
 * Creates new  {@link ShutdownArgs} and setting {@literal NOW}.
 * @return new {@link ShutdownArgs} with {@literal NOW} set.
 * @see ShutdownArgs#now()
 */
  public static ShutdownArgs now(){
    return new ShutdownArgs().now();
  }
  /** 
 * Creates new  {@link ShutdownArgs} and setting {@literal FORCE}.
 * @return new {@link ShutdownArgs} with {@literal FORCE} set.
 * @see ShutdownArgs#force()
 */
  public static ShutdownArgs force(){
    return new ShutdownArgs().force();
  }
  /** 
 * Creates new  {@link ShutdownArgs} and setting {@literal ABORT}.
 * @return new {@link ShutdownArgs} with {@literal ABORT} set.
 * @see ShutdownArgs#abort()
 */
  public static ShutdownArgs abort(){
    return new ShutdownArgs().abort();
  }
}
/** 
 * Builder for  {@link SocketOptions}.
 */
public static class Builder {
  private Duration connectTimeout=DEFAULT_CONNECT_TIMEOUT_DURATION;
  private KeepAliveOptions keepAlive=KeepAliveOptions.builder().enable(DEFAULT_SO_KEEPALIVE).build();
  private boolean tcpNoDelay=DEFAULT_SO_NO_DELAY;
  private boolean extendedKeepAlive=false;
  private Builder(){
  }
  /** 
 * Set connection timeout. Defaults to  {@literal 10 SECONDS}. See  {@link #DEFAULT_CONNECT_TIMEOUT} and{@link #DEFAULT_CONNECT_TIMEOUT_UNIT}.
 * @param connectTimeout connection timeout, must be greater {@literal 0}.
 * @return {@code this}
 * @since 5.0
 */
  public Builder connectTimeout(  Duration connectTimeout){
    LettuceAssert.notNull(connectTimeout,"Connection timeout must not be null");
    LettuceAssert.isTrue(connectTimeout.toNanos() > 0,"Connect timeout must be greater 0");
    this.connectTimeout=connectTimeout;
    return this;
  }
  /** 
 * Set connection timeout. Defaults to  {@literal 10 SECONDS}. See  {@link #DEFAULT_CONNECT_TIMEOUT} and{@link #DEFAULT_CONNECT_TIMEOUT_UNIT}.
 * @param connectTimeout connection timeout, must be greater {@literal 0}.
 * @param connectTimeoutUnit unit for {@code connectTimeout}, must not be  {@code null}.
 * @return {@code this}
 * @deprecated since 5.0, use {@link #connectTimeout(Duration)}
 */
  @Deprecated public Builder connectTimeout(  long connectTimeout,  TimeUnit connectTimeoutUnit){
    LettuceAssert.isTrue(connectTimeout > 0,"Connect timeout must be greater 0");
    LettuceAssert.notNull(connectTimeoutUnit,"TimeUnit must not be null");
    return connectTimeout(Duration.ofNanos(connectTimeoutUnit.toNanos(connectTimeout)));
  }
  /** 
 * Set whether to enable TCP keepalive. Defaults to  {@code false}. See  {@link #DEFAULT_SO_KEEPALIVE}.
 * @param keepAlive whether to enable or disable the TCP keepalive.
 * @return {@code this}
 * @see java.net.SocketOptions#SO_KEEPALIVE
 */
  public Builder keepAlive(  boolean keepAlive){
    this.keepAlive=KeepAliveOptions.builder().enable(keepAlive).build();
    this.extendedKeepAlive=false;
    return this;
  }
  /** 
 * Configure TCP keepalive. Defaults to disabled. See  {@link #DEFAULT_SO_KEEPALIVE}.
 * @param keepAlive whether to enable or disable the TCP keepalive.
 * @return {@code this}
 * @since 6.1
 * @see KeepAliveOptions
 * @see java.net.SocketOptions#SO_KEEPALIVE
 */
  public Builder keepAlive(  KeepAliveOptions keepAlive){
    LettuceAssert.notNull(keepAlive,"KeepAlive options must not be null");
    this.keepAlive=keepAlive;
    this.extendedKeepAlive=true;
    return this;
  }
  /** 
 * Set whether to disable/enable Nagle's algorithm. Defaults to  {@code true} (Nagle disabled). See{@link #DEFAULT_SO_NO_DELAY}. <p> Disabling TCP NoDelay delays TCP  {@code ACK} packets to await more data input before confirming the packet.
 * @param tcpNoDelay {@code false} to disable TCP NoDelay (enable Nagle's algorithm), {@code true} to enable TCP NoDelay(disable Nagle's algorithm).
 * @return {@code this}
 * @see java.net.SocketOptions#TCP_NODELAY
 */
  public Builder tcpNoDelay(  boolean tcpNoDelay){
    this.tcpNoDelay=tcpNoDelay;
    return this;
  }
  /** 
 * Create a new instance of  {@link SocketOptions}
 * @return new instance of {@link SocketOptions}
 */
  public SocketOptions build(){
    return new SocketOptions(this);
  }
}
/** 
 * Builder for  {@link KeepAliveOptions}.
 */
public static class Builder {
  private int count=DEFAULT_COUNT;
  private boolean enabled=DEFAULT_SO_KEEPALIVE;
  private Duration idle=DEFAULT_IDLE;
  private Duration interval=DEFAULT_INTERVAL;
  private Builder(){
  }
  /** 
 * Set the the maximum number of keepalive probes TCP should send before dropping the connection. Defaults to {@code 9}. See also  {@link #DEFAULT_COUNT} and {@code TCP_KEEPCNT}.
 * @param count the maximum number of keepalive probes TCP
 * @return {@code this}
 */
  public KeepAliveOptions.Builder count(  int count){
    LettuceAssert.isTrue(count >= 0,"Count must be greater 0");
    this.count=count;
    return this;
  }
  /** 
 * Enable TCP keepalive. Defaults to disabled. See  {@link #DEFAULT_SO_KEEPALIVE}.
 * @return {@code this}
 * @see java.net.SocketOptions#SO_KEEPALIVE
 */
  public KeepAliveOptions.Builder enable(){
    return enable(true);
  }
  /** 
 * Disable TCP keepalive. Defaults to disabled. See  {@link #DEFAULT_SO_KEEPALIVE}.
 * @return {@code this}
 * @see java.net.SocketOptions#SO_KEEPALIVE
 */
  public KeepAliveOptions.Builder disable(){
    return enable(false);
  }
  /** 
 * Enable TCP keepalive. Defaults to  {@code false}. See  {@link #DEFAULT_SO_KEEPALIVE}.
 * @param enabled whether to enable TCP keepalive.
 * @return {@code this}
 * @see java.net.SocketOptions#SO_KEEPALIVE
 */
  public KeepAliveOptions.Builder enable(  boolean enabled){
    this.enabled=enabled;
    return this;
  }
  /** 
 * The time the connection needs to remain idle before TCP starts sending keepalive probes if keepalive is enabled. Defaults to  {@code 2 hours}. See also @link  {@link #DEFAULT_IDLE} and {@code TCP_KEEPIDLE}. <p> The time granularity of is seconds.
 * @param idle connection idle time, must be greater {@literal 0}.
 * @return {@code this}
 */
  public KeepAliveOptions.Builder idle(  Duration idle){
    LettuceAssert.notNull(idle,"Idle time must not be null");
    LettuceAssert.isTrue(!idle.isNegative(),"Idle time must not be begative");
    this.idle=idle;
    return this;
  }
  /** 
 * The time between individual keepalive probes. Defaults to  {@code 75 second}. See also  {@link #DEFAULT_INTERVAL}and  {@code TCP_KEEPINTVL}. <p> The time granularity of is seconds.
 * @param interval connection interval time, must be greater {@literal 0}
 * @return {@code this}
 */
  public KeepAliveOptions.Builder interval(  Duration interval){
    LettuceAssert.notNull(interval,"Idle time must not be null");
    LettuceAssert.isTrue(!interval.isNegative(),"Idle time must not be begative");
    this.interval=interval;
    return this;
  }
  /** 
 * Create a new instance of  {@link KeepAliveOptions}
 * @return new instance of {@link KeepAliveOptions}
 */
  public KeepAliveOptions build(){
    return new KeepAliveOptions(this);
  }
}
/** 
 * Builder entry points for  {@link SortArgs}.
 */
public static class Builder {
  /** 
 * Utility constructor.
 */
  private Builder(){
  }
  /** 
 * Creates new  {@link SortArgs} setting {@literal PATTERN}.
 * @param pattern must not be {@code null}.
 * @return new {@link SortArgs} with {@literal PATTERN} set.
 * @see SortArgs#by(String)
 */
  public static SortArgs by(  String pattern){
    return new SortArgs().by(pattern);
  }
  /** 
 * Creates new  {@link SortArgs} setting {@literal LIMIT}.
 * @param offset
 * @param count
 * @return new {@link SortArgs} with {@literal LIMIT} set.
 * @see SortArgs#limit(long,long)
 */
  public static SortArgs limit(  long offset,  long count){
    return new SortArgs().limit(offset,count);
  }
  /** 
 * Creates new  {@link SortArgs} setting {@literal GET}.
 * @param pattern must not be {@code null}.
 * @return new {@link SortArgs} with {@literal GET} set.
 * @see SortArgs#by(String)
 */
  public static SortArgs get(  String pattern){
    return new SortArgs().get(pattern);
  }
  /** 
 * Creates new  {@link SortArgs} setting {@literal ASC}.
 * @return new {@link SortArgs} with {@literal ASC} set.
 * @see SortArgs#asc()
 */
  public static SortArgs asc(){
    return new SortArgs().asc();
  }
  /** 
 * Creates new  {@link SortArgs} setting {@literal DESC}.
 * @return new {@link SortArgs} with {@literal DESC} set.
 * @see SortArgs#desc()
 */
  public static SortArgs desc(){
    return new SortArgs().desc();
  }
  /** 
 * Creates new  {@link SortArgs} setting {@literal ALPHA}.
 * @return new {@link SortArgs} with {@literal ALPHA} set.
 * @see SortArgs#alpha()
 */
  public static SortArgs alpha(){
    return new SortArgs().alpha();
  }
}
/** 
 * Builder for  {@link SslOptions}.
 */
public static class Builder {
  private SslProvider sslProvider=DEFAULT_SSL_PROVIDER;
  private String keyStoreType;
  private URL keystore;
  private char[] keystorePassword=new char[0];
  private URL truststore;
  private char[] truststorePassword=new char[0];
  private String[] protocols=null;
  private String[] cipherSuites=null;
  private Consumer<SslContextBuilder> sslContextBuilderCustomizer=contextBuilder -> {
  }
;
  private Supplier<SSLParameters> sslParametersSupplier=SSLParameters::new;
  private KeystoreAction keymanager=KeystoreAction.NO_OP;
  private KeystoreAction trustmanager=KeystoreAction.NO_OP;
  private Duration sslHandshakeTimeout=Duration.ofSeconds(10);
  private Builder(){
  }
  /** 
 * Sets the cipher suites to use.
 * @param cipherSuites cipher suites to use.
 * @return {@code this}
 * @since 5.3
 */
  public Builder cipherSuites(  String... cipherSuites){
    LettuceAssert.notNull(cipherSuites,"Cipher suites must not be null");
    this.cipherSuites=cipherSuites;
    return this;
  }
  /** 
 * Use the JDK SSL provider for SSL connections.
 * @return {@code this}
 */
  public Builder jdkSslProvider(){
    return sslProvider(SslProvider.JDK);
  }
  /** 
 * Use the OpenSSL provider for SSL connections. The OpenSSL provider requires the <a href="https://netty.io/wiki/forked-tomcat-native.html"> {@code netty-tcnative}</a> dependency with the OpenSSL JNI binary.
 * @return {@code this}
 * @throws IllegalStateException if OpenSSL is not available
 */
  public Builder openSslProvider(){
    return sslProvider(SslProvider.OPENSSL);
  }
  private Builder sslProvider(  SslProvider sslProvider){
    if (sslProvider == SslProvider.OPENSSL) {
      if (!OpenSsl.isAvailable()) {
        throw new IllegalStateException("OpenSSL SSL Provider is not available");
      }
    }
    this.sslProvider=sslProvider;
    return this;
  }
  /** 
 * Sets a timeout for the SSL handshake.
 * @param timeout {@link Duration}.
 * @return {@code this}
 * @since 5.3.2
 */
  public Builder handshakeTimeout(  Duration timeout){
    LettuceAssert.notNull(timeout,"SSL Handshake Timeout must not be null");
    this.sslHandshakeTimeout=timeout;
    return this;
  }
  /** 
 * Sets the KeyStore type. Defaults to  {@link KeyStore#getDefaultType()} if not set.
 * @param keyStoreType the keystore type to use, must not be {@code null}.
 * @return {@code this}
 * @since 5.3
 */
  public Builder keyStoreType(  String keyStoreType){
    LettuceAssert.notNull(keyStoreType,"KeyStoreType must not be null");
    this.keyStoreType=keyStoreType;
    return this;
  }
  /** 
 * Sets the Keystore file to load client certificates. The key store file must be supported by {@link java.security.KeyStore} which is {@link KeyStore#getDefaultType()} by default. The keystore is reloaded oneach connection attempt that allows to replace certificates during runtime.
 * @param keystore the keystore file, must not be {@code null}.
 * @return {@code this}
 * @since 4.4
 */
  public Builder keystore(  File keystore){
    return keystore(keystore,new char[0]);
  }
  /** 
 * Sets the Keystore file to load client certificates. The keystore file must be supported by {@link java.security.KeyStore} which is {@link KeyStore#getDefaultType()} by default. The keystore is reloaded oneach connection attempt that allows to replace certificates during runtime.
 * @param keystore the keystore file, must not be {@code null}.
 * @param keystorePassword the keystore password. May be empty to omit password and the keystore integrity check.
 * @return {@code this}
 * @since 4.4
 */
  public Builder keystore(  File keystore,  char[] keystorePassword){
    LettuceAssert.notNull(keystore,"Keystore must not be null");
    LettuceAssert.isTrue(keystore.exists(),() -> String.format("Keystore file %s does not exist",truststore));
    LettuceAssert.isTrue(keystore.isFile(),() -> String.format("Keystore %s is not a file",truststore));
    return keystore(Resource.from(keystore),keystorePassword);
  }
  /** 
 * Sets the Keystore resource to load client certificates. The keystore file must be supported by {@link java.security.KeyStore} which is {@link KeyStore#getDefaultType()} by default. The keystore is reloaded oneach connection attempt that allows to replace certificates during runtime.
 * @param keystore the keystore URL, must not be {@code null}.
 * @return {@code this}
 * @since 4.4
 */
  public Builder keystore(  URL keystore){
    return keystore(keystore,null);
  }
  /** 
 * Sets the Keystore resource to load client certificates. The keystore file must be supported by {@link java.security.KeyStore} which is {@link KeyStore#getDefaultType()} by default. The keystore is reloaded oneach connection attempt that allows to replace certificates during runtime.
 * @param keystore the keystore file, must not be {@code null}.
 * @return {@code this}
 * @since 4.4
 */
  public Builder keystore(  URL keystore,  char[] keystorePassword){
    LettuceAssert.notNull(keystore,"Keystore must not be null");
    this.keystore=keystore;
    return keystore(Resource.from(keystore),keystorePassword);
  }
  /** 
 * Sets the key file and its certificate to use for client authentication. The key is reloaded on each connection attempt that allows to replace certificates during runtime.
 * @param keyCertChainFile an X.509 certificate chain file in PEM format.
 * @param keyFile a PKCS#8 private key file in PEM format.
 * @param keyPassword the password of the {@code keyFile}, or  {@code null} if it's not password-protected.
 * @return {@code this}
 * @since 5.3
 */
  public Builder keyManager(  File keyCertChainFile,  File keyFile,  char[] keyPassword){
    LettuceAssert.notNull(keyCertChainFile,"Key certificate file must not be null");
    LettuceAssert.notNull(keyFile,"Key file must not be null");
    LettuceAssert.isTrue(keyCertChainFile.exists(),() -> String.format("Key certificate file %s does not exist",keyCertChainFile));
    LettuceAssert.isTrue(keyCertChainFile.isFile(),() -> String.format("Key certificate %s is not a file",keyCertChainFile));
    LettuceAssert.isTrue(keyFile.exists(),() -> String.format("Key file %s does not exist",keyFile));
    LettuceAssert.isTrue(keyFile.isFile(),() -> String.format("Key %s is not a file",keyFile));
    return keyManager(Resource.from(keyCertChainFile),Resource.from(keyFile),keyPassword);
  }
  /** 
 * Sets the key and its certificate to use for client authentication. The key is reloaded on each connection attempt that allows to replace certificates during runtime.
 * @param keyCertChain an {@link Resource} for a X.509 certificate chain in PEM format.
 * @param key an {@link Resource} for a PKCS#8 private key in PEM format.
 * @param keyPassword the password of the {@code keyFile}, or  {@code null} if it's not password-protected.
 * @return {@code this}
 * @since 5.3
 * @see Resource
 */
  public Builder keyManager(  Resource keyCertChain,  Resource key,  char[] keyPassword){
    LettuceAssert.notNull(keyCertChain,"KeyChain InputStreamProvider must not be null");
    LettuceAssert.notNull(key,"Key InputStreamProvider must not be null");
    char[] passwordToUse=getPassword(keyPassword);
    this.keymanager=(builder,keyStoreType) -> {
      try (InputStream keyCertChainIs=keyCertChain.get();InputStream keyIs=key.get()){
        builder.keyManager(keyCertChainIs,keyIs,passwordToUse == null || passwordToUse.length == 0 ? null : new String(passwordToUse));
      }
     }
;
    return this;
  }
  /** 
 * Sets the  {@link KeyManagerFactory}.
 * @param keyManagerFactory the {@link KeyManagerFactory} to use.
 * @return {@code this}
 * @since 5.3
 */
  public Builder keyManager(  KeyManagerFactory keyManagerFactory){
    LettuceAssert.notNull(keyManagerFactory,"KeyManagerFactory must not be null");
    this.keymanager=(builder,keyStoreType) -> builder.keyManager(keyManagerFactory);
    return this;
  }
  /** 
 * Sets the Java Keystore resource to load client certificates. The keystore file must be supported by {@link java.security.KeyStore} which is {@link KeyStore#getDefaultType()} by default. The keystore is reloaded oneach connection attempt that allows to replace certificates during runtime.
 * @param resource the provider that opens a {@link InputStream} to the keystore file, must not be {@code null}.
 * @param keystorePassword the keystore password. May be empty to omit password and the keystore integrity check.
 * @return {@code this}
 * @since 5.3
 */
  public Builder keystore(  Resource resource,  char[] keystorePassword){
    LettuceAssert.notNull(resource,"Keystore InputStreamProvider must not be null");
    char[] keystorePasswordToUse=getPassword(keystorePassword);
    this.keystorePassword=keystorePasswordToUse;
    this.keymanager=(builder,keyStoreType) -> {
      try (InputStream is=resource.get()){
        builder.keyManager(createKeyManagerFactory(is,keystorePasswordToUse,keyStoreType));
      }
     }
;
    return this;
  }
  /** 
 * Sets the protocol used for the connection established to Redis Server, such as  {@code TLSv1.2, TLSv1.1, TLSv1}.
 * @param protocols list of desired protocols to use.
 * @return {@code this}
 * @since 5.3
 */
  public Builder protocols(  String... protocols){
    LettuceAssert.notNull(protocols,"Protocols  must not be null");
    this.protocols=protocols;
    return this;
  }
  /** 
 * Sets the Truststore file to load trusted certificates. The truststore file must be supported by {@link java.security.KeyStore} which is {@link KeyStore#getDefaultType()} by default. The truststore is reloaded oneach connection attempt that allows to replace certificates during runtime.
 * @param truststore the truststore file, must not be {@code null}.
 * @return {@code this}
 */
  public Builder truststore(  File truststore){
    return truststore(truststore,null);
  }
  /** 
 * Sets the Truststore file to load trusted certificates. The truststore file must be supported by {@link java.security.KeyStore} which is {@link KeyStore#getDefaultType()} by default. The truststore is reloaded oneach connection attempt that allows to replace certificates during runtime.
 * @param truststore the truststore file, must not be {@code null}.
 * @param truststorePassword the truststore password. May be empty to omit password and the truststore integrity check.
 * @return {@code this}
 */
  public Builder truststore(  File truststore,  String truststorePassword){
    LettuceAssert.notNull(truststore,"Truststore must not be null");
    LettuceAssert.isTrue(truststore.exists(),() -> String.format("Truststore file %s does not exist",truststore));
    LettuceAssert.isTrue(truststore.isFile(),() -> String.format("Truststore file %s is not a file",truststore));
    return truststore(Resource.from(truststore),getPassword(truststorePassword));
  }
  /** 
 * Sets the Truststore resource to load trusted certificates. The truststore resource must be supported by {@link java.security.KeyStore} which is {@link KeyStore#getDefaultType()} by default. The truststore is reloaded oneach connection attempt that allows to replace certificates during runtime.
 * @param truststore the truststore file, must not be {@code null}.
 * @return {@code this}
 */
  public Builder truststore(  URL truststore){
    return truststore(truststore,null);
  }
  /** 
 * Sets the Truststore resource to load trusted certificates. The truststore resource must be supported by {@link java.security.KeyStore} which is {@link KeyStore#getDefaultType()} by default. The truststore is reloaded oneach connection attempt that allows to replace certificates during runtime.
 * @param truststore the truststore file, must not be {@code null}.
 * @param truststorePassword the truststore password. May be empty to omit password and the truststore integrity check.
 * @return {@code this}
 */
  public Builder truststore(  URL truststore,  String truststorePassword){
    LettuceAssert.notNull(truststore,"Truststore must not be null");
    this.truststore=truststore;
    return truststore(Resource.from(truststore),getPassword(truststorePassword));
  }
  /** 
 * Sets the certificate file to load trusted certificates. The file must provide X.509 certificates in PEM format. Certificates are reloaded on each connection attempt that allows to replace certificates during runtime.
 * @param certCollection the X.509 certificate collection in PEM format.
 * @return {@code this}
 * @since 5.3
 */
  public Builder trustManager(  File certCollection){
    LettuceAssert.notNull(certCollection,"Certificate collection must not be null");
    LettuceAssert.isTrue(certCollection.exists(),() -> String.format("Certificate collection file %s does not exist",certCollection));
    LettuceAssert.isTrue(certCollection.isFile(),() -> String.format("Certificate collection %s is not a file",certCollection));
    return trustManager(Resource.from(certCollection));
  }
  /** 
 * Sets the certificate resource to load trusted certificates. The file must provide X.509 certificates in PEM format. Certificates are reloaded on each connection attempt that allows to replace certificates during runtime.
 * @param certCollection the X.509 certificate collection in PEM format.
 * @return {@code this}
 * @since 5.3
 */
  public Builder trustManager(  Resource certCollection){
    LettuceAssert.notNull(certCollection,"Truststore must not be null");
    this.trustmanager=(builder,keyStoreType) -> {
      try (InputStream is=certCollection.get()){
        builder.trustManager(is);
      }
     }
;
    return this;
  }
  /** 
 * Sets the  {@link TrustManagerFactory}.
 * @param trustManagerFactory the {@link TrustManagerFactory} to use.
 * @return {@code this}
 * @since 5.3
 */
  public Builder trustManager(  TrustManagerFactory trustManagerFactory){
    LettuceAssert.notNull(trustManagerFactory,"TrustManagerFactory must not be null");
    this.trustmanager=(builder,keyStoreType) -> {
      builder.trustManager(trustManagerFactory);
    }
;
    return this;
  }
  /** 
 * Sets the Truststore resource to load trusted certificates. The truststore resource must be supported by {@link java.security.KeyStore} which is {@link KeyStore#getDefaultType()} by default. The truststore is reloaded oneach connection attempt that allows to replace certificates during runtime.
 * @param resource the provider that opens a {@link InputStream} to the keystore file, must not be {@code null}.
 * @param truststorePassword the truststore password. May be empty to omit password and the truststore integrity check.
 * @return {@code this}
 */
  public Builder truststore(  Resource resource,  char[] truststorePassword){
    LettuceAssert.notNull(resource,"Truststore InputStreamProvider must not be null");
    char[] passwordToUse=getPassword(truststorePassword);
    this.truststorePassword=passwordToUse;
    this.trustmanager=(builder,keyStoreType) -> {
      try (InputStream is=resource.get()){
        builder.trustManager(createTrustManagerFactory(is,passwordToUse,keyStoreType));
      }
     }
;
    return this;
  }
  /** 
 * Applies a  {@link SslContextBuilder} customizer by calling {@link java.util.function.Consumer#accept(Object)}
 * @param contextBuilderCustomizer builder callback to customize the {@link SslContextBuilder}.
 * @return {@code this}
 * @since 5.3
 */
  public Builder sslContext(  Consumer<SslContextBuilder> contextBuilderCustomizer){
    LettuceAssert.notNull(contextBuilderCustomizer,"SslContextBuilder customizer must not be null");
    this.sslContextBuilderCustomizer=contextBuilderCustomizer;
    return this;
  }
  /** 
 * Configures a  {@link Supplier} to create {@link SSLParameters}.
 * @param sslParametersSupplier {@link Supplier} for {@link SSLParameters}.
 * @return {@code this}
 * @since 5.3
 */
  public Builder sslParameters(  Supplier<SSLParameters> sslParametersSupplier){
    LettuceAssert.notNull(sslParametersSupplier,"SSLParameters supplier must not be null");
    this.sslParametersSupplier=sslParametersSupplier;
    return this;
  }
  /** 
 * Create a new instance of  {@link SslOptions}
 * @return new instance of {@link SslOptions}
 */
  public SslOptions build(){
    return new SslOptions(this);
  }
}
/** 
 * Builder entry points for  {@link StrAlgoArgs}.
 */
public static class Builder {
  /** 
 * Utility constructor.
 */
  private Builder(){
  }
  /** 
 * Creates new  {@link StrAlgoArgs} by keys.
 * @return new {@link StrAlgoArgs} with {@literal By KEYS} set.
 */
  public static StrAlgoArgs keys(  String... keys){
    return new StrAlgoArgs().by(By.KEYS,keys);
  }
  /** 
 * Creates new  {@link StrAlgoArgs} by strings.
 * @return new {@link StrAlgoArgs} with {@literal By STRINGS} set.
 */
  public static StrAlgoArgs strings(  String... strings){
    return new StrAlgoArgs().by(By.STRINGS,strings);
  }
  /** 
 * Creates new  {@link StrAlgoArgs} by strings and charset.
 * @return new {@link StrAlgoArgs} with {@literal By STRINGS} set.
 */
  public static StrAlgoArgs strings(  Charset charset,  String... strings){
    return new StrAlgoArgs().by(By.STRINGS,strings).charset(charset);
  }
}
/** 
 * Builder for  {@link TimeoutOptions}.
 */
public static class Builder {
  private boolean timeoutCommands=DEFAULT_TIMEOUT_COMMANDS;
  private boolean applyConnectionTimeout=false;
  private TimeoutSource source;
  /** 
 * Enable command timeouts. Disabled by default, see  {@link #DEFAULT_TIMEOUT_COMMANDS}.
 * @return {@code this}
 */
  public Builder timeoutCommands(){
    return timeoutCommands(true);
  }
  /** 
 * Configure whether commands should timeout. Disabled by default, see  {@link #DEFAULT_TIMEOUT_COMMANDS}.
 * @param enabled {@code true} to enable timeout; {@code false} to disable timeouts.
 * @return {@code this}
 */
  public Builder timeoutCommands(  boolean enabled){
    this.timeoutCommands=enabled;
    return this;
  }
  /** 
 * Set a fixed timeout for all commands.
 * @param duration the timeout {@link Duration}, must not be  {@code null}.
 * @return {@code this}
 */
  public Builder fixedTimeout(  Duration duration){
    LettuceAssert.notNull(duration,"Duration must not be null");
    return timeoutSource(new FixedTimeoutSource(duration.toNanos(),TimeUnit.NANOSECONDS));
  }
  /** 
 * Configure a  {@link TimeoutSource} that applies timeouts configured on the connection/client instance.
 * @return {@code this}
 */
  public Builder connectionTimeout(){
    return timeoutSource(new DefaultTimeoutSource());
  }
  /** 
 * Set a  {@link TimeoutSource} to obtain the timeout value per {@link RedisCommand}.
 * @param source the timeout source.
 * @return {@code this}
 */
  public Builder timeoutSource(  TimeoutSource source){
    LettuceAssert.notNull(source,"TimeoutSource must not be null");
    timeoutCommands(true);
    this.applyConnectionTimeout=source instanceof DefaultTimeoutSource;
    this.source=source;
    return this;
  }
  /** 
 * Create a new instance of  {@link TimeoutOptions}.
 * @return new instance of {@link TimeoutOptions}
 */
  public TimeoutOptions build(){
    if (timeoutCommands) {
      if (source == null) {
        throw new IllegalStateException("TimeoutSource is required for enabled timeouts");
      }
    }
    return new TimeoutOptions(timeoutCommands,applyConnectionTimeout,source);
  }
}
/** 
 * Builder entry points for  {@link TrackingArgs}.
 */
public static class Builder {
  /** 
 * Utility constructor.
 */
  private Builder(){
  }
  /** 
 * Creates new  {@link TrackingArgs} with {@literal CLIENT TRACKING ON}.
 * @return new {@link TrackingArgs}.
 * @see TrackingArgs#enabled(boolean)
 */
  public static TrackingArgs enabled(){
    return enabled(true);
  }
  /** 
 * Creates new  {@link TrackingArgs} with {@literal CLIENT TRACKING ON} if {@code enabled} is {@code true}.
 * @param enabled whether to enable key tracking for the currently connected client.
 * @return new {@link TrackingArgs}.
 * @see TrackingArgs#enabled(boolean)
 */
  public static TrackingArgs enabled(  boolean enabled){
    return new TrackingArgs().enabled(enabled);
  }
}
/** 
 * Builder entry points for  {@link XAddArgs}.
 */
public static class Builder {
  /** 
 * Utility constructor.
 */
  private Builder(){
  }
  /** 
 * Creates new  {@link XAddArgs} and setting {@literal MAXLEN}.
 * @return new {@link XAddArgs} with {@literal MAXLEN} set.
 * @see XAddArgs#maxlen(long)
 */
  public static XAddArgs maxlen(  long count){
    return new XAddArgs().maxlen(count);
  }
  /** 
 * Creates new  {@link XAddArgs} and setting {@literal NOMKSTREAM}.
 * @return new {@link XAddArgs} with {@literal NOMKSTREAM} set.
 * @see XAddArgs#nomkstream()
 * @since 6.1
 */
  public static XAddArgs nomkstream(){
    return new XAddArgs().nomkstream();
  }
  /** 
 * Creates new  {@link XAddArgs} and setting {@literal MINID}.
 * @param minid the oldest ID in the stream will be exactly the minimum between its original oldest ID and the specifiedthreshold.
 * @return new {@link XAddArgs} with {@literal MINID} set.
 * @see XAddArgs#minId(String)
 * @since 6.1
 */
  public static XAddArgs minId(  String minid){
    return new XAddArgs().minId(minid);
  }
}
/** 
 * Builder entry points for  {@link XAutoClaimArgs}.
 */
public static class Builder {
  /** 
 * Utility constructor.
 */
  private Builder(){
  }
  /** 
 * Creates new  {@link XAutoClaimArgs} and set the {@code JUSTID} flag to return just the message id and do not incrementthe retry counter. The message body is not returned when calling  {@code XAUTOCLAIM}.
 * @param consumer
 * @param minIdleTime
 * @param startId
 * @param < K >
 * @return new {@link XAutoClaimArgs} with {@code minIdleTime} and {@code startId} configured.
 */
  public static <K>XAutoClaimArgs<K> justid(  Consumer<K> consumer,  long minIdleTime,  String startId){
    return new XAutoClaimArgs<K>().justid().consumer(consumer).minIdleTime(minIdleTime).startId(startId);
  }
  /** 
 * Creates new  {@link XAutoClaimArgs} and set the {@code JUSTID} flag to return just the message id and do not incrementthe retry counter. The message body is not returned when calling  {@code XAUTOCLAIM}.
 * @param consumer
 * @param minIdleTime
 * @param startId
 * @param < K >
 * @return new {@link XAutoClaimArgs} with {@code minIdleTime} and {@code startId} configured.
 */
  public static <K>XAutoClaimArgs<K> justid(  Consumer<K> consumer,  Duration minIdleTime,  String startId){
    return new XAutoClaimArgs<K>().justid().consumer(consumer).minIdleTime(minIdleTime).startId(startId);
  }
  /** 
 * Creates new  {@link XAutoClaimArgs}.
 * @param consumer
 * @param minIdleTime
 * @param startId
 * @param < K >
 * @return new {@link XAutoClaimArgs} with {@code minIdleTime} and {@code startId} configured.
 */
  public static <K>XAutoClaimArgs<K> xautoclaim(  Consumer<K> consumer,  long minIdleTime,  String startId){
    return new XAutoClaimArgs<K>().consumer(consumer).minIdleTime(minIdleTime).startId(startId);
  }
  /** 
 * Creates new  {@link XAutoClaimArgs}.
 * @param consumer
 * @param minIdleTime
 * @param startId
 * @param < K >
 * @return new {@link XAutoClaimArgs} with {@code minIdleTime} and {@code startId} configured.
 */
  public static <K>XAutoClaimArgs<K> xautoclaim(  Consumer<K> consumer,  Duration minIdleTime,  String startId){
    return new XAutoClaimArgs<K>().consumer(consumer).minIdleTime(minIdleTime).startId(startId);
  }
}
/** 
 * Builder entry points for  {@link XAddArgs}.
 */
public static class Builder {
  /** 
 * Utility constructor.
 */
  private Builder(){
  }
  /** 
 * Creates new  {@link XClaimArgs} and set the {@code JUSTID} flag to return just the message id and do not increment theretry counter. The message body is not returned when calling  {@code XCLAIM}.
 * @return new {@link XClaimArgs} with min idle time set.
 * @see XClaimArgs#justid()
 * @since 5.3
 */
  public static XClaimArgs justid(){
    return new XClaimArgs().justid();
  }
  public static XClaimArgs minIdleTime(  long milliseconds){
    return new XClaimArgs().minIdleTime(milliseconds);
  }
  /** 
 * Creates new  {@link XClaimArgs} and set the minimum idle time.
 * @return new {@link XClaimArgs} with min idle time set.
 * @see XClaimArgs#minIdleTime(long)
 */
  public static XClaimArgs minIdleTime(  Duration minIdleTime){
    LettuceAssert.notNull(minIdleTime,"Min idle time must not be null");
    return minIdleTime(minIdleTime.toMillis());
  }
}
/** 
 * Builder entry points for  {@link XGroupCreateArgs}.
 */
public static class Builder {
  /** 
 * Utility constructor.
 */
  private Builder(){
  }
  /** 
 * Creates new  {@link XGroupCreateArgs} and set {@literal MKSTREAM}.
 * @return new {@link XGroupCreateArgs} with {@literal MKSTREAM} set.
 * @see XGroupCreateArgs#mkstream(boolean)
 */
  public static XGroupCreateArgs mkstream(){
    return mkstream(true);
  }
  /** 
 * Creates new  {@link XGroupCreateArgs} and set {@literal MKSTREAM}.
 * @param mkstream whether to apply {@literal MKSTREAM}.
 * @return new {@link XGroupCreateArgs} with {@literal MKSTREAM} set.
 * @see XGroupCreateArgs#mkstream(boolean)
 */
  public static XGroupCreateArgs mkstream(  boolean mkstream){
    return new XGroupCreateArgs().mkstream(mkstream);
  }
  /** 
 * Creates new  {@link XGroupCreateArgs} and set {@literal ENTRIESREAD}.
 * @param entriesRead number of read entries for lag tracking.
 * @return new {@link XGroupCreateArgs} with {@literal ENTRIESREAD} set.
 * @see XGroupCreateArgs#entriesRead(long)
 * @since 6.2
 */
  public static XGroupCreateArgs entriesRead(  long entriesRead){
    return new XGroupCreateArgs().entriesRead(entriesRead);
  }
}
/** 
 * Builder entry points for  {@link XPendingArgs}.
 */
public static class Builder {
  /** 
 * Utility constructor.
 */
  private Builder(){
  }
  /** 
 * Create a new  {@link XPendingArgs} .
 * @param consumer the consumer
 * @param range the range of message Id's
 * @param limit limit {@code COUNT}
 * @return a new {@link XPendingArgs} with {@link Range} and {@link Limit} applied.
 */
  public static <K>XPendingArgs<K> xpending(  Consumer<K> consumer,  Range<String> range,  Limit limit){
    return new XPendingArgs<K>().consumer(consumer).range(range).limit(limit);
  }
  /** 
 * Create a new  {@link XPendingArgs} .
 * @param group the group
 * @param range the range of message Id's
 * @param limit limit {@code COUNT}
 * @return a new {@link XPendingArgs} with {@link Range} and {@link Limit} applied.
 * @since 6.1.9
 */
  public static <K>XPendingArgs<K> xpending(  K group,  Range<String> range,  Limit limit){
    return new XPendingArgs<K>().group(group).range(range).limit(limit);
  }
}
/** 
 * Builder entry points for  {@link XReadArgs}.
 */
public static class Builder {
  /** 
 * Utility constructor.
 */
  private Builder(){
  }
  /** 
 * Create a new  {@link XReadArgs} and set {@literal BLOCK}.
 * @param milliseconds time to block.
 * @return new {@link XReadArgs} with {@literal BLOCK} set.
 * @see XReadArgs#block(long)
 */
  public static XReadArgs block(  long milliseconds){
    return new XReadArgs().block(milliseconds);
  }
  /** 
 * Create a new  {@link XReadArgs} and set {@literal BLOCK}.
 * @param timeout time to block.
 * @return new {@link XReadArgs} with {@literal BLOCK} set.
 * @see XReadArgs#block(Duration)
 */
  public static XReadArgs block(  Duration timeout){
    LettuceAssert.notNull(timeout,"Block timeout must not be null");
    return block(timeout.toMillis());
  }
  /** 
 * Create a new  {@link XReadArgs} and set {@literal COUNT}.
 * @param count
 * @return new {@link XReadArgs} with {@literal COUNT} set.
 */
  public static XReadArgs count(  long count){
    return new XReadArgs().count(count);
  }
  /** 
 * Create a new  {@link XReadArgs} and set {@literal NOACK}.
 * @return new {@link XReadArgs} with {@literal NOACK} set.
 * @see XReadArgs#noack(boolean)
 */
  public static XReadArgs noack(){
    return noack(true);
  }
  /** 
 * Create a new  {@link XReadArgs} and set {@literal NOACK}.
 * @param noack
 * @return new {@link XReadArgs} with {@literal NOACK} set.
 * @see XReadArgs#noack(boolean)
 */
  public static XReadArgs noack(  boolean noack){
    return new XReadArgs().noack(noack);
  }
}
/** 
 * Builder entry points for  {@link XTrimArgs}.
 */
public static class Builder {
  /** 
 * Utility constructor.
 */
  private Builder(){
  }
  /** 
 * Creates new  {@link XTrimArgs} and setting {@literal MAXLEN}.
 * @return new {@link XTrimArgs} with {@literal MAXLEN} set.
 * @see XTrimArgs#maxlen(long)
 */
  public static XTrimArgs maxlen(  long count){
    return new XTrimArgs().maxlen(count);
  }
  /** 
 * Creates new  {@link XTrimArgs} and setting {@literal MINID}.
 * @param minid the oldest ID in the stream will be exactly the minimum between its original oldest ID and the specifiedthreshold.
 * @return new {@link XTrimArgs} with {@literal MINID} set.
 * @see XTrimArgs#minId(String)
 */
  public static XTrimArgs minId(  String minid){
    return new XTrimArgs().minId(minid);
  }
}
/** 
 * Builder entry points for  {@link ScanArgs}.
 */
public static class Builder {
  /** 
 * Utility constructor.
 */
  private Builder(){
  }
  /** 
 * Creates new  {@link ZAddArgs} and enabling {@literal NX}.
 * @return new {@link ZAddArgs} with {@literal NX} enabled.
 * @see ZAddArgs#nx()
 */
  public static ZAddArgs nx(){
    return new ZAddArgs().nx();
  }
  /** 
 * Creates new  {@link ZAddArgs} and enabling {@literal XX}.
 * @return new {@link ZAddArgs} with {@literal XX} enabled.
 * @see ZAddArgs#xx()
 */
  public static ZAddArgs xx(){
    return new ZAddArgs().xx();
  }
  /** 
 * Creates new  {@link ZAddArgs} and enabling {@literal CH}.
 * @return new {@link ZAddArgs} with {@literal CH} enabled.
 * @see ZAddArgs#ch()
 */
  public static ZAddArgs ch(){
    return new ZAddArgs().ch();
  }
  /** 
 * Creates new  {@link ZAddArgs} and enabling {@literal GT}.
 * @return new {@link ZAddArgs} with {@literal GT} enabled.
 * @see ZAddArgs#gt()
 * @since 6.1
 */
  public static ZAddArgs gt(){
    return new ZAddArgs().gt();
  }
  /** 
 * Creates new  {@link ZAddArgs} and enabling {@literal LT}.
 * @return new {@link ZAddArgs} with {@literal LT} enabled.
 * @see ZAddArgs#lt()
 * @since 6.1
 */
  public static ZAddArgs lt(){
    return new ZAddArgs().lt();
  }
}
/** 
 * Builder entry points for  {@link ScanArgs}.
 */
public static class Builder {
  /** 
 * Utility constructor.
 */
  Builder(){
  }
  /** 
 * Creates new  {@link ZAggregateArgs} setting {@literal WEIGHTS}.
 * @return new {@link ZAddArgs} with {@literal WEIGHTS} set.
 * @see ZAggregateArgs#weights(double...)
 */
  public static ZAggregateArgs weights(  double... weights){
    return new ZAggregateArgs().weights(weights);
  }
  /** 
 * Creates new  {@link ZAggregateArgs} setting {@literal AGGREGATE SUM}.
 * @return new {@link ZAddArgs} with {@literal AGGREGATE SUM} set.
 * @see ZAggregateArgs#sum()
 */
  public static ZAggregateArgs sum(){
    return new ZAggregateArgs().sum();
  }
  /** 
 * Creates new  {@link ZAggregateArgs} setting {@literal AGGREGATE MIN}.
 * @return new {@link ZAddArgs} with {@literal AGGREGATE MIN} set.
 * @see ZAggregateArgs#sum()
 */
  public static ZAggregateArgs min(){
    return new ZAggregateArgs().min();
  }
  /** 
 * Creates new  {@link ZAggregateArgs} setting {@literal AGGREGATE MAX}.
 * @return new {@link ZAddArgs} with {@literal AGGREGATE MAX} set.
 * @see ZAggregateArgs#sum()
 */
  public static ZAggregateArgs max(){
    return new ZAggregateArgs().max();
  }
}
/** 
 * Builder entry points for  {@link ScanArgs}.
 */
public static class Builder {
  /** 
 * Utility constructor.
 */
  private Builder(){
  }
  /** 
 * Creates new  {@link ZStoreArgs} setting {@literal WEIGHTS} using long.
 * @return new {@link ZAddArgs} with {@literal WEIGHTS} set.
 * @see ZStoreArgs#weights(long[])
 * @deprecated use {@link #weights(double...)}.
 */
  @Deprecated public static ZStoreArgs weights(  long[] weights){
    return new ZStoreArgs().weights(toDoubleArray(weights));
  }
  /** 
 * Creates new  {@link ZStoreArgs} setting {@literal WEIGHTS}.
 * @return new {@link ZAddArgs} with {@literal WEIGHTS} set.
 * @see ZStoreArgs#weights(double...)
 */
  public static ZStoreArgs weights(  double... weights){
    return new ZStoreArgs().weights(weights);
  }
  /** 
 * Creates new  {@link ZStoreArgs} setting {@literal AGGREGATE SUM}.
 * @return new {@link ZAddArgs} with {@literal AGGREGATE SUM} set.
 * @see ZStoreArgs#sum()
 */
  public static ZStoreArgs sum(){
    return new ZStoreArgs().sum();
  }
  /** 
 * Creates new  {@link ZStoreArgs} setting {@literal AGGREGATE MIN}.
 * @return new {@link ZAddArgs} with {@literal AGGREGATE MIN} set.
 * @see ZStoreArgs#sum()
 */
  public static ZStoreArgs min(){
    return new ZStoreArgs().min();
  }
  /** 
 * Creates new  {@link ZStoreArgs} setting {@literal AGGREGATE MAX}.
 * @return new {@link ZAddArgs} with {@literal AGGREGATE MAX} set.
 * @see ZStoreArgs#sum()
 */
  public static ZStoreArgs max(){
    return new ZStoreArgs().max();
  }
}
