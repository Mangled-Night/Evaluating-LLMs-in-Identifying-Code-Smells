/** 
 * Create a  {@link SecretkeyElement} which contains the secret keys listed in {@code fingerprints} and is encryptedsymmetrically using the  {@code backupCode}.
 * @param provider {@link OpenPgpProvider} for symmetric encryption.
 * @param owner owner of the secret keys (usually our jid).
 * @param fingerprints set of {@link OpenPgpV4Fingerprint}s of the keys which are going to be backed up.
 * @param backupCode passphrase for symmetric encryption.
 * @return {@link SecretkeyElement}
 * @throws PGPException PGP is brittle
 * @throws IOException IO is dangerous
 * @throws MissingOpenPgpKeyException in case one of the keys whose fingerprint is in {@code fingerprints} isnot accessible.
 */
public static SecretkeyElement createSecretkeyElement(OpenPgpProvider provider,BareJid owner,Set<OpenPgpV4Fingerprint> fingerprints,OpenPgpSecretKeyBackupPassphrase backupCode) throws PGPException, IOException, MissingOpenPgpKeyException {
  ByteArrayOutputStream buffer=new ByteArrayOutputStream();
  for (  OpenPgpV4Fingerprint fingerprint : fingerprints) {
    PGPSecretKeyRing key=provider.getStore().getSecretKeyRing(owner,fingerprint);
    if (key == null) {
      throw new MissingOpenPgpKeyException(owner,fingerprint);
    }
    byte[] bytes=key.getEncoded();
    buffer.write(bytes);
  }
  return createSecretkeyElement(buffer.toByteArray(),backupCode);
}
/** 
 * Create a  {@link SecretkeyElement} which contains the secret keys which are serialized in {@code keys} and issymmetrically encrypted using the  {@code backupCode}.
 * @see <a href="https://xmpp.org/extensions/xep-0373.html#backup-encryption">
     *     XEP-0373 ยง5.4 Encrypting the Secret Key Backup</a>
 * @param keys serialized OpenPGP secret keys in transferable key format
 * @param backupCode passphrase for symmetric encryption
 * @return {@link SecretkeyElement}
 * @throws PGPException PGP is brittle
 * @throws IOException IO is dangerous
 */
public static SecretkeyElement createSecretkeyElement(byte[] keys,OpenPgpSecretKeyBackupPassphrase backupCode) throws PGPException, IOException {
  InputStream keyStream=new ByteArrayInputStream(keys);
  ByteArrayOutputStream cryptOut=new ByteArrayOutputStream();
  EncryptionOptions encOpts=new EncryptionOptions().addPassphrase(Passphrase.fromPassword(backupCode.toString()));
  encOpts.overrideEncryptionAlgorithm(SymmetricKeyAlgorithm.AES_256);
  EncryptionStream encryptionStream=PGPainless.encryptAndOrSign().onOutputStream(cryptOut).withOptions(ProducerOptions.encrypt(encOpts).setAsciiArmor(false));
  Streams.pipeAll(keyStream,encryptionStream);
  encryptionStream.close();
  return new SecretkeyElement(Base64.encode(cryptOut.toByteArray()));
}
