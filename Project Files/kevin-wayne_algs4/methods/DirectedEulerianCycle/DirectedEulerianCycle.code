/** 
 * Computes an Eulerian cycle in the specified digraph, if one exists.
 * @param G the digraph
 */
public DirectedEulerianCycle(Digraph G){
  if (G.E() == 0)   return;
  for (int v=0; v < G.V(); v++)   if (G.outdegree(v) != G.indegree(v))   return;
  Iterator<Integer>[] adj=(Iterator<Integer>[])new Iterator[G.V()];
  for (int v=0; v < G.V(); v++)   adj[v]=G.adj(v).iterator();
  int s=nonIsolatedVertex(G);
  Stack<Integer> stack=new Stack<Integer>();
  stack.push(s);
  cycle=new Stack<Integer>();
  while (!stack.isEmpty()) {
    int v=stack.pop();
    while (adj[v].hasNext()) {
      stack.push(v);
      v=adj[v].next();
    }
    cycle.push(v);
  }
  if (cycle.size() != G.E() + 1)   cycle=null;
  assert certifySolution(G);
}
