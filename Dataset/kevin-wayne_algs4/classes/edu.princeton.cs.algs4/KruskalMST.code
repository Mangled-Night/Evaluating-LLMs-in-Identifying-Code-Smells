/** 
 * The  {@code KruskalMST} class represents a data type for computing a<em>minimum spanning tree</em> in an edge-weighted graph. The edge weights can be positive, zero, or negative and need not be distinct. If the graph is not connected, it computes a <em>minimum spanning forest</em>, which is the union of minimum spanning trees in each connected component. The  {@code weight()} method returns theweight of a minimum spanning tree and the  {@code edges()} methodreturns its edges. <p> This implementation uses <em>Kruskal's algorithm</em> and the union-find data type. The constructor takes &Theta;(<em>E</em> log <em>E</em>) time in the worst case. Each instance method takes &Theta;(1) time. It uses &Theta;(<em>E</em>) extra space (not including the graph). <p> This  {@code weight()} method correctly computes the weight of the MSTif all arithmetic performed is without floating-point rounding error or arithmetic overflow. This is the case if all edge weights are non-negative integers and the weight of the MST does not exceed 2<sup>52</sup>. <p> For additional documentation, see <a href="https://algs4.cs.princeton.edu/43mst">Section 4.3</a> of <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne. For alternate implementations, see  {@link LazyPrimMST},  {@link PrimMST}, and  {@link BoruvkaMST}.
 * @author Robert Sedgewick
 * @author Kevin Wayne
 */
public class KruskalMST {
  private static final double FLOATING_POINT_EPSILON=1.0E-12;
  private double weight;
  private Queue<Edge> mst=new Queue<Edge>();
  /** 
 * Compute a minimum spanning tree (or forest) of an edge-weighted graph.
 * @param G the edge-weighted graph
 */
  public KruskalMST(  EdgeWeightedGraph G){
    Edge[] edges=new Edge[G.E()];
    int t=0;
    for (    Edge e : G.edges()) {
      edges[t++]=e;
    }
    Arrays.sort(edges);
    UF uf=new UF(G.V());
    for (int i=0; i < G.E() && mst.size() < G.V() - 1; i++) {
      Edge e=edges[i];
      int v=e.either();
      int w=e.other(v);
      if (uf.find(v) != uf.find(w)) {
        uf.union(v,w);
        mst.enqueue(e);
        weight+=e.weight();
      }
    }
    assert check(G);
  }
  /** 
 * Returns the edges in a minimum spanning tree (or forest).
 * @return the edges in a minimum spanning tree (or forest) asan iterable of edges
 */
  public Iterable<Edge> edges(){
    return mst;
  }
  /** 
 * Returns the sum of the edge weights in a minimum spanning tree (or forest).
 * @return the sum of the edge weights in a minimum spanning tree (or forest)
 */
  public double weight(){
    return weight;
  }
  private boolean check(  EdgeWeightedGraph G){
    double total=0.0;
    for (    Edge e : edges()) {
      total+=e.weight();
    }
    if (Math.abs(total - weight()) > FLOATING_POINT_EPSILON) {
      System.err.printf("Weight of edges does not equal weight(): %f vs. %f\n",total,weight());
      return false;
    }
    UF uf=new UF(G.V());
    for (    Edge e : edges()) {
      int v=e.either(), w=e.other(v);
      if (uf.find(v) == uf.find(w)) {
        System.err.println("Not a forest");
        return false;
      }
      uf.union(v,w);
    }
    for (    Edge e : G.edges()) {
      int v=e.either(), w=e.other(v);
      if (uf.find(v) != uf.find(w)) {
        System.err.println("Not a spanning forest");
        return false;
      }
    }
    for (    Edge e : edges()) {
      uf=new UF(G.V());
      for (      Edge f : mst) {
        int x=f.either(), y=f.other(x);
        if (f != e)         uf.union(x,y);
      }
      for (      Edge f : G.edges()) {
        int x=f.either(), y=f.other(x);
        if (uf.find(x) != uf.find(y)) {
          if (f.weight() < e.weight()) {
            System.err.println("Edge " + f + " violates cut optimality conditions");
            return false;
          }
        }
      }
    }
    return true;
  }
  /** 
 * Unit tests the  {@code KruskalMST} data type.
 * @param args the command-line arguments
 */
  public static void main(  String[] args){
    In in=new In(args[0]);
    EdgeWeightedGraph G=new EdgeWeightedGraph(in);
    KruskalMST mst=new KruskalMST(G);
    for (    Edge e : mst.edges()) {
      StdOut.println(e);
    }
    StdOut.printf("%.5f\n",mst.weight());
  }
}
