/** 
 * @author Mark Paluch
 */
@ExtendWith(LettuceExtension.class) class ClusterCommandIntegrationTests extends TestSupport {
  private final RedisClient client;
  private final RedisClusterClient clusterClient;
  private final StatefulRedisConnection<String,String> connection;
  private final RedisClusterAsyncCommands<String,String> async;
  private final RedisClusterCommands<String,String> sync;
  @Inject ClusterCommandIntegrationTests(  RedisClient client,  RedisClusterClient clusterClient){
    this.client=client;
    this.clusterClient=clusterClient;
    this.connection=client.connect(RedisURI.Builder.redis(host,ClusterTestSettings.port1).build());
    this.sync=connection.sync();
    this.async=connection.async();
  }
  @AfterEach void after(){
    connection.close();
  }
  @Test void testClusterBumpEpoch(){
    RedisFuture<String> future=async.clusterBumpepoch();
    String result=TestFutures.getOrTimeout(future);
    assertThat(result).matches("(BUMPED|STILL).*");
  }
  @Test void testClusterInfo(){
    String result=sync.clusterInfo();
    assertThat(result).contains("cluster_known_nodes:");
    assertThat(result).contains("cluster_slots_fail:0");
    assertThat(result).contains("cluster_state:");
  }
  @Test void testClusterNodes(){
    String result=sync.clusterNodes();
    assertThat(result).contains("connected");
    assertThat(result).contains("master");
    assertThat(result).contains("myself");
  }
  @Test @EnabledOnCommand("EXPIRETIME") void testClusterShards(){
    List<Object> result=sync.clusterShards();
    assertThat(result).hasSize(2);
    result=connection.reactive().clusterShards().block(Duration.ofSeconds(5));
    assertThat(result).hasSize(2);
  }
  @Test @EnabledOnCommand("EXPIRETIME") void testClusterShardsParsing(){
    List<Object> result=sync.clusterShards();
    Partitions partitions=ClusterPartitionParser.parse(result);
    assertThat(partitions).hasSize(4);
    assertThat(partitions.getPartitionBySlot(1).getUri().getPort()).isIn(7379,7381);
    assertThat(partitions.getPartitionBySlot(12001).getUri().getPort()).isIn(7380,7382);
    assertThat(partitions.getPartition("127.0.0.1",7382).is(RedisClusterNode.NodeFlag.REPLICA)).isTrue();
    assertThat(partitions.getPartition("127.0.0.1",7382).is(RedisClusterNode.NodeFlag.SLAVE)).isTrue();
  }
  @Test void testClusterNodesSync(){
    StatefulRedisClusterConnection<String,String> connection=clusterClient.connect();
    String string=connection.sync().clusterNodes();
    connection.close();
    assertThat(string).contains("connected");
    assertThat(string).contains("master");
    assertThat(string).contains("myself");
  }
  @Test void testClusterReplicas(){
    sync.set("b",value);
    RedisFuture<Long> replication=async.waitForReplication(1,5);
    assertThat(TestFutures.getOrTimeout(replication)).isGreaterThan(0L);
  }
  @Test void testAsking(){
    assertThat(sync.asking()).isEqualTo("OK");
  }
  @Test void testReset(){
    clusterClient.reloadPartitions();
    StatefulRedisClusterConnection<String,String> clusterConnection=clusterClient.connect();
    TestFutures.awaitOrTimeout(clusterConnection.async().set("a","myValue1"));
    clusterConnection.reset();
    RedisFuture<String> setA=clusterConnection.async().set("a","myValue1");
    assertThat(TestFutures.getOrTimeout(setA)).isEqualTo("OK");
    assertThat(setA.getError()).isNull();
    connection.close();
  }
  @Test void testClusterSlots(){
    List<Object> reply=sync.clusterSlots();
    assertThat(reply.size()).isGreaterThan(1);
    List<ClusterSlotRange> parse=ClusterSlotsParser.parse(reply);
    assertThat(parse).hasSize(2);
    ClusterSlotRange clusterSlotRange=parse.get(0);
    assertThat(clusterSlotRange.getFrom()).isEqualTo(0);
    assertThat(clusterSlotRange.getTo()).isEqualTo(11999);
    assertThat(clusterSlotRange.toString()).contains(ClusterSlotRange.class.getSimpleName());
  }
  @Test void readOnly() throws Exception {
    String key="b";
    assertThat(SlotHash.getSlot(key)).isEqualTo(3300);
    prepareReadonlyTest(key);
    RedisCommands<String,String> connect3=client.connect(RedisURI.Builder.redis(host,ClusterTestSettings.port3).build()).sync();
    assertThat(connect3.readOnly()).isEqualTo("OK");
    waitUntilValueIsVisible(key,connect3);
    String resultBViewedByReplica=connect3.get("b");
    assertThat(resultBViewedByReplica).isEqualTo(value);
    connect3.quit();
    resultBViewedByReplica=connect3.get("b");
    assertThat(resultBViewedByReplica).isEqualTo(value);
  }
  @Test void readOnlyWithReconnect() throws Exception {
    String key="b";
    assertThat(SlotHash.getSlot(key)).isEqualTo(3300);
    prepareReadonlyTest(key);
    RedisCommands<String,String> connect3=client.connect(RedisURI.Builder.redis(host,ClusterTestSettings.port3).build()).sync();
    assertThat(connect3.readOnly()).isEqualTo("OK");
    connect3.quit();
    waitUntilValueIsVisible(key,connect3);
    String resultViewedByReplica=connect3.get("b");
    assertThat(resultViewedByReplica).isEqualTo(value);
  }
  @Test void readOnlyReadWrite() throws Exception {
    String key="b";
    assertThat(SlotHash.getSlot(key)).isEqualTo(3300);
    prepareReadonlyTest(key);
    final RedisCommands<String,String> connect3=client.connect(RedisURI.Builder.redis(host,ClusterTestSettings.port3).build()).sync();
    try {
      connect3.get("b");
    }
 catch (    Exception e) {
      assertThat(e).hasMessageContaining("MOVED");
    }
    assertThat(connect3.readOnly()).isEqualTo("OK");
    waitUntilValueIsVisible(key,connect3);
    connect3.readWrite();
    try {
      connect3.get("b");
    }
 catch (    Exception e) {
      assertThat(e).hasMessageContaining("MOVED");
    }
  }
  @Test void clusterSlaves(){
    String nodeId=getNodeId(sync);
    List<String> result=sync.clusterSlaves(nodeId);
    assertThat(result.size()).isGreaterThan(0);
  }
  @Test void clusterReplicas(){
    String nodeId=getNodeId(sync);
    List<String> result=sync.clusterReplicas(nodeId);
    assertThat(result.size()).isGreaterThan(0);
  }
  private void prepareReadonlyTest(  String key){
    async.set(key,value);
    String resultB=TestFutures.getOrTimeout(async.get(key));
    assertThat(resultB).isEqualTo(value);
    Delay.delay(Duration.ofMillis(500));
  }
  private static void waitUntilValueIsVisible(  String key,  RedisCommands<String,String> commands){
    Wait.untilTrue(() -> commands.get(key) != null).waitOrTimeout();
  }
}
