public static final class Builder {
  private DomainBareJid service;
  private String serviceTlsPin;
  private SecurityMode securityMode;
  private int replyTimeout;
  private String adminAccountUsername;
  private String adminAccountPassword;
  private String accountOneUsername;
  private String accountOnePassword;
  private String accountTwoUsername;
  private String accountTwoPassword;
  public String accountThreeUsername;
  public String accountThreePassword;
  private Debugger debugger=Debugger.none;
  private Set<String> enabledTests;
  private Set<String> disabledTests;
  private String defaultConnectionNickname;
  private Set<String> enabledConnections;
  private Set<String> disabledConnections;
  private Set<String> testPackages;
  private boolean verbose;
  private DnsResolver dnsResolver=DnsResolver.minidns;
  private CompatibilityMode compatibilityMode=CompatibilityMode.standardsCompliant;
  private Builder(){
  }
  public Builder setService(  String service) throws XmppStringprepException {
    if (service == null) {
      return this;
    }
    return setService(JidCreate.domainBareFrom(service));
  }
  public Builder setService(  DomainBareJid service){
    this.service=service;
    return this;
  }
  public Builder addEnabledTest(  Class<? extends AbstractSmackIntTest> enabledTest){
    if (enabledTests == null) {
      enabledTests=new HashSet<>();
    }
    enabledTests.add(enabledTest.getName());
    return addTestPackage(enabledTest.getPackage().getName());
  }
  private void ensureTestPackagesIsSet(  int length){
    if (testPackages == null) {
      testPackages=new HashSet<>(length);
    }
  }
  public Builder addTestPackage(  String testPackage){
    ensureTestPackagesIsSet(4);
    testPackages.add(testPackage);
    return this;
  }
  public Builder setAdminAccountUsernameAndPassword(  String adminAccountUsername,  String adminAccountPassword){
    this.adminAccountUsername=StringUtils.requireNotNullNorEmpty(adminAccountUsername,"adminAccountUsername must not be null nor empty");
    this.adminAccountPassword=StringUtils.requireNotNullNorEmpty(adminAccountPassword,"adminAccountPassword must no be null nor empty");
    return this;
  }
  public Builder setUsernamesAndPassword(  String accountOneUsername,  String accountOnePassword,  String accountTwoUsername,  String accountTwoPassword,  String accountThreeUsername,  String accountThreePassword){
    this.accountOneUsername=StringUtils.requireNotNullNorEmpty(accountOneUsername,"accountOneUsername must not be null nor empty");
    this.accountOnePassword=StringUtils.requireNotNullNorEmpty(accountOnePassword,"accountOnePassword must not be null nor empty");
    this.accountTwoUsername=StringUtils.requireNotNullNorEmpty(accountTwoUsername,"accountTwoUsername must not be null nor empty");
    this.accountTwoPassword=StringUtils.requireNotNullNorEmpty(accountTwoPassword,"accountTwoPasswordmust not be null nor empty");
    this.accountThreeUsername=StringUtils.requireNotNullNorEmpty(accountThreeUsername,"accountThreeUsername must not be null nor empty");
    this.accountThreePassword=StringUtils.requireNotNullNorEmpty(accountThreePassword,"accountThreePassword must not be null nor empty");
    return this;
  }
  public Builder setServiceTlsPin(  String tlsPin){
    this.serviceTlsPin=tlsPin;
    return this;
  }
  public Builder setSecurityMode(  String securityModeString){
    if (securityModeString != null) {
      securityMode=SecurityMode.valueOf(securityModeString);
    }
 else {
      securityMode=SecurityMode.required;
    }
    return this;
  }
  public Builder setReplyTimeout(  String timeout){
    if (timeout != null) {
      replyTimeout=Integer.valueOf(timeout);
    }
    return this;
  }
  @SuppressWarnings("fallthrough") public Builder setDebugger(  String debuggerString){
    if (debuggerString == null) {
      return this;
    }
switch (debuggerString) {
case "false":
      LOGGER.warning("Debug string \"" + debuggerString + "\" is deprecated, please use \"none\" instead");
case "none":
    debugger=Debugger.none;
  break;
case "true":
LOGGER.warning("Debug string \"" + debuggerString + "\" is deprecated, please use \"console\" instead");
case "console":
debugger=Debugger.console;
break;
case "enhanced":
debugger=Debugger.enhanced;
break;
default :
throw new IllegalArgumentException("Unrecognized debugger string: " + debuggerString);
}
return this;
}
public Builder setEnabledTests(String enabledTestsString){
enabledTests=getTestSetFrom(enabledTestsString);
return this;
}
public Builder setDisabledTests(String disabledTestsString){
disabledTests=getTestSetFrom(disabledTestsString);
return this;
}
public Builder setDefaultConnection(String defaultConnectionNickname){
this.defaultConnectionNickname=defaultConnectionNickname;
return this;
}
public Builder setEnabledConnections(String enabledConnectionsString){
enabledConnections=split(enabledConnectionsString);
return this;
}
public Builder setDisabledConnections(String disabledConnectionsString){
disabledConnections=split(disabledConnectionsString);
return this;
}
public Builder addTestPackages(String testPackagesString){
if (testPackagesString != null) {
String[] testPackagesArray=testPackagesString.split(",");
ensureTestPackagesIsSet(testPackagesArray.length);
for (String s : testPackagesArray) {
testPackages.add(s.trim());
}
}
return this;
}
public Builder addTestPackages(String[] testPackagesString){
if (testPackagesString == null) {
return this;
}
ensureTestPackagesIsSet(testPackagesString.length);
for (String testPackage : testPackagesString) {
testPackages.add(testPackage);
}
return this;
}
public Builder setVerbose(boolean verbose){
this.verbose=verbose;
return this;
}
public Builder setVerbose(String verboseBooleanString){
if (verboseBooleanString == null) {
return this;
}
boolean verbose=ParserUtils.parseXmlBoolean(verboseBooleanString);
return setVerbose(verbose);
}
public Builder setDnsResolver(DnsResolver dnsResolver){
this.dnsResolver=Objects.requireNonNull(dnsResolver);
return this;
}
public Builder setDnsResolver(String dnsResolverString){
if (dnsResolverString == null) {
return this;
}
DnsResolver dnsResolver=DnsResolver.valueOf(dnsResolverString);
return setDnsResolver(dnsResolver);
}
public Builder setCompatibilityMode(CompatibilityMode compatibilityMode){
this.compatibilityMode=compatibilityMode;
return this;
}
public Builder setCompatibilityMode(String compatibilityModeString){
if (compatibilityModeString == null) {
return this;
}
CompatibilityMode compatibilityMode=CompatibilityMode.valueOf(compatibilityModeString);
return setCompatibilityMode(compatibilityMode);
}
public Configuration build() throws KeyManagementException, NoSuchAlgorithmException {
return new Configuration(this);
}
}
public static final class Builder<C extends AbstractXMPPConnection,CC extends ConnectionConfiguration,CCB extends ConnectionConfiguration.Builder<?,CC>> {
  private final Class<C> connectionClass;
  private final Class<CC> connectionConfigurationClass;
  private Consumer<CCB> extraBuilder;
  private String nickname;
  @SuppressWarnings("UnusedVariable") private Builder(  Class<C> connectionClass,  Class<CC> connectionConfigurationClass,  Class<CCB> connectionConfigurationBuilderClass){
    this.connectionClass=connectionClass;
    this.connectionConfigurationClass=connectionConfigurationClass;
    nickname=connectionClass.getSimpleName();
  }
  public Builder<C,CC,CCB> applyExtraConfguration(  Consumer<CCB> extraBuilder){
    this.extraBuilder=extraBuilder;
    return this;
  }
  public Builder<C,CC,CCB> withNickname(  String nickname){
    this.nickname=nickname;
    return this;
  }
  public XmppConnectionDescriptor<C,CC,CCB> build() throws NoSuchMethodException, SecurityException {
    return new XmppConnectionDescriptor<>(this);
  }
}
