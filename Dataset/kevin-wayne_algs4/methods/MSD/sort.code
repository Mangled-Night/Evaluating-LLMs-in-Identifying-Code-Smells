/** 
 * Rearranges the array of extended ASCII strings in ascending order.
 * @param a the array to be sorted
 */
public static void sort(String[] a){
  int n=a.length;
  String[] aux=new String[n];
  sort(a,0,n - 1,0,aux);
}
private static void sort(String[] a,int lo,int hi,int d,String[] aux){
  if (hi <= lo + CUTOFF) {
    insertion(a,lo,hi,d);
    return;
  }
  int[] count=new int[R + 2];
  for (int i=lo; i <= hi; i++) {
    int c=charAt(a[i],d);
    count[c + 2]++;
  }
  for (int r=0; r < R + 1; r++)   count[r + 1]+=count[r];
  for (int i=lo; i <= hi; i++) {
    int c=charAt(a[i],d);
    aux[count[c + 1]++]=a[i];
  }
  for (int i=lo; i <= hi; i++)   a[i]=aux[i - lo];
  for (int r=0; r < R; r++)   sort(a,lo + count[r],lo + count[r + 1] - 1,d + 1,aux);
}
/** 
 * Rearranges the array of 32-bit integers in ascending order. Currently assumes that the integers are nonnegative.
 * @param a the array to be sorted
 */
public static void sort(int[] a){
  int n=a.length;
  int[] aux=new int[n];
  sort(a,0,n - 1,0,aux);
}
private static void sort(int[] a,int lo,int hi,int d,int[] aux){
  if (hi <= lo + CUTOFF) {
    insertion(a,lo,hi);
    return;
  }
  int[] count=new int[R + 1];
  int mask=R - 1;
  int shift=BITS_PER_INT - BITS_PER_BYTE * d - BITS_PER_BYTE;
  for (int i=lo; i <= hi; i++) {
    int c=(a[i] >> shift) & mask;
    count[c + 1]++;
  }
  for (int r=0; r < R; r++)   count[r + 1]+=count[r];
  if (d == 0) {
    int shift1=count[R] - count[R / 2];
    int shift2=count[R / 2];
    count[R]=shift1 + count[1];
    for (int r=0; r < R / 2; r++)     count[r]+=shift1;
    for (int r=R / 2; r < R; r++)     count[r]-=shift2;
  }
  for (int i=lo; i <= hi; i++) {
    int c=(a[i] >> shift) & mask;
    aux[count[c]++]=a[i];
  }
  for (int i=lo; i <= hi; i++)   a[i]=aux[i - lo];
  if (d == 3)   return;
  if (d == 0 && count[R / 2] > 0)   sort(a,lo,lo + count[R / 2] - 1,d + 1,aux);
  if (d != 0 && count[0] > 0)   sort(a,lo,lo + count[0] - 1,d + 1,aux);
  for (int r=0; r < R; r++)   if (count[r + 1] > count[r])   sort(a,lo + count[r],lo + count[r + 1] - 1,d + 1,aux);
}
