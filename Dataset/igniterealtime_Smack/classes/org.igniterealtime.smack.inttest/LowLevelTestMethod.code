private final class LowLevelTestMethod {
  private final Method testMethod;
  private final SmackIntegrationTest smackIntegrationTestAnnotation;
  private final boolean parameterListOfConnections;
  private LowLevelTestMethod(  Method testMethod){
    this.testMethod=testMethod;
    smackIntegrationTestAnnotation=testMethod.getAnnotation(SmackIntegrationTest.class);
    assert smackIntegrationTestAnnotation != null;
    parameterListOfConnections=testMethodParametersIsListOfConnections(testMethod);
  }
  private void invoke(  AbstractSmackLowLevelIntegrationTest test,  XmppConnectionDescriptor<?,?,?> connectionDescriptor) throws IllegalAccessException, IllegalArgumentException, InvocationTargetException, InterruptedException, SmackException, IOException, XMPPException {
    final int connectionCount;
    if (parameterListOfConnections) {
      connectionCount=smackIntegrationTestAnnotation.connectionCount();
      if (connectionCount < 1) {
        throw new IllegalArgumentException(testMethod + " is annotated to use less than one connection ('" + connectionCount+ ')');
      }
    }
 else {
      connectionCount=testMethod.getParameterCount();
    }
    List<? extends AbstractXMPPConnection> connections=connectionManager.constructConnectedConnections(connectionDescriptor,connectionCount);
    if (parameterListOfConnections) {
      testMethod.invoke(test,connections);
    }
 else {
      Object[] connectionsArray=new Object[connectionCount];
      for (int i=0; i < connectionsArray.length; i++) {
        connectionsArray[i]=connections.remove(0);
      }
      testMethod.invoke(test,connectionsArray);
    }
    connectionManager.recycle(connections);
  }
  @Override public String toString(){
    return testMethod.toString();
  }
}
