/** 
 * @author Mark Paluch
 */
@ExtendWith(LettuceExtension.class) @TestInstance(TestInstance.Lifecycle.PER_CLASS) class ScanIteratorIntegrationTests extends TestSupport {
  private final RedisCommands<String,String> redis;
  @Inject ScanIteratorIntegrationTests(  StatefulRedisConnection<String,String> connection){
    this.redis=connection.sync();
  }
  @BeforeEach void setUp(){
    this.redis.flushall();
  }
  @Test void scanShouldThrowNoSuchElementExceptionOnEmpty(){
    redis.mset(KeysAndValues.MAP);
    ScanIterator<String> scan=ScanIterator.scan(redis,ScanArgs.Builder.limit(50).match("key-foo"));
    assertThat(scan.hasNext()).isFalse();
    try {
      scan.next();
      fail("Missing NoSuchElementException");
    }
 catch (    NoSuchElementException e) {
      assertThat(e).isInstanceOf(NoSuchElementException.class);
    }
  }
  @Test void keysSinglePass(){
    redis.mset(KeysAndValues.MAP);
    ScanIterator<String> scan=ScanIterator.scan(redis,ScanArgs.Builder.limit(50).match("key-11*"));
    assertThat(scan.hasNext()).isTrue();
    assertThat(scan.hasNext()).isTrue();
    for (int i=0; i < 11; i++) {
      assertThat(scan.hasNext()).isTrue();
      assertThat(scan.next()).isNotNull();
    }
    assertThat(scan.hasNext()).isFalse();
  }
  @Test void keysMultiPass(){
    redis.mset(KeysAndValues.MAP);
    ScanIterator<String> scan=ScanIterator.scan(redis);
    List<String> keys=scan.stream().collect(Collectors.toList());
    assertThat(keys).containsAll(KeysAndValues.KEYS);
  }
  @Test void hscanShouldThrowNoSuchElementExceptionOnEmpty(){
    redis.mset(KeysAndValues.MAP);
    ScanIterator<KeyValue<String,String>> scan=ScanIterator.hscan(redis,"none",ScanArgs.Builder.limit(50).match("key-foo"));
    assertThat(scan.hasNext()).isFalse();
    try {
      scan.next();
      fail("Missing NoSuchElementException");
    }
 catch (    NoSuchElementException e) {
      assertThat(e).isInstanceOf(NoSuchElementException.class);
    }
  }
  @Test void hashSinglePass(){
    redis.hmset(key,KeysAndValues.MAP);
    ScanIterator<KeyValue<String,String>> scan=ScanIterator.hscan(redis,key,ScanArgs.Builder.limit(50).match("key-11*"));
    assertThat(scan.hasNext()).isTrue();
    assertThat(scan.hasNext()).isTrue();
    for (int i=0; i < 11; i++) {
      assertThat(scan.hasNext()).isTrue();
      assertThat(scan.next()).isNotNull();
    }
    assertThat(scan.hasNext()).isFalse();
  }
  @Test void hashMultiPass(){
    redis.hmset(key,KeysAndValues.MAP);
    ScanIterator<KeyValue<String,String>> scan=ScanIterator.hscan(redis,key);
    List<KeyValue<String,String>> keys=scan.stream().collect(Collectors.toList());
    assertThat(keys).containsAll(KeysAndValues.KEYS.stream().map(s -> KeyValue.fromNullable(s,KeysAndValues.MAP.get(s))).collect(Collectors.toList()));
  }
  @Test void sscanShouldThrowNoSuchElementExceptionOnEmpty(){
    redis.sadd(key,KeysAndValues.VALUES.toArray(new String[0]));
    ScanIterator<String> scan=ScanIterator.sscan(redis,"none",ScanArgs.Builder.limit(50).match("key-foo"));
    assertThat(scan.hasNext()).isFalse();
    try {
      scan.next();
      fail("Missing NoSuchElementException");
    }
 catch (    NoSuchElementException e) {
      assertThat(e).isInstanceOf(NoSuchElementException.class);
    }
  }
  @Test void setSinglePass(){
    redis.sadd(key,KeysAndValues.KEYS.toArray(new String[0]));
    ScanIterator<String> scan=ScanIterator.sscan(redis,key,ScanArgs.Builder.limit(50).match("key-11*"));
    assertThat(scan.hasNext()).isTrue();
    assertThat(scan.hasNext()).isTrue();
    for (int i=0; i < 11; i++) {
      assertThat(scan.hasNext()).isTrue();
      assertThat(scan.next()).isNotNull();
    }
    assertThat(scan.hasNext()).isFalse();
  }
  @Test void setMultiPass(){
    redis.sadd(key,KeysAndValues.KEYS.toArray(new String[0]));
    ScanIterator<String> scan=ScanIterator.sscan(redis,key);
    List<String> values=scan.stream().collect(Collectors.toList());
    assertThat(values).containsAll(values);
  }
  @Test void zscanShouldThrowNoSuchElementExceptionOnEmpty(){
    for (int i=0; i < KeysAndValues.COUNT; i++) {
      redis.zadd(key,ScoredValue.just(i,KeysAndValues.KEYS.get(i)));
    }
    ScanIterator<ScoredValue<String>> scan=ScanIterator.zscan(redis,"none",ScanArgs.Builder.limit(50).match("key-foo"));
    assertThat(scan.hasNext()).isFalse();
    try {
      scan.next();
      fail("Missing NoSuchElementException");
    }
 catch (    NoSuchElementException e) {
      assertThat(e).isInstanceOf(NoSuchElementException.class);
    }
  }
  @Test void zsetSinglePass(){
    for (int i=0; i < KeysAndValues.COUNT; i++) {
      redis.zadd(key,ScoredValue.just(i,KeysAndValues.KEYS.get(i)));
    }
    ScanIterator<ScoredValue<String>> scan=ScanIterator.zscan(redis,key,ScanArgs.Builder.limit(50).match("key-11*"));
    assertThat(scan.hasNext()).isTrue();
    assertThat(scan.hasNext()).isTrue();
    for (int i=0; i < 11; i++) {
      assertThat(scan.hasNext()).isTrue();
      assertThat(scan.next()).isNotNull();
    }
    assertThat(scan.hasNext()).isFalse();
  }
  @Test void zsetMultiPass(){
    List<ScoredValue<String>> expected=new ArrayList<>();
    for (int i=0; i < KeysAndValues.COUNT; i++) {
      ScoredValue<String> scoredValue=ScoredValue.just(i,KeysAndValues.KEYS.get(i));
      expected.add(scoredValue);
      redis.zadd(key,scoredValue);
    }
    ScanIterator<ScoredValue<String>> scan=ScanIterator.zscan(redis,key);
    List<ScoredValue<String>> values=scan.stream().collect(Collectors.toList());
    assertThat(values).containsAll(values);
  }
}
