public class SingleProducerSequencer extends SingleProducerSequencerFields {
  public SingleProducerSequencer(  int bufferSize,  final WaitStrategy waitStrategy){
    super(bufferSize,waitStrategy);
  }
  @Override public void claim(  long sequence){
    nextValue=sequence;
  }
  @Override public boolean isAvailable(  long sequence){
    return sequence <= cursor.get();
  }
  @Override public long getHighestPublishedSequence(  long nextSequence,  long availableSequence){
    return availableSequence;
  }
  @Override public boolean hasAvailableCapacity(  int requiredCapacity){
    long nextValue=this.nextValue;
    long wrapPoint=(nextValue + requiredCapacity) - bufferSize;
    long cachedGatingSequence=this.cachedValue;
    if (wrapPoint > cachedGatingSequence || cachedGatingSequence > nextValue) {
      long minSequence=Util.getMinimumSequence(gatingSequences,nextValue);
      this.cachedValue=minSequence;
      if (wrapPoint > minSequence) {
        return false;
      }
    }
    return true;
  }
  @Override public long remainingCapacity(){
    long nextValue=this.nextValue;
    long consumed=Util.getMinimumSequence(gatingSequences,nextValue);
    long produced=nextValue;
    return getBufferSize() - (produced - consumed);
  }
  @Override public long next(){
    return next(1);
  }
  @Override public long next(  int n){
    if (n < 1) {
      throw new IllegalArgumentException("n must be > 0");
    }
    long nextValue=this.nextValue;
    long nextSequence=nextValue + n;
    long wrapPoint=nextSequence - bufferSize;
    long cachedGatingSequence=this.cachedValue;
    if (wrapPoint > cachedGatingSequence || cachedGatingSequence > nextValue) {
      long minSequence;
      while (wrapPoint > (minSequence=Util.getMinimumSequence(gatingSequences,nextValue))) {
        waitStrategy.signalAllWhenBlocking();
        LockSupport.parkNanos(1L);
      }
      this.cachedValue=minSequence;
    }
    this.nextValue=nextSequence;
    return nextSequence;
  }
  @Override public long tryNext() throws InsufficientCapacityException {
    return tryNext(1);
  }
  @Override public long tryNext(  int n) throws InsufficientCapacityException {
    if (n < 1) {
      throw new IllegalArgumentException("n must be > 0");
    }
    if (!hasAvailableCapacity(n)) {
      throw InsufficientCapacityException.INSTANCE;
    }
    long nextSequence=this.nextValue+=n;
    return nextSequence;
  }
  @Override public void publish(  long sequence){
    cursor.set(sequence);
    waitStrategy.signalAllWhenBlocking();
  }
  @Override public void publish(  long lo,  long hi){
    publish(hi);
  }
}
