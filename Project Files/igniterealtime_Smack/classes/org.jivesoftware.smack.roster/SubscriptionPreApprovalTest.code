/** 
 * Tests that verifies the correct behavior of the pre-approval implementation.
 * @see <a href="http://xmpp.org/rfcs/rfc6121.html#sub-preapproval">Pre-Approving a Subscription Request</a>
 * @author Tomáš Havlas
 */
public class SubscriptionPreApprovalTest extends InitSmackIm {
  private DummyConnection connection;
  private Roster roster;
  private TestRosterListener rosterListener;
  @Before public void setUp() throws Exception {
    connection=new DummyConnection();
    connection.connect();
    connection.login();
    rosterListener=new TestRosterListener();
    roster=Roster.getInstanceFor(connection);
    roster.addRosterListener(rosterListener);
    connection.setReplyTimeout(1000 * 60 * 5);
  }
  @After public void tearDown() throws Exception {
    connection.disconnect();
    connection=null;
  }
  @Test(expected=FeatureNotSupportedException.class) public void testPreApprovalNotSupported() throws Throwable {
    final Jid contactJID=JidCreate.from("preapproval@example.com");
    roster.preApprove(contactJID.asBareJid());
  }
  @Test public void testPreApproveAndCreate() throws Throwable {
    final BareJid contactJID=JidCreate.bareFrom("preapproval@example.com");
    final String contactName="PreApproval";
    final String[] contactGroup={};
    connection.enableStreamFeature(SubscriptionPreApproval.INSTANCE);
    final PreApproveAndCreateEntryResponder serverSimulator=new PreApproveAndCreateEntryResponder(){
      @Override void verifyRosterUpdateRequest(      final RosterPacket updateRequest){
        final Item item=updateRequest.getRosterItems().iterator().next();
        assertSame("The provided JID doesn't match the requested!",contactJID,item.getJid());
        assertSame("The provided name doesn't match the requested!",contactName,item.getName());
        assertSame("The provided group number doesn't match the requested!",0,item.getGroupNames().size());
      }
      @Override void verifyPreApprovalRequest(      Presence preApproval){
        assertSame("The provided name doesn't match the requested!",contactJID,preApproval.getTo());
        assertSame("The provided presence type is incorrect!",Presence.Type.subscribed,preApproval.getType());
      }
    }
;
    serverSimulator.start();
    roster.preApproveAndCreateEntry(contactJID,contactName,contactGroup);
    serverSimulator.join();
    final Throwable exception=serverSimulator.getException();
    if (exception != null) {
      throw exception;
    }
    rosterListener.waitUntilInvocationOrTimeout();
    final RosterEntry addedEntry=roster.getEntry(contactJID);
    assertNotNull("The new contact wasn't added to the roster!",addedEntry);
    assertTrue("The roster listener wasn't invoked for the new contact!",rosterListener.getAddedAddresses().contains(contactJID));
    assertSame("Setup wrong name for the new contact!",contactName,addedEntry.getName());
    assertSame("Setup wrong default subscription status!",ItemType.none,addedEntry.getType());
    assertSame("The new contact should be member of exactly one group!",0,addedEntry.getGroups().size());
  }
  /** 
 * This class can be used to simulate the server response for a pre approve request request.
 */
private abstract class PreApproveAndCreateEntryResponder extends Thread {
    private Throwable exception=null;
    /** 
 * Overwrite this method to check if the received roster update request is valid.
 * @param updateRequest the request which would be sent to the server.
 */
    abstract void verifyRosterUpdateRequest(    RosterPacket updateRequest);
    /** 
 * Overwrite this method to check if received pre-approval request is valid
 * @param preApproval the request which would be sent to server.
 */
    abstract void verifyPreApprovalRequest(    Presence preApproval);
    @Override public void run(){
      try {
        while (true) {
          final Stanza packet=connection.getSentPacket();
          if (packet instanceof RosterPacket && ((IQ)packet).getType() == IQ.Type.set) {
            final RosterPacket rosterRequest=(RosterPacket)packet;
            final RosterPacket rosterPush=new RosterPacket();
            final Item item=rosterRequest.getRosterItems().iterator().next();
            if (item.getItemType() != ItemType.remove) {
              item.setItemType(ItemType.none);
            }
            rosterPush.setType(IQ.Type.set);
            rosterPush.setTo(connection.getUser());
            rosterPush.addRosterItem(item);
            connection.processStanza(rosterPush);
            final IQ response=IQ.createResultIQ(rosterRequest);
            connection.processStanza(response);
            if (rosterRequest.getRosterItemCount() != 1) {
              throw new AssertionError("A roster set MUST contain one and only one <item/> element.");
            }
            verifyRosterUpdateRequest(rosterRequest);
            break;
          }
 else           if (packet instanceof Presence && ((Presence)packet).getType() == Presence.Type.subscribed) {
            final Presence approval=(Presence)packet;
            verifyPreApprovalRequest(approval);
          }
        }
      }
 catch (      Throwable e) {
        exception=e;
        fail(e.getMessage());
      }
    }
    /** 
 * Returns the exception or error if something went wrong.
 * @return the Throwable exception or error that occurred.
 */
    public Throwable getException(){
      return exception;
    }
  }
}
