public class XmppElementUtil {
  private static final LruCache<Class<? extends XmlElement>,QName> CLASS_TO_QNAME_CACHE=new LruCache<>(512);
  public static final Logger LOGGER=Logger.getLogger(XmppElementUtil.class.getName());
  public static QName getQNameFor(  Class<? extends XmlElement> fullyQualifiedElement){
    QName qname=CLASS_TO_QNAME_CACHE.get(fullyQualifiedElement);
    if (qname != null) {
      return qname;
    }
    try {
      Object qnameObject=fullyQualifiedElement.getField("QNAME").get(null);
      if (QName.class.isAssignableFrom(qnameObject.getClass())) {
        qname=(QName)qnameObject;
        CLASS_TO_QNAME_CACHE.put(fullyQualifiedElement,qname);
        return qname;
      }
      LOGGER.warning("The QNAME field of " + fullyQualifiedElement + " is not of type QNAME.");
    }
 catch (    NoSuchFieldException e) {
      LOGGER.finer("The " + fullyQualifiedElement + " has no static QNAME field. Consider adding one.");
    }
catch (    IllegalArgumentException|IllegalAccessException|SecurityException e) {
      throw new IllegalArgumentException(e);
    }
    String element, namespace;
    try {
      element=(String)fullyQualifiedElement.getField("ELEMENT").get(null);
      namespace=(String)fullyQualifiedElement.getField("NAMESPACE").get(null);
    }
 catch (    IllegalArgumentException|IllegalAccessException|NoSuchFieldException|SecurityException e) {
      throw new IllegalArgumentException("The " + fullyQualifiedElement + " has no ELEMENT, NAMESPACE or QNAME member. Consider adding QNAME",e);
    }
    qname=new QName(namespace,element);
    CLASS_TO_QNAME_CACHE.put(fullyQualifiedElement,qname);
    return qname;
  }
  public static <E extends ExtensionElement>List<E> getElementsFrom(  MultiMap<QName,XmlElement> elementMap,  Class<E> extensionElementClass){
    QName qname=XmppElementUtil.getQNameFor(extensionElementClass);
    List<XmlElement> extensionElements=elementMap.getAll(qname);
    if (extensionElements.isEmpty()) {
      return Collections.emptyList();
    }
    List<E> res=new ArrayList<>(extensionElements.size());
    for (    XmlElement extensionElement : extensionElements) {
      E e=castOrThrow(extensionElement,extensionElementClass);
      res.add(e);
    }
    return res;
  }
  public static <E extends ExtensionElement>E castOrThrow(  XmlElement extensionElement,  Class<E> extensionElementClass){
    if (!extensionElementClass.isInstance(extensionElement)) {
      final QName qname=getQNameFor(extensionElementClass);
      final String detailMessage;
      if (extensionElement instanceof StandardExtensionElement) {
        detailMessage="because there is no according extension element provider registered with ProviderManager for " + qname + ". WARNING: This indicates a serious problem with your Smack setup, probably causing Smack not being able to properly initialize itself.";
      }
 else {
        Object provider=ProviderManager.getExtensionProvider(qname);
        detailMessage="because there is an inconsistency with the provider registered with ProviderManager: the active provider for " + qname + " '"+ provider.getClass()+ "' does not return instances of type "+ extensionElementClass+ ", but instead returns instances of type "+ extensionElement.getClass()+ ".";
      }
      String message="Extension element is not of expected class '" + extensionElementClass.getName() + "', "+ detailMessage;
      throw new IllegalStateException(message);
    }
    return extensionElementClass.cast(extensionElement);
  }
}
