private static Object convert(Class<?> cls,String string){
  Method method=null;
  Object value=null;
  if (cls.equals(String.class)) {
    value=string;
  }
 else   if (cls.equals(Boolean.TYPE)) {
    value=Boolean.valueOf(string);
  }
 else   if (cls.equals(Byte.TYPE)) {
    value=Byte.valueOf(string);
  }
 else   if (cls.equals(Short.TYPE)) {
    value=Short.valueOf(string);
  }
 else   if (cls.equals(Integer.TYPE)) {
    value=Integer.valueOf(string);
  }
 else   if (cls.equals(Long.TYPE)) {
    value=Long.valueOf(string);
  }
 else   if (cls.equals(Double.TYPE)) {
    value=Double.valueOf(string);
  }
 else   if (cls.equals(Float.TYPE)) {
    value=Float.valueOf(string);
  }
 else   if ((cls.equals(Boolean.class)) || (cls.equals(Byte.class)) || (cls.equals(Short.class))|| (cls.equals(Integer.class))|| (cls.equals(Long.class))|| (cls.equals(Float.class))|| (cls.equals(Double.class))) {
    try {
      method=cls.getMethod("valueOf",new Class[]{String.class});
      value=method.invoke(null,new Object[]{string});
    }
 catch (    Exception t) {
      LOGGER.error("valueofError",t);
      value=null;
    }
  }
 else   if (cls.equals(Class.class)) {
    try {
      value=Class.forName(string);
    }
 catch (    ClassNotFoundException e) {
      throw new ConfigException(e);
    }
  }
 else {
    value=null;
  }
  return (value);
}
