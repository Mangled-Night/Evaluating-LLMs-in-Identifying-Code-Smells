@SuppressWarnings("unchecked") private static class CipherCodecWrapper implements RedisCodec<Object,Object>, ToByteBufEncoder<Object,Object> {
  private RedisCodec<Object,Object> delegate;
  private CipherSupplier encrypt;
  private CipherSupplier decrypt;
  CipherCodecWrapper(  RedisCodec<Object,Object> delegate,  CipherSupplier encrypt,  CipherSupplier decrypt){
    this.delegate=delegate;
    this.encrypt=encrypt;
    this.decrypt=decrypt;
  }
  @Override public Object decodeKey(  ByteBuffer bytes){
    return delegate.decodeKey(bytes);
  }
  @Override public Object decodeValue(  ByteBuffer bytes){
    KeyDescriptor keyDescriptor=KeyDescriptor.from(bytes);
    try {
      return delegate.decodeValue(doWithCipher(this.decrypt.get(keyDescriptor),bytes));
    }
 catch (    GeneralSecurityException e) {
      throw new IllegalStateException(e);
    }
  }
  @Override public void encodeKey(  Object key,  ByteBuf target){
    if (delegate instanceof ToByteBufEncoder) {
      ((ToByteBufEncoder)delegate).encodeKey(key,target);
      return;
    }
    target.writeBytes(delegate.encodeKey(key));
  }
  @Override public void encodeValue(  Object value,  ByteBuf target){
    ByteBuf serialized;
    if (delegate instanceof ToByteBufEncoder) {
      serialized=target.alloc().buffer(estimateSize(value));
      ((ToByteBufEncoder)delegate).encodeKey(value,serialized);
    }
 else {
      ByteBuffer byteBuffer=delegate.encodeValue(value);
      serialized=target.alloc().buffer(byteBuffer.remaining());
      serialized.writeBytes(byteBuffer);
    }
    try {
      KeyDescriptor keyDescriptor=this.encrypt.encryptionKey();
      Cipher cipher=this.encrypt.get(keyDescriptor);
      keyDescriptor.writeTo(target);
      doWithCipher(cipher,serialized,target);
    }
 catch (    GeneralSecurityException e) {
      throw new IllegalStateException(e);
    }
 finally {
      serialized.release();
    }
  }
  @Override public int estimateSize(  Object keyOrValue){
    if (delegate instanceof ToByteBufEncoder) {
      return ((ToByteBufEncoder)delegate).estimateSize(keyOrValue);
    }
    return 16 + 8;
  }
  @Override public ByteBuffer encodeKey(  Object key){
    return delegate.encodeKey(key);
  }
  @Override public ByteBuffer encodeValue(  Object value){
    try {
      ByteBuffer serialized=delegate.encodeValue(value);
      KeyDescriptor keyDescriptor=this.encrypt.encryptionKey();
      Cipher cipher=this.encrypt.get(keyDescriptor);
      ByteBuffer intermediate=ByteBuffer.allocate(cipher.getOutputSize(serialized.remaining() + 3 + keyDescriptor.name.length+ 10));
      keyDescriptor.writeTo(intermediate);
      intermediate.put(doWithCipher(cipher,serialized));
      intermediate.flip();
      return intermediate;
    }
 catch (    GeneralSecurityException e) {
      throw new IllegalStateException(e);
    }
  }
  private void doWithCipher(  Cipher cipher,  ByteBuf serialized,  ByteBuf target) throws GeneralSecurityException {
    ByteBuffer intermediate=ByteBuffer.allocate(cipher.getOutputSize(serialized.readableBytes()));
    ByteBuffer buffer=serialized.nioBuffer();
    cipher.update(buffer,intermediate);
    cipher.doFinal(buffer,intermediate);
    intermediate.flip();
    target.writeBytes(intermediate);
    serialized.readerIndex(serialized.writerIndex());
  }
  private ByteBuffer doWithCipher(  Cipher cipher,  ByteBuffer source) throws GeneralSecurityException {
    byte[] encrypted=new byte[source.remaining()];
    source.get(encrypted);
    byte[] update=cipher.update(encrypted);
    byte[] finalBytes=cipher.doFinal();
    ByteBuffer buffer=ByteBuffer.allocate(update.length + finalBytes.length);
    buffer.put(update).put(finalBytes).flip();
    return buffer;
  }
}
