public class DruidMycatRouteStrategy extends AbstractRouteStrategy {
  public static final Logger LOGGER=LoggerFactory.getLogger(DruidMycatRouteStrategy.class);
  private static Map<Class<?>,RouteMiddlerReaultHandler> middlerResultHandler=new HashMap<>();
static {
    middlerResultHandler.put(SQLQueryExpr.class,new SQLQueryResultHandler());
    middlerResultHandler.put(SQLBinaryOpExpr.class,new BinaryOpResultHandler());
    middlerResultHandler.put(SQLInSubQueryExpr.class,new InSubQueryResultHandler());
    middlerResultHandler.put(SQLExistsExpr.class,new SQLExistsResultHandler());
    middlerResultHandler.put(SQLAllExpr.class,new SQLAllResultHandler());
  }
  @Override public RouteResultset routeNormalSqlWithAST(  SchemaConfig schema,  String stmt,  RouteResultset rrs,  String charset,  LayerCachePool cachePool,  int sqlType,  ServerConnection sc) throws SQLNonTransientException {
    if (sc != null && sc.isAllowMultiStatements() && (sqlType == ServerParse.DELETE || sqlType == ServerParse.UPDATE)) {
      return routeMultiSqlWithAST(schema,stmt,rrs,charset,cachePool,sqlType,sc);
    }
 else {
      return routeNormalSqlWithAST0(schema,stmt,rrs,charset,cachePool,sqlType,sc);
    }
  }
  private RouteResultset routeNormalSqlWithAST0(  SchemaConfig schema,  String stmt,  RouteResultset rrs,  String charset,  LayerCachePool cachePool,  int sqlType,  ServerConnection sc) throws SQLNonTransientException {
    SQLStatementParser parser=null;
    if (schema.isNeedSupportMultiDBType()) {
      parser=new MycatStatementParser(stmt);
    }
 else {
      parser=new MySqlStatementParser(stmt);
    }
    MycatSchemaStatVisitor visitor=null;
    SQLStatement statement;
    try {
      if (parser instanceof MycatStatementParser || sqlType == ServerParse.LOCK) {
        statement=parser.parseStatement();
      }
 else {
        List<SQLStatement> statementList=new ArrayList<SQLStatement>();
        parser.parseStatementList(statementList,2);
        if (statementList.size() > 1) {
          throw new SQLSyntaxErrorException("Multi statements is not supported,use single statement instead ");
        }
 else {
          statement=statementList.get(0);
        }
      }
      visitor=new MycatSchemaStatVisitor();
    }
 catch (    Exception t) {
      LOGGER.error("DruidMycatRouteStrategyError",t);
      throw new SQLSyntaxErrorException(t);
    }
    checkUnSupportedStatement(statement);
    DruidParser druidParser=DruidParserFactory.create(schema,statement,visitor);
    druidParser.parser(schema,rrs,statement,stmt,cachePool,visitor);
    DruidShardingParseInfo ctx=druidParser.getCtx();
    rrs.setTables(ctx.getTables());
    if (visitor.isSubqueryRelationOr()) {
      String err="In subQuery,the or condition is not supported.";
      LOGGER.error(err);
      throw new SQLSyntaxErrorException(err);
    }
    List<String> tables=ctx.getTables();
    SchemaConfig schemaConf=MycatServer.getInstance().getConfig().getSchemas().get(schema.getName());
    int index=0;
    RuleConfig firstRule=null;
    boolean directRoute=true;
    Set<String> firstDataNodes=new HashSet<String>();
    Map<String,TableConfig> tconfigs=schemaConf == null ? null : schemaConf.getTables();
    Map<String,RuleConfig> rulemap=new HashMap<>();
    if (tconfigs != null) {
      for (      String tableName : tables) {
        TableConfig tc=tconfigs.get(tableName);
        if (tc == null) {
          Map<String,String> tableAliasMap=ctx.getTableAliasMap();
          if (tableAliasMap != null && tableAliasMap.get(tableName) != null) {
            tc=schemaConf.getTables().get(tableAliasMap.get(tableName));
          }
        }
        if (index == 0) {
          if (tc != null) {
            firstRule=tc.getRule();
            if (firstRule == null) {
              continue;
            }
            firstDataNodes.addAll(tc.getDataNodes());
            rulemap.put(tc.getName(),firstRule);
          }
        }
 else {
          if (tc != null) {
            RuleConfig ruleCfg=tc.getRule();
            if (ruleCfg == null) {
              continue;
            }
            Set<String> dataNodes=new HashSet<>(tc.getDataNodes());
            rulemap.put(tc.getName(),ruleCfg);
            if (firstRule != null && ((ruleCfg != null && !ruleCfg.getRuleAlgorithm().equals(firstRule.getRuleAlgorithm())) || (!dataNodes.equals(firstDataNodes)))) {
              directRoute=false;
              break;
            }
          }
        }
        index++;
      }
    }
    RouteResultset rrsResult=rrs;
    if (directRoute) {
      if (!RouterUtil.isAllGlobalTable(ctx,schemaConf)) {
        if (rulemap.size() > 1 && !checkRuleField(rulemap,visitor)) {
          String err="In case of slice table,there is no rule field in the relationship condition!";
          LOGGER.error(err);
          throw new SQLSyntaxErrorException(err);
        }
      }
      rrsResult=directRoute(rrs,ctx,schema,druidParser,statement,cachePool);
    }
 else {
      int subQuerySize=visitor.getSubQuerys().size();
      if (subQuerySize == 0 && ctx.getTables().size() == 2) {
        if (!visitor.getRelationships().isEmpty()) {
          rrs.setCacheAble(false);
          rrs.setFinishedRoute(true);
          rrsResult=catletRoute(schema,ctx.getSql(),charset,sc);
        }
 else {
          rrsResult=directRoute(rrs,ctx,schema,druidParser,statement,cachePool);
        }
      }
 else       if (subQuerySize == 1) {
        SQLSelect sqlselect=visitor.getSubQuerys().iterator().next();
        if (!visitor.getRelationships().isEmpty()) {
          String err="In case of slice table,sql have different rules,the relationship condition is not supported.";
          LOGGER.error(err);
          throw new SQLSyntaxErrorException(err);
        }
 else {
          SQLSelectQuery sqlSelectQuery=sqlselect.getQuery();
          if (((MySqlSelectQueryBlock)sqlSelectQuery).getFrom() instanceof SQLExprTableSource) {
            rrs.setCacheAble(false);
            rrs.setFinishedRoute(true);
            rrsResult=middlerResultRoute(schema,charset,sqlselect,sqlType,statement,sc);
          }
        }
      }
 else       if (subQuerySize >= 2) {
        String err="In case of slice table,sql has different rules,currently only one subQuery is supported.";
        LOGGER.error(err);
        throw new SQLSyntaxErrorException(err);
      }
    }
    return rrsResult;
  }
  private RouteResultset routeMultiSqlWithAST(  SchemaConfig schema,  String stmt,  RouteResultset rrs,  String charset,  LayerCachePool cachePool,  int sqlType,  ServerConnection sc) throws SQLNonTransientException {
    List<RouteResultsetNode> allNodes=new ArrayList<>(64);
    String remingSql=stmt;
    String eachSqlItem=null;
    do {
      int index=ParseUtil.findNextBreak(remingSql);
      if (index + 1 < remingSql.length() && !ParseUtil.isEOF(remingSql,index)) {
        eachSqlItem=remingSql.substring(0,index);
        remingSql=remingSql.substring(index + 1,remingSql.length());
        RouteResultset rrsTemp=new RouteResultset(eachSqlItem,sqlType);
        RouteResultset tempRrs=routeNormalSqlWithAST0(schema,eachSqlItem,rrsTemp,charset,cachePool,sqlType,sc);
        allNodes.addAll(Arrays.asList(tempRrs.getNodes()));
      }
 else {
        RouteResultset rrsTemp=new RouteResultset(remingSql,sqlType);
        RouteResultset tempRrs=routeNormalSqlWithAST0(schema,remingSql,rrsTemp,charset,cachePool,sqlType,sc);
        allNodes.addAll(Arrays.asList(tempRrs.getNodes()));
        rrs=rrsTemp;
        break;
      }
    }
 while (true);
    if (allNodes.size() >= 1) {
      rrs.setStatement(stmt);
      rrs.setNodes(allNodes.toArray(new RouteResultsetNode[0]));
      rrs.mergeSameNode();
      return rrs;
    }
 else {
      throw new SQLNonTransientException("mycat parse error on sql:" + stmt);
    }
  }
  /** 
 * 子查询中存在关联查询的情况下,检查关联字段是否是分片字段
 * @param rulemap
 * @param ships
 * @return
 */
  private boolean checkRuleField(  Map<String,RuleConfig> rulemap,  MycatSchemaStatVisitor visitor){
    if (!MycatServer.getInstance().getConfig().getSystem().isSubqueryRelationshipCheck()) {
      return true;
    }
    Set<Relationship> ships=visitor.getRelationships();
    Iterator<Relationship> iter=ships.iterator();
    while (iter.hasNext()) {
      Relationship ship=iter.next();
      String lefttable=ship.getLeft().getTable().toUpperCase();
      String righttable=ship.getRight().getTable().toUpperCase();
      if (lefttable.equals(righttable)) {
        return true;
      }
      RuleConfig leftconfig=rulemap.get(lefttable);
      RuleConfig rightconfig=rulemap.get(righttable);
      if (null != leftconfig && null != rightconfig && leftconfig.equals(rightconfig) && leftconfig.getColumn().equals(ship.getLeft().getName().toUpperCase()) && rightconfig.getColumn().equals(ship.getRight().getName().toUpperCase())) {
        return true;
      }
    }
    return false;
  }
  private RouteResultset middlerResultRoute(  final SchemaConfig schema,  final String charset,  final SQLSelect sqlselect,  final int sqlType,  final SQLStatement statement,  final ServerConnection sc){
    final String middlesql=SQLUtils.toMySqlString(sqlselect);
    MiddlerResultHandler<String> middlerResultHandler=new MiddlerQueryResultHandler<>(new SecondHandler(){
      @Override public void doExecute(      List param){
        sc.getSession2().setMiddlerResultHandler(null);
        String sqls=null;
        RouteResultset rrs=null;
        try {
          sqls=buildSql(statement,sqlselect,param);
          rrs=MycatServer.getInstance().getRouterservice().route(MycatServer.getInstance().getConfig().getSystem(),schema,sqlType,sqls.toLowerCase(),charset,sc);
        }
 catch (        Exception e) {
          StringBuilder s=new StringBuilder();
          LOGGER.warn(s.append(this).append(sqls).toString() + " err:" + e.toString(),e);
          String msg=e.getMessage();
          sc.writeErrMessage(ErrorCode.ER_PARSE_ERROR,msg == null ? e.getClass().getSimpleName() : msg);
          return;
        }
        NonBlockingSession noBlockSession=new NonBlockingSession(sc.getSession2().getSource());
        noBlockSession.setMiddlerResultHandler(null);
        noBlockSession.setPrepared(sc.getSession2().isPrepared());
        if (rrs != null) {
          noBlockSession.setCanClose(false);
          noBlockSession.execute(rrs,ServerParse.SELECT);
        }
      }
    }
);
    sc.getSession2().setMiddlerResultHandler(middlerResultHandler);
    sc.getSession2().setCanClose(false);
    RouteResultset rrs=null;
    try {
      rrs=MycatServer.getInstance().getRouterservice().route(MycatServer.getInstance().getConfig().getSystem(),schema,ServerParse.SELECT,middlesql,charset,sc);
    }
 catch (    Exception e) {
      StringBuilder s=new StringBuilder();
      LOGGER.warn(s.append(this).append(middlesql).toString() + " err:" + e.toString(),e);
      String msg=e.getMessage();
      sc.writeErrMessage(ErrorCode.ER_PARSE_ERROR,msg == null ? e.getClass().getSimpleName() : msg);
      return null;
    }
    if (rrs != null) {
      rrs.setCacheAble(false);
    }
    return rrs;
  }
  /** 
 * 获取子查询执行结果后,改写原始sql 继续执行.
 * @param statement
 * @param sqlselect
 * @param param
 * @return
 */
  private String buildSql(  SQLStatement statement,  SQLSelect sqlselect,  List param){
    SQLObject parent=sqlselect.getParent();
    RouteMiddlerReaultHandler handler=middlerResultHandler.get(parent.getClass());
    if (handler == null) {
      throw new UnsupportedOperationException(parent.getClass() + " current is not supported ");
    }
    return handler.dohandler(statement,sqlselect,parent,param);
  }
  /** 
 * 两个表的情况，catlet
 * @param schema
 * @param stmt
 * @param charset
 * @param sc
 * @return
 */
  private RouteResultset catletRoute(  SchemaConfig schema,  String stmt,  String charset,  ServerConnection sc){
    RouteResultset rrs=null;
    try {
      rrs=MycatServer.getInstance().getRouterservice().route(MycatServer.getInstance().getConfig().getSystem(),schema,ServerParse.SELECT,"/*!mycat:catlet=io.mycat.catlets.ShareJoin */ " + stmt,charset,sc);
    }
 catch (    Exception e) {
    }
    return rrs;
  }
  /** 
 * 直接结果路由
 * @param rrs
 * @param ctx
 * @param schema
 * @param druidParser
 * @param statement
 * @param cachePool
 * @return
 * @throws SQLNonTransientException
 */
  private RouteResultset directRoute(  RouteResultset rrs,  DruidShardingParseInfo ctx,  SchemaConfig schema,  DruidParser druidParser,  SQLStatement statement,  LayerCachePool cachePool) throws SQLNonTransientException {
    druidParser.changeSql(schema,rrs,statement,cachePool);
    if (rrs.isFinishedRoute()) {
      return rrs;
    }
    if ((ctx.getTables() == null || ctx.getTables().size() == 0) && (ctx.getTableAliasMap() == null || ctx.getTableAliasMap().isEmpty())) {
      return RouterUtil.routeToSingleNode(rrs,schema.getRandomDataNode(),druidParser.getCtx().getSql());
    }
    if (druidParser.getCtx().getRouteCalculateUnits().size() == 0) {
      RouteCalculateUnit routeCalculateUnit=new RouteCalculateUnit();
      druidParser.getCtx().addRouteCalculateUnit(routeCalculateUnit);
    }
    SortedSet<RouteResultsetNode> nodeSet=new TreeSet<RouteResultsetNode>();
    boolean isAllGlobalTable=RouterUtil.isAllGlobalTable(ctx,schema);
    for (    RouteCalculateUnit unit : druidParser.getCtx().getRouteCalculateUnits()) {
      RouteResultset rrsTmp=RouterUtil.tryRouteForTables(schema,druidParser.getCtx(),unit,rrs,isSelect(statement),cachePool);
      if (rrsTmp != null && rrsTmp.getNodes() != null) {
        for (        RouteResultsetNode node : rrsTmp.getNodes()) {
          nodeSet.add(node);
        }
      }
      if (isAllGlobalTable) {
        break;
      }
    }
    RouteResultsetNode[] nodes=new RouteResultsetNode[nodeSet.size()];
    int i=0;
    for (    RouteResultsetNode aNodeSet : nodeSet) {
      nodes[i]=aNodeSet;
      if (statement instanceof MySqlInsertStatement && ctx.getTables().size() == 1 && schema.getTables().containsKey(ctx.getTables().get(0))) {
        RuleConfig rule=schema.getTables().get(ctx.getTables().get(0)).getRule();
        if (rule != null && rule.getRuleAlgorithm() instanceof SlotFunction) {
          aNodeSet.setStatement(ParseUtil.changeInsertAddSlot(aNodeSet.getStatement(),aNodeSet.getSlot()));
        }
      }
      i++;
    }
    rrs.setNodes(nodes);
    if (rrs.isDistTable()) {
      return this.routeDisTable(statement,rrs);
    }
    return rrs;
  }
  private SQLExprTableSource getDisTable(  SQLTableSource tableSource,  RouteResultsetNode node) throws SQLSyntaxErrorException {
    if (node.getSubTableName() == null) {
      String msg=" sub table not exists for " + node.getName() + " on "+ tableSource;
      LOGGER.error("DruidMycatRouteStrategyError " + msg);
      throw new SQLSyntaxErrorException(msg);
    }
    SQLIdentifierExpr sqlIdentifierExpr=new SQLIdentifierExpr();
    sqlIdentifierExpr.setParent(tableSource.getParent());
    sqlIdentifierExpr.setName(node.getSubTableName());
    SQLExprTableSource from2=new SQLExprTableSource(sqlIdentifierExpr);
    return from2;
  }
  private RouteResultset routeDisTable(  SQLStatement statement,  RouteResultset rrs) throws SQLSyntaxErrorException {
    SQLTableSource tableSource=null;
    if (statement instanceof SQLInsertStatement) {
      SQLInsertStatement insertStatement=(SQLInsertStatement)statement;
      tableSource=insertStatement.getTableSource();
      for (      RouteResultsetNode node : rrs.getNodes()) {
        SQLExprTableSource from2=getDisTable(tableSource,node);
        insertStatement.setTableSource(from2);
        node.setStatement(insertStatement.toString());
      }
    }
    if (statement instanceof SQLDeleteStatement) {
      SQLDeleteStatement deleteStatement=(SQLDeleteStatement)statement;
      tableSource=deleteStatement.getTableSource();
      SQLTableSource from=deleteStatement.getFrom();
      for (      RouteResultsetNode node : rrs.getNodes()) {
        SQLExprTableSource from2=getDisTable(tableSource,node);
        if (from == null) {
          from2.setAlias(tableSource.toString());
          deleteStatement.setFrom(from2);
        }
 else {
          String alias=from.getAlias();
          from2.setAlias(alias);
          deleteStatement.setFrom(from2);
        }
        node.setStatement(deleteStatement.toString());
      }
    }
    if (statement instanceof SQLUpdateStatement) {
      SQLUpdateStatement updateStatement=(SQLUpdateStatement)statement;
      tableSource=updateStatement.getTableSource();
      String alias=tableSource.getAlias();
      SQLExprTableSource exprSource=(SQLExprTableSource)tableSource;
      SQLIdentifierExpr expr=(SQLIdentifierExpr)exprSource.getExpr();
      alias=alias == null ? expr.getName() : alias;
      for (      RouteResultsetNode node : rrs.getNodes()) {
        SQLExprTableSource from2=getDisTable(tableSource,node);
        if (!from2.toString().equals(alias)) {
          from2.setAlias(alias);
        }
        updateStatement.setTableSource(from2);
        node.setStatement(updateStatement.toString());
      }
    }
    return rrs;
  }
  /** 
 * SELECT 语句
 */
  private boolean isSelect(  SQLStatement statement){
    if (statement instanceof SQLSelectStatement) {
      return true;
    }
    return false;
  }
  /** 
 * 检验不支持的SQLStatement类型 ：不支持的类型直接抛SQLSyntaxErrorException异常
 * @param statement
 * @throws SQLSyntaxErrorException
 */
  private void checkUnSupportedStatement(  SQLStatement statement) throws SQLSyntaxErrorException {
    if (statement instanceof SQLReplaceStatement) {
      throw new SQLSyntaxErrorException(" ReplaceStatement can't be supported,use insert into ...on duplicate key update... instead ");
    }
  }
  /** 
 * 分析 SHOW SQL
 */
  @Override public RouteResultset analyseShowSQL(  SchemaConfig schema,  RouteResultset rrs,  String stmt) throws SQLSyntaxErrorException {
    String[] fields=SchemaUtil.parseShowTable(stmt);
    if ("1".equals(fields[0])) {
      String relSchema=fields[3];
      String tableName=fields[8];
      if (relSchema != null && !relSchema.equalsIgnoreCase(schema.getName())) {
        schema=MycatServer.getInstance().getConfig().getSchemas().get(relSchema);
        if (schema == null) {
          throw new SQLSyntaxErrorException("not found schema : " + relSchema);
        }
      }
      if (StringUtils.isNotBlank(tableName) && tableName.indexOf("%") < 0 && !schema.getTables().isEmpty()) {
        TableConfig tableConfig=schema.getTables().get(tableName.toUpperCase());
        if (tableConfig != null) {
          String dataNode=RouterUtil.getAliveRandomDataNode(tableConfig);
          PhysicalDBNode dataNodeObj=MycatServer.getInstance().getConfig().getDataNodes().get(dataNode);
          if (StringUtils.isNotBlank(dataNodeObj.getDatabase())) {
            stmt=stmt.replaceAll(relSchema,dataNodeObj.getDatabase());
          }
          return RouterUtil.routeToSingleNode(rrs,dataNode,stmt);
        }
      }
      if (StringUtils.isNotBlank(relSchema)) {
        if (schema.getDataNode() != null) {
          PhysicalDBNode dataNode=MycatServer.getInstance().getConfig().getDataNodes().get(schema.getDataNode());
          stmt=stmt.replaceAll(relSchema,dataNode.getDatabase());
        }
 else {
          if (fields[2] != null) {
            stmt=stmt.replaceAll(fields[2] + "\\s*" + relSchema,"");
          }
        }
      }
      String defaultNode=schema.getDataNode();
      if (!Strings.isNullOrEmpty(defaultNode)) {
        return RouterUtil.routeToSingleNode(rrs,defaultNode,stmt);
      }
      return RouterUtil.routeToMultiNode(false,rrs,schema.getMetaDataNodes(),stmt);
    }
    String upStmt=stmt.toUpperCase();
    int[] indx=RouterUtil.getSpecPos(upStmt,0);
    if (indx[0] > 0) {
      int[] repPos={indx[0] + indx[1],0};
      String tableName=RouterUtil.getShowTableName(schema,stmt,repPos);
      int[] indx2=RouterUtil.getSpecPos(upStmt,indx[0] + indx[1] + 1);
      if (indx2[0] > 0) {
        repPos[1]=RouterUtil.getSpecEndPos(upStmt,indx2[0] + indx2[1]);
      }
      stmt=stmt.substring(0,indx[0]) + " FROM " + tableName+ stmt.substring(repPos[1]);
      RouterUtil.routeForTableMeta(rrs,schema,tableName,stmt);
      return rrs;
    }
    int[] createTabInd=RouterUtil.getCreateTablePos(upStmt,0);
    if (createTabInd[0] > 0) {
      int tableNameIndex=createTabInd[0] + createTabInd[1];
      if (upStmt.length() > tableNameIndex) {
        String tableName=stmt.substring(tableNameIndex).trim();
        int ind2=tableName.indexOf('.');
        if (ind2 > 0) {
          tableName=tableName.substring(ind2 + 1);
        }
        RouterUtil.routeForTableMeta(rrs,schema,tableName,stmt);
        return rrs;
      }
    }
    return RouterUtil.routeToSingleNode(rrs,schema.getRandomDataNode(),stmt);
  }
  public RouteResultset routeSystemInfo(  SchemaConfig schema,  int sqlType,  String stmt,  RouteResultset rrs) throws SQLSyntaxErrorException {
switch (sqlType) {
case ServerParse.SHOW:
      return analyseShowSQL(schema,rrs,stmt);
case ServerParse.SELECT:
    int index=stmt.indexOf("@@");
  if (index > 0 && "SELECT".equals(stmt.substring(0,index).trim().toUpperCase())) {
    return analyseDoubleAtSgin(schema,rrs,stmt);
  }
break;
case ServerParse.DESCRIBE:
int ind=stmt.indexOf(' ');
stmt=stmt.trim();
return analyseDescrSQL(schema,rrs,stmt,ind + 1);
}
return null;
}
/** 
 * 对Desc语句进行分析 返回数据路由集合 *
 * @param schema   				数据库名
 * @param rrs    				数据路由集合
 * @param stmt   				执行语句
 * @param ind    				第一个' '的位置
 * @return RouteResultset		(数据路由集合)
 * @author mycat
 */
private static RouteResultset analyseDescrSQL(SchemaConfig schema,RouteResultset rrs,String stmt,int ind){
final String MATCHED_FEATURE="DESCRIBE ";
final String MATCHED2_FEATURE="DESC ";
int pos=0;
while (pos < stmt.length()) {
char ch=stmt.charAt(pos);
if (ch == '/' && pos + 4 < stmt.length() && stmt.charAt(pos + 1) == '*') {
if (stmt.substring(pos + 2).indexOf("*/") != -1) {
pos+=stmt.substring(pos + 2).indexOf("*/") + 4;
continue;
}
 else {
throw new IllegalArgumentException("sql 注释 语法错误");
}
}
 else if (ch == 'D' || ch == 'd') {
if (pos + MATCHED_FEATURE.length() < stmt.length() && (stmt.substring(pos).toUpperCase().indexOf(MATCHED_FEATURE) != -1)) {
pos=pos + MATCHED_FEATURE.length();
break;
}
 else if (pos + MATCHED2_FEATURE.length() < stmt.length() && (stmt.substring(pos).toUpperCase().indexOf(MATCHED2_FEATURE) != -1)) {
pos=pos + MATCHED2_FEATURE.length();
break;
}
 else {
pos++;
}
}
 else {
break;
}
}
ind=pos;
int[] repPos={ind,0};
String tableName=RouterUtil.getTableName(stmt,repPos);
stmt=stmt.substring(0,ind) + tableName + stmt.substring(repPos[1]);
RouterUtil.routeForTableMeta(rrs,schema,tableName,stmt);
return rrs;
}
/** 
 * 根据执行语句判断数据路由
 * @param schema     			数据库名
 * @param rrs		  		 	数据路由集合
 * @param stmt		  	 		执行sql
 * @return RouteResultset		数据路由集合
 * @throws SQLSyntaxErrorException
 * @author mycat
 */
private RouteResultset analyseDoubleAtSgin(SchemaConfig schema,RouteResultset rrs,String stmt) throws SQLSyntaxErrorException {
String upStmt=stmt.toUpperCase();
int atSginInd=upStmt.indexOf(" @@");
if (atSginInd > 0) {
return RouterUtil.routeToMultiNode(false,rrs,schema.getMetaDataNodes(),stmt);
}
return RouterUtil.routeToSingleNode(rrs,schema.getRandomDataNode(),stmt);
}
}
