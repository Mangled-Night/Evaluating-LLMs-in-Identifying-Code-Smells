public class IncrSequenceMySQLHandler implements SequenceHandler {
  protected static final Logger LOGGER=LoggerFactory.getLogger(IncrSequenceMySQLHandler.class);
  private static final String SEQUENCE_DB_PROPS="sequence_db_conf.properties";
  protected static final String errSeqResult="-999999,null";
  protected static Map<String,String> latestErrors=new ConcurrentHashMap<String,String>();
  private final FetchMySQLSequnceHandler mysqlSeqFetcher=new FetchMySQLSequnceHandler();
private static class IncrSequenceMySQLHandlerHolder {
    private static final IncrSequenceMySQLHandler instance=new IncrSequenceMySQLHandler();
  }
  public static IncrSequenceMySQLHandler getInstance(){
    return IncrSequenceMySQLHandlerHolder.instance;
  }
  private IncrSequenceMySQLHandler(){
    load();
  }
  public void load(){
    Properties props=PropertiesUtil.loadProps(SEQUENCE_DB_PROPS);
    removeDesertedSequenceVals(props);
    putNewSequenceVals(props);
  }
  private void removeDesertedSequenceVals(  Properties props){
    Iterator<Map.Entry<String,SequenceVal>> i=seqValueMap.entrySet().iterator();
    while (i.hasNext()) {
      Map.Entry<String,SequenceVal> entry=i.next();
      if (!props.containsKey(entry.getKey())) {
        i.remove();
      }
    }
  }
  private void putNewSequenceVals(  Properties props){
    for (    Map.Entry<Object,Object> entry : props.entrySet()) {
      String seqName=(String)entry.getKey();
      String dataNode=(String)entry.getValue();
      if (!seqValueMap.containsKey(seqName)) {
        seqValueMap.put(seqName,new SequenceVal(seqName,dataNode));
      }
 else {
        seqValueMap.get(seqName).dataNode=dataNode;
      }
    }
  }
  /** 
 * save sequnce -> curval
 */
  private ConcurrentHashMap<String,SequenceVal> seqValueMap=new ConcurrentHashMap<String,SequenceVal>();
  @Override public long nextId(  String seqName){
    SequenceVal seqVal=seqValueMap.get(seqName);
    if (seqVal == null) {
      throw new ConfigException("can't find definition for sequence :" + seqName);
    }
    if (!seqVal.isSuccessFetched()) {
      return getSeqValueFromDB(seqVal);
    }
 else {
      return getNextValidSeqVal(seqVal);
    }
  }
  private Long getNextValidSeqVal(  SequenceVal seqVal){
    Long nexVal=seqVal.nextValue();
    if (seqVal.isNexValValid(nexVal)) {
      return nexVal;
    }
 else {
      return getSeqValueFromDB(seqVal);
    }
  }
  private long getSeqValueFromDB(  SequenceVal seqVal){
    if (LOGGER.isDebugEnabled()) {
      LOGGER.debug("get next segement of sequence from db for sequnce:" + seqVal.seqName + " curVal "+ seqVal.curVal);
    }
    boolean isLock=seqVal.fetching.compareAndSet(false,true);
    if (isLock) {
      if (seqVal.successFetched == true) {
        Long nexVal=seqVal.nextValue();
        if (seqVal.isNexValValid(nexVal)) {
          seqVal.fetching.compareAndSet(true,false);
          return nexVal;
        }
      }
      Long[] values=seqVal.fetchSequenceFromDB(mysqlSeqFetcher,1,true);
      if (values == null) {
        throw new RuntimeException("can't fetch sequnce in db,sequnce :" + seqVal.seqName + " detail:"+ mysqlSeqFetcher.getLastestError(seqVal.seqName));
      }
 else {
        seqVal.setCurValue(values[0]);
        seqVal.maxSegValue=values[1];
        seqVal.successFetched=true;
        return values[0];
      }
    }
 else {
      long count=0;
      while (seqVal.fetching.get() || seqVal.successFetched == false) {
        try {
          Thread.sleep(10);
          if (++count > 10000L) {
            return this.getSeqValueFromDB(seqVal);
          }
        }
 catch (        InterruptedException e) {
          e.printStackTrace();
          return this.getSeqValueFromDB(seqVal);
        }
      }
      return this.getNextValidSeqVal(seqVal);
    }
  }
}
