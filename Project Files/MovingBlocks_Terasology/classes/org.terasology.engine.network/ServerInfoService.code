/** 
 * Performs temporary connections to one or more game servers.
 */
public class ServerInfoService implements AutoCloseable {
  private final Bootstrap bootstrap;
  private final EventLoopGroup eventLoopGroup;
  public ServerInfoService(  Context context){
    eventLoopGroup=new NioEventLoopGroup();
    bootstrap=new Bootstrap();
    bootstrap.group(eventLoopGroup);
    bootstrap.channel(NioSocketChannel.class);
    bootstrap.handler(createWithConstructorInjection(InfoRequestPipelineFactory.class,context));
    bootstrap.option(ChannelOption.TCP_NODELAY,true);
    bootstrap.option(ChannelOption.SO_KEEPALIVE,true);
    bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS,10000);
  }
  public Future<ServerInfoMessage> requestInfo(  final String address,  final int port){
    SettableFuture<ServerInfoMessage> resultFuture=SettableFuture.create();
    InetSocketAddress remoteAddress=new InetSocketAddress(address,port);
    ChannelFuture connectCheck=bootstrap.connect(remoteAddress).addListener(connectFuture -> {
      if (!connectFuture.isSuccess()) {
        if (connectFuture.cause() != null && connectFuture.cause().getCause() != null) {
          resultFuture.setException(connectFuture.cause().getCause());
        }
 else         if (connectFuture.cause() != null) {
          resultFuture.setException(connectFuture.cause());
        }
 else {
          resultFuture.setException(new RuntimeException("Cannot connect to server"));
        }
      }
    }
);
    Channel channel=connectCheck.channel();
    channel.closeFuture().addListener(channelFuture -> {
      if (channelFuture.isSuccess()) {
        ServerInfoRequestHandler handler=channel.pipeline().get(ServerInfoRequestHandler.class);
        resultFuture.set(handler.getServerInfo());
      }
 else {
        resultFuture.setException(channelFuture.cause());
      }
    }
);
    return resultFuture;
  }
  @Override public void close(){
    eventLoopGroup.shutdownGracefully().syncUninterruptibly();
  }
}
