private class CommandProcessImpl implements CommandProcess {
  private final Process process;
  private final Tty tty;
  private List<String> args2;
  private CommandLine commandLine;
  private AtomicInteger times=new AtomicInteger();
  private AdviceListener listener=null;
  private ClassFileTransformer transformer;
  public CommandProcessImpl(  Process process,  Tty tty){
    this.process=process;
    this.tty=tty;
  }
  @Override public List<CliToken> argsTokens(){
    return args;
  }
  @Override public List<String> args(){
    return args2;
  }
  @Override public String type(){
    return tty.type();
  }
  @Override public boolean isForeground(){
    return foreground;
  }
  @Override public int width(){
    return tty.width();
  }
  @Override public int height(){
    return tty.height();
  }
  @Override public CommandLine commandLine(){
    return commandLine;
  }
  @Override public Session session(){
    return session;
  }
  @Override public AtomicInteger times(){
    return times;
  }
  public void setArgs2(  List<String> args2){
    this.args2=args2;
  }
  public void setCommandLine(  CommandLine commandLine){
    this.commandLine=commandLine;
  }
  @Override public CommandProcess stdinHandler(  Handler<String> handler){
    stdinHandler=handler;
    if (processForeground && stdinHandler != null) {
      tty.stdinHandler(stdinHandler);
    }
    return this;
  }
  @Override public CommandProcess write(  String data){
synchronized (ProcessImpl.this) {
      if (processStatus != ExecStatus.RUNNING) {
        throw new IllegalStateException("Cannot write to standard output when " + status().name().toLowerCase());
      }
    }
    processOutput.write(data);
    return this;
  }
  @Override public void echoTips(  String tips){
    processOutput.term.write(tips);
  }
  @Override public String cacheLocation(){
    return ProcessImpl.this.cacheLocation();
  }
  @Override public CommandProcess resizehandler(  Handler<Void> handler){
    resizeHandler=handler;
    tty.resizehandler(resizeHandler);
    return this;
  }
  @Override public CommandProcess interruptHandler(  Handler<Void> handler){
synchronized (ProcessImpl.this) {
      interruptHandler=handler;
    }
    return this;
  }
  @Override public CommandProcess suspendHandler(  Handler<Void> handler){
synchronized (ProcessImpl.this) {
      suspendHandler=handler;
    }
    return this;
  }
  @Override public CommandProcess resumeHandler(  Handler<Void> handler){
synchronized (ProcessImpl.this) {
      resumeHandler=handler;
    }
    return this;
  }
  @Override public CommandProcess endHandler(  Handler<Void> handler){
synchronized (ProcessImpl.this) {
      endHandler=handler;
    }
    return this;
  }
  @Override public CommandProcess backgroundHandler(  Handler<Void> handler){
synchronized (ProcessImpl.this) {
      backgroundHandler=handler;
    }
    return this;
  }
  @Override public CommandProcess foregroundHandler(  Handler<Void> handler){
synchronized (ProcessImpl.this) {
      foregroundHandler=handler;
    }
    return this;
  }
  @Override public void register(  AdviceListener adviceListener,  ClassFileTransformer transformer){
    if (adviceListener instanceof ProcessAware) {
      ProcessAware processAware=(ProcessAware)adviceListener;
      if (processAware.getProcess() == null) {
        processAware.setProcess(this.process);
      }
    }
    this.listener=adviceListener;
    AdviceWeaver.reg(listener);
    this.transformer=transformer;
  }
  @Override public void unregister(){
    if (transformer != null) {
      ArthasBootstrap.getInstance().getTransformerManager().removeTransformer(transformer);
    }
    if (listener instanceof ProcessAware) {
      if (this.process.equals(((ProcessAware)listener).getProcess())) {
        AdviceWeaver.unReg(listener);
      }
    }
 else {
      AdviceWeaver.unReg(listener);
    }
  }
  @Override public void resume(){
  }
  @Override public void suspend(){
  }
  @Override public void end(){
    end(0);
  }
  @Override public void end(  int statusCode){
    end(statusCode,null);
  }
  @Override public void end(  int statusCode,  String message){
    terminate(statusCode,null,message);
  }
  @Override public boolean isRunning(){
    return processStatus == ExecStatus.RUNNING;
  }
  @Override public void appendResult(  ResultModel result){
    if (processStatus != ExecStatus.RUNNING) {
      throw new IllegalStateException("Cannot write to standard output when " + status().name().toLowerCase());
    }
    ProcessImpl.this.appendResult(result);
  }
}
