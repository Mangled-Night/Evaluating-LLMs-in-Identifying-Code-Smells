boolean replace(K key,int hash,V oldValue,V newValue){
  lock();
  try {
    removeStale();
    HashEntry<K,V> e=getFirst(hash);
    while (e != null && (e.hash != hash || !keyEq(key,e.key()))) {
      e=e.next;
    }
    boolean replaced=false;
    if (e != null && oldValue.equals(e.value())) {
      replaced=true;
      e.setValue(newValue);
    }
    return replaced;
  }
  finally {
    unlock();
  }
}
V replace(K key,int hash,V newValue){
  lock();
  try {
    removeStale();
    HashEntry<K,V> e=getFirst(hash);
    while (e != null && (e.hash != hash || !keyEq(key,e.key()))) {
      e=e.next;
    }
    V oldValue=null;
    if (e != null) {
      oldValue=e.value();
      e.setValue(newValue);
    }
    return oldValue;
  }
  finally {
    unlock();
  }
}
/** 
 * @throws NullPointerException if any of the arguments are null
 */
public boolean replace(K key,V oldValue,V newValue){
  if (oldValue == null || newValue == null) {
    throw new NullPointerException();
  }
  int hash=hashOf(key);
  return segmentFor(hash).replace(key,hash,oldValue,newValue);
}
/** 
 * @return the previous value associated with the specified key, or<tt>null</tt> if there was no mapping for the key
 * @throws NullPointerException if the specified key or value is null
 */
public V replace(K key,V value){
  if (value == null) {
    throw new NullPointerException();
  }
  int hash=hashOf(key);
  return segmentFor(hash).replace(key,hash,value);
}
