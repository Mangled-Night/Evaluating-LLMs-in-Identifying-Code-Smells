/** 
 * Class providing the main() method for launching Terasology as a PC app. <p> Through the following launch arguments default locations to store logs and game saves can be overridden, by using the current directory or a specified one as the home directory. Furthermore, Terasology can be launched headless, to save resources while acting as a server or to run in an environment with no graphics, audio or input support. Additional arguments are available to reload the latest game on startup and to disable crash reporting. <p> When used via command line an usage help and some examples can be obtained via: <p> terasology --help    or    terasology /?
 */
@CommandLine.Command(name="terasology",usageHelpAutoWidth=true,footer="%n" + "For details, see%n" + " https://github.com/MovingBlocks/Terasology/wiki/Advanced-Options%n"+ "%n"+ "Alternatively use our standalone Launcher from%n"+ " https://github.com/MovingBlocks/TerasologyLauncher/releases") public final class Terasology implements Callable<Integer> {
  private static final Logger logger=LoggerFactory.getLogger(Terasology.class);
  @CommandLine.Spec CommandLine.Model.CommandSpec spec;
  @SuppressWarnings("unused") @Option(names={"--help","-help","/help","-h","/h","-?","/?"},usageHelp=true,description="Show help") private boolean helpRequested;
  @Option(names="--headless",description="Start headless (no graphics)") private boolean isHeadless;
  @Option(names="--max-data-size",description="Set maximum process data size [Linux only]",paramLabel="<size>",converter=DataSizeConverter.class) private Long maxDataSize;
  @Option(names="--oom-score",description="Adjust out-of-memory score [Linux only]",paramLabel="<score>") private Integer outOfMemoryScore;
  @Option(names="--crash-report",defaultValue="true",negatable=true,description="Enable crash reporting") private boolean crashReportEnabled;
  @Option(names="--sound",defaultValue="true",negatable=true,description="Enable sound") private boolean soundEnabled;
  @Option(names="--splash",defaultValue="true",negatable=true,description="Enable splash screen") private boolean splashEnabled;
  @Option(names="--load-last-game",description="Load the latest game on startup") private boolean loadLastGame;
  @Option(names="--create-last-game",description="Recreates the world of the latest game with a new save file on startup") private boolean createLastGame;
  @Option(names="--permissive-security") private boolean permissiveSecurity;
  @Option(names="--save-games",defaultValue="true",negatable=true,description="Enable new save games") private boolean saveGamesEnabled;
  @Option(names="--server-port",description="Change the server port") private Integer serverPort;
  @Option(names="--override-default-config",description="Override default config") private Path overrideConfigPath;
  @Option(names="--homedir",description="Path to home directory") private Path homeDir;
  private Terasology(){
  }
  public static void main(  String[] args){
    new CommandLine(new Terasology()).execute(args);
  }
  @Override public Integer call() throws IOException {
    handleLaunchArguments();
    setupLogging();
    SplashScreen splashScreen;
    if (splashEnabled) {
      CountDownLatch splashInitLatch=new CountDownLatch(1);
      GLFWSplashScreen glfwSplash=new GLFWSplashScreen(splashInitLatch);
      Thread thread=new Thread(glfwSplash,"splashscreen-loop");
      thread.setDaemon(true);
      thread.start();
      try {
        splashInitLatch.await(1,TimeUnit.SECONDS);
      }
 catch (      InterruptedException e) {
      }
      splashScreen=glfwSplash;
    }
 else {
      splashScreen=SplashScreenBuilder.createStub();
    }
    splashScreen.post("Java Runtime " + System.getProperty("java.version") + " loaded");
    try {
      TerasologyEngineBuilder builder=new TerasologyEngineBuilder();
      populateSubsystems(builder);
      TerasologyEngine engine=builder.build();
      engine.subscribe(newStatus -> {
        if (newStatus == StandardGameStatus.RUNNING) {
          splashScreen.close();
        }
 else {
          splashScreen.post(newStatus.getDescription());
        }
      }
);
      if (isHeadless) {
        engine.subscribeToStateChange(new HeadlessStateChangeListener(engine));
      }
      engine.initialize();
      GameState nextState=chainMainMenuToWorkAroundBug1127(selectNextGameState());
      if (nextState == null) {
        return 1;
      }
      engine.run(nextState);
    }
 catch (    Throwable e) {
      splashScreen.close();
      reportException(e);
      return 1;
    }
    return 0;
  }
  private GameState selectNextGameState(){
    GameState nextState;
    GameManifest gameManifest=getLatestGameManifest();
    if (isHeadless) {
      nextState=new StateHeadlessSetup();
    }
 else     if (loadLastGame) {
      if (gameManifest == null) {
        logger.error("Failed --load-last-game: last game not found.");
        return null;
      }
      nextState=new StateLoading(gameManifest,NetworkMode.NONE);
    }
 else     if (createLastGame) {
      if (gameManifest == null) {
        logger.error("Failed --create-last-game: last game not found.");
        return null;
      }
      String title=gameManifest.getTitle();
      if (!title.startsWith("New Created")) {
        gameManifest.setTitle("New Created " + title + " 1");
      }
 else {
        gameManifest.setTitle(getNewTitle(title));
      }
      nextState=new StateLoading(gameManifest,NetworkMode.NONE);
    }
 else {
      nextState=new StateMainMenu();
    }
    return nextState;
  }
  /** 
 * Chain states to load after MainMenu. <p> Things are broken when we're not headless and try to skip MainMenu entirely.
 * @see <a href="https://github.com/MovingBlocks/Terasology/issues/1126">#1126</a>
 * @see <a href="https://github.com/MovingBlocks/Terasology/issues/1127">#1127</a>
 */
  private GameState chainMainMenuToWorkAroundBug1127(  GameState nextState){
    if (isHeadless || nextState == null || nextState instanceof StateMainMenu) {
      return nextState;
    }
    return new StateMainMenu(){
      @Override public void init(      GameEngine gameEngine){
        super.init(gameEngine);
        gameEngine.changeState(nextState);
      }
    }
;
  }
  private static String getNewTitle(  String title){
    String newTitle=title.substring(0,getPositionOfLastDigit(title));
    int fileNumber=getLastNumber(title);
    fileNumber++;
    return (newTitle + " " + fileNumber);
  }
  private static void setupLogging(){
    Path path=PathManager.getInstance().getLogPath();
    if (path == null) {
      path=Paths.get("logs");
    }
    LoggingContext.initialize(path);
  }
  private void handleLaunchArguments() throws IOException {
    if (outOfMemoryScore != null) {
      adjustOutOfMemoryScore(outOfMemoryScore);
    }
    if (maxDataSize != null) {
      setMemoryLimit(maxDataSize);
    }
    if (homeDir != null) {
      logger.info("homeDir is {}",homeDir);
      PathManager.getInstance().useOverrideHomePath(homeDir);
    }
 else {
      PathManager.getInstance().useDefaultHomePath();
    }
    if (isHeadless) {
      crashReportEnabled=false;
      splashEnabled=false;
    }
    if (!saveGamesEnabled) {
      System.setProperty(SystemConfig.SAVED_GAMES_ENABLED_PROPERTY,"false");
    }
    if (permissiveSecurity) {
      System.setProperty(SystemConfig.PERMISSIVE_SECURITY_ENABLED_PROPERTY,"true");
    }
    if (serverPort != null) {
      System.setProperty(ConfigurationSubsystem.SERVER_PORT_PROPERTY,serverPort.toString());
    }
    if (overrideConfigPath != null) {
      System.setProperty(Config.PROPERTY_OVERRIDE_DEFAULT_CONFIG,overrideConfigPath.toString());
    }
  }
  private void populateSubsystems(  TerasologyEngineBuilder builder){
    if (isHeadless) {
      builder.add(new HeadlessGraphics()).add(new HeadlessTimer()).add(new HeadlessAudio());
    }
 else {
      EngineSubsystem audio=soundEnabled ? new LwjglAudio() : new HeadlessAudio();
      builder.add(audio).add(new LwjglGraphics()).add(new LwjglTimer()).add(new LwjglInput()).add(new BindsSubsystem()).add(new OpenVRInput());
      builder.add(new DiscordRPCSubSystem());
    }
    builder.add(new HibernationSubsystem());
  }
  private void reportException(  Throwable throwable){
    Path logPath=LoggingContext.getLoggingPath();
    if (!GraphicsEnvironment.isHeadless() && crashReportEnabled) {
      CrashReporter.report(throwable,logPath);
    }
 else {
      throwable.printStackTrace();
      System.err.println("For more details, see the log files in " + logPath.toAbsolutePath().normalize());
    }
  }
  private static GameManifest getLatestGameManifest(){
    GameInfo latestGame=null;
    List<GameInfo> savedGames=GameProvider.getSavedGames();
    for (    GameInfo savedGame : savedGames) {
      if (latestGame == null || savedGame.getTimestamp().after(latestGame.getTimestamp())) {
        latestGame=savedGame;
      }
    }
    if (latestGame == null) {
      return null;
    }
    return latestGame.getManifest();
  }
  private static int getPositionOfLastDigit(  String str){
    int position;
    for (position=str.length() - 1; position >= 0; --position) {
      char c=str.charAt(position);
      if (!Character.isDigit(c)) {
        break;
      }
    }
    return position + 1;
  }
  private static int getLastNumber(  String str){
    int positionOfLastDigit=getPositionOfLastDigit(str);
    if (positionOfLastDigit == str.length()) {
      return -1;
    }
    return Integer.parseInt(str.substring(positionOfLastDigit));
  }
  /** 
 * Limit the amount of memory the operating system will allow this program. <p> Enforced by the operating system instead of the Java Virtual Machine, this limits memory usage in a different way than setting Java's maximum heap size (the <code>-Xmx</code> java option). Use this to prevent Terasology from gobbling all your system memory if it has a memory leak. <p> Set this limit to a number larger than the maximum java heap size. It is normal for a process to need <em>some</em> additional memory outside the java heap. <p> This is currently only implemented on Linux. <p> On Windows, you may be able to set a limit using one of these external tools: <ul> <li> <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/devtest/application-verifier"> Application Verifier (<code>AppVerif.exe</code>) </a> , available from the Windows SDK </li> <li> <a href="https://github.com/lowleveldesign/process-governor"> Process Governor (<code>procgov</code>) </a> , an open source third-party tool </li> </ul>
 * @param bytes maximum allowed size
 * @see <a href="https://docs.oracle.com/en/java/javase/11/tools/java.html#GUID-3B1CE181-CD30-4178-9602-230B800D4FAE">Java command-line params</a>
 * @see <a href="https://man7.org/linux/man-pages/man2/setrlimit.2.html">setrlimit(2)</a>
 */
  private static void setMemoryLimit(  long bytes){
    if (Platform.isLinux()) {
      final LibC.Rlimit dataLimit=new LibC.Rlimit();
      dataLimit.rlim_cur=bytes;
      dataLimit.rlim_max=bytes;
      LibC.INSTANCE.setrlimit(LibC.RLIMIT_DATA,dataLimit);
    }
 else {
      logger.warn("--max-data-size is not supported on platform {}",Platform.RESOURCE_PREFIX);
    }
  }
  /** 
 * Make the Linux Out-of-Memory killer more likely to pick Terasology. <p> When a Linux system runs out of available memory, it invokes the Out of Memory killer (aka <i>OOM killer</i>) to choose a process to terminate to free up some memory. <p> Add to this score if you want to make Terasology a bigger target. Why? If you'd rather the game process be the thing that gets killed instead of some other memory-hungry program, like your browser or IDE. A score of 1000 is equivalent to saying “this process is taking <em>all</em> the memory.” <p> This out-of-memory score is a Linux-specific mechanism.
 * @param adjustment how much worse to make the score, 0–1000
 * @see <a href="https://man7.org/linux/man-pages/man5/proc.5.html#:~:text=/proc/%5Bpid%5D/-,oom_score_adj,-(since">proc(5)</a>
 */
  private static void adjustOutOfMemoryScore(  int adjustment){
    Path procFile=Paths.get("/proc","self","oom_score_adj");
    try {
      Files.write(procFile,String.valueOf(adjustment).getBytes(),StandardOpenOption.WRITE,StandardOpenOption.TRUNCATE_EXISTING);
    }
 catch (    IOException e) {
      logger.error("Failed to adjust out-of-memory score.",e);
    }
  }
}
