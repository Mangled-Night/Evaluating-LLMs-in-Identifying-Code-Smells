/** 
 * A reactive and thread-safe API for a Redis pub/sub connection.
 * @param < K > Key type.
 * @param < V > Value type.
 * @author Mark Paluch
 * @since 5.0
 */
public class RedisClusterPubSubReactiveCommandsImpl<K,V> extends RedisPubSubReactiveCommandsImpl<K,V> implements RedisClusterPubSubReactiveCommands<K,V> {
  /** 
 * Initialize a new connection.
 * @param connection the connection.
 * @param codec Codec used to encode/decode keys and values.
 */
  public RedisClusterPubSubReactiveCommandsImpl(  StatefulRedisPubSubConnection<K,V> connection,  RedisCodec<K,V> codec){
    super(connection,codec);
  }
  @Override public Flux<V> georadius(  K key,  double longitude,  double latitude,  double distance,  GeoArgs.Unit unit){
    return super.georadius_ro(key,longitude,latitude,distance,unit);
  }
  @Override public Flux<GeoWithin<V>> georadius(  K key,  double longitude,  double latitude,  double distance,  GeoArgs.Unit unit,  GeoArgs geoArgs){
    return super.georadius_ro(key,longitude,latitude,distance,unit,geoArgs);
  }
  @Override public Flux<V> georadiusbymember(  K key,  V member,  double distance,  GeoArgs.Unit unit){
    return super.georadiusbymember_ro(key,member,distance,unit);
  }
  @Override public Flux<GeoWithin<V>> georadiusbymember(  K key,  V member,  double distance,  GeoArgs.Unit unit,  GeoArgs geoArgs){
    return super.georadiusbymember_ro(key,member,distance,unit,geoArgs);
  }
  @Override public StatefulRedisClusterPubSubConnectionImpl<K,V> getStatefulConnection(){
    return (StatefulRedisClusterPubSubConnectionImpl<K,V>)super.getStatefulConnection();
  }
  @SuppressWarnings("unchecked") @Override public PubSubReactiveNodeSelection<K,V> nodes(  Predicate<RedisClusterNode> predicate){
    PubSubReactiveNodeSelection<K,V> selection=new StaticPubSubReactiveNodeSelection<K,V>(getStatefulConnection(),predicate);
    NodeSelectionInvocationHandler h=new NodeSelectionInvocationHandler((AbstractNodeSelection<?,?,?,?>)selection,RedisPubSubReactiveCommands.class,REACTIVE);
    return (PubSubReactiveNodeSelection<K,V>)Proxy.newProxyInstance(NodeSelectionSupport.class.getClassLoader(),new Class<?>[]{NodeSelectionPubSubReactiveCommands.class,PubSubReactiveNodeSelection.class},h);
  }
private static class StaticPubSubReactiveNodeSelection<K,V> extends AbstractNodeSelection<RedisPubSubReactiveCommands<K,V>,NodeSelectionPubSubReactiveCommands<K,V>,K,V> implements PubSubReactiveNodeSelection<K,V> {
    private final List<RedisClusterNode> redisClusterNodes;
    private final ClusterDistributionChannelWriter writer;
    @SuppressWarnings("unchecked") public StaticPubSubReactiveNodeSelection(    StatefulRedisClusterPubSubConnection<K,V> globalConnection,    Predicate<RedisClusterNode> selector){
      this.redisClusterNodes=globalConnection.getPartitions().stream().filter(selector).collect(Collectors.toList());
      writer=((StatefulRedisClusterPubSubConnectionImpl)globalConnection).getClusterDistributionChannelWriter();
    }
    @Override protected CompletableFuture<RedisPubSubReactiveCommands<K,V>> getApi(    RedisClusterNode redisClusterNode){
      return getConnection(redisClusterNode).thenApply(StatefulRedisPubSubConnection::reactive);
    }
    protected List<RedisClusterNode> nodes(){
      return redisClusterNodes;
    }
    @SuppressWarnings("unchecked") protected CompletableFuture<StatefulRedisPubSubConnection<K,V>> getConnection(    RedisClusterNode redisClusterNode){
      RedisURI uri=redisClusterNode.getUri();
      AsyncClusterConnectionProvider async=(AsyncClusterConnectionProvider)writer.getClusterConnectionProvider();
      return async.getConnectionAsync(ConnectionIntent.WRITE,uri.getHost(),uri.getPort()).thenApply(it -> (StatefulRedisPubSubConnection<K,V>)it);
    }
  }
}
