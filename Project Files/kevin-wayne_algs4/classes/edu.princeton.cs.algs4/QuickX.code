/** 
 * The  {@code QuickX} class provides static methods for sorting an arrayusing an optimized version of quicksort (using Hoare's 2-way partitioning algorithm, median-of-3 to choose the partitioning element, and cutoff to insertion sort). <p> For additional documentation, see <a href="https://algs4.cs.princeton.edu/23quicksort">Section 2.3</a> of <i>Algorithms, 4th Edition</i> by Robert Sedgewick and Kevin Wayne.
 * @author Robert Sedgewick
 * @author Kevin Wayne
 */
public class QuickX {
  private static final int INSERTION_SORT_CUTOFF=8;
  private QuickX(){
  }
  /** 
 * Rearranges the array in ascending order, using the natural order.
 * @param a the array to be sorted
 */
  public static void sort(  Comparable[] a){
    sort(a,0,a.length - 1);
    assert isSorted(a);
  }
  private static void sort(  Comparable[] a,  int lo,  int hi){
    if (hi <= lo)     return;
    int n=hi - lo + 1;
    if (n <= INSERTION_SORT_CUTOFF) {
      Insertion.sort(a,lo,hi + 1);
      return;
    }
    int j=partition(a,lo,hi);
    sort(a,lo,j - 1);
    sort(a,j + 1,hi);
  }
  private static int partition(  Comparable[] a,  int lo,  int hi){
    int n=hi - lo + 1;
    int m=median3(a,lo,lo + n / 2,hi);
    exch(a,m,lo);
    int i=lo;
    int j=hi + 1;
    Comparable v=a[lo];
    while (less(a[++i],v)) {
      if (i == hi) {
        exch(a,lo,hi);
        return hi;
      }
    }
    while (less(v,a[--j])) {
      if (j == lo + 1)       return lo;
    }
    while (i < j) {
      exch(a,i,j);
      while (less(a[++i],v))       ;
      while (less(v,a[--j]))       ;
    }
    exch(a,lo,j);
    return j;
  }
  private static int median3(  Comparable[] a,  int i,  int j,  int k){
    return (less(a[i],a[j]) ? (less(a[j],a[k]) ? j : less(a[i],a[k]) ? k : i) : (less(a[k],a[j]) ? j : less(a[k],a[i]) ? k : i));
  }
  /** 
 * Helper sorting functions.
 */
  private static boolean less(  Comparable v,  Comparable w){
    return v.compareTo(w) < 0;
  }
  private static void exch(  Object[] a,  int i,  int j){
    Object swap=a[i];
    a[i]=a[j];
    a[j]=swap;
  }
  /** 
 * Check if array is sorted - useful for debugging.
 */
  private static boolean isSorted(  Comparable[] a){
    for (int i=1; i < a.length; i++)     if (less(a[i],a[i - 1]))     return false;
    return true;
  }
  private static void show(  Comparable[] a){
    for (int i=0; i < a.length; i++) {
      StdOut.println(a[i]);
    }
  }
  /** 
 * Reads in a sequence of strings from standard input; quicksorts them (using an optimized version of 2-way quicksort); and prints them to standard output in ascending order.
 * @param args the command-line arguments
 */
  public static void main(  String[] args){
    String[] a=StdIn.readAllStrings();
    QuickX.sort(a);
    assert isSorted(a);
    show(a);
  }
}
