public class UserTuneIntegrationTest extends AbstractSmackIntegrationTest {
  private final UserTuneManager utm1;
  private final UserTuneManager utm2;
  public UserTuneIntegrationTest(  SmackIntegrationTestEnvironment environment) throws NotLoggedInException {
    super(environment);
    utm1=UserTuneManager.getInstanceFor(conOne);
    utm2=UserTuneManager.getInstanceFor(conTwo);
  }
  @AfterClass public void unsubscribe() throws SmackException.NotLoggedInException, XMPPException.XMPPErrorException, SmackException.NotConnectedException, InterruptedException, SmackException.NoResponseException {
    IntegrationTestRosterUtil.ensureBothAccountsAreNotInEachOthersRoster(conOne,conTwo);
  }
  /** 
 * Verifies that a notification is sent when a publication is received, assuming that notification filtering has been adjusted to allow for the notification to be delivered.
 * @throws Exception if the test fails
 */
  @SmackIntegrationTest public void testNotification() throws Exception {
    URI uri=new URI("http://www.yesworld.com/lyrics/Fragile.html#9");
    UserTuneElement.Builder builder=UserTuneElement.getBuilder();
    UserTuneElement data=builder.setArtist("Yes").setLength(686).setRating(8).setSource("Yessongs").setTitle("Heart of the Sunrise").setTrack("3").setUri(uri).build();
    IntegrationTestRosterUtil.ensureBothAccountsAreSubscribedToEachOther(conOne,conTwo,timeout);
    final SimpleResultSyncPoint userTuneReceived=new SimpleResultSyncPoint();
    final PepEventListener<UserTuneElement> userTuneListener=(jid,userTune,id,message) -> {
      if (userTune.equals(data)) {
        userTuneReceived.signal();
      }
    }
;
    try {
      registerListenerAndWait(utm2,ServiceDiscoveryManager.getInstanceFor(conTwo),userTuneListener);
      utm1.publishUserTune(data);
      Object result=userTuneReceived.waitForResult(timeout);
      Assertions.assertNotNull(result,"Expected to receive a PEP notification, but did not.");
    }
  finally {
      unregisterListener(utm2,userTuneListener);
    }
  }
  /** 
 * Verifies that a notification for a previously sent publication is received as soon as notification filtering has been adjusted to allow for the notification to be delivered.
 * @throws Exception if the test fails
 */
  @SmackIntegrationTest public void testNotificationAfterFilterChange() throws Exception {
    URI uri=new URI("http://www.yesworld.com/lyrics/Fragile.html#8");
    UserTuneElement.Builder builder=UserTuneElement.getBuilder();
    UserTuneElement data=builder.setArtist("No").setLength(306).setRating(3).setSource("NoSongs").setTitle("Sunrise of the Heart").setTrack("2").setUri(uri).build();
    IntegrationTestRosterUtil.ensureBothAccountsAreSubscribedToEachOther(conOne,conTwo,timeout);
    final SimpleResultSyncPoint userTuneReceived=new SimpleResultSyncPoint();
    final PepEventListener<UserTuneElement> userTuneListener=(jid,userTune,id,message) -> {
      if (userTune.equals(data)) {
        userTuneReceived.signal();
      }
    }
;
    try {
      publishAndWait(utm1,ServiceDiscoveryManager.getInstanceFor(conOne),data);
      registerListenerAndWait(utm2,ServiceDiscoveryManager.getInstanceFor(conTwo),userTuneListener);
      try {
        Object result=userTuneReceived.waitForResult(timeout);
        Assertions.assertNotNull(result,"Expected to receive a PEP notification, but did not.");
      }
 catch (      TimeoutException e) {
        Assertions.fail("Expected to receive a PEP notification, but did not.");
      }
    }
  finally {
      unregisterListener(utm2,userTuneListener);
    }
  }
  /** 
 * Registers a listener for User Tune data. This implicitly publishes a CAPS update to include a notification filter for the usertune node. This method blocks until the server has indicated that this update has been received.
 * @param userTuneManager The UserTuneManager instance for the connection that is expected to receive data.
 * @param discoManager The ServiceDiscoveryManager instance for the connection that is expected to publish data.
 * @param listener A listener instance for UserTune data that is to be registered.
 * @throws Exception if the test fails
 */
  public void registerListenerAndWait(  UserTuneManager userTuneManager,  ServiceDiscoveryManager discoManager,  PepEventListener<UserTuneElement> listener) throws Exception {
    final SimpleResultSyncPoint notificationFilterReceived=new SimpleResultSyncPoint();
    final EntityCapabilitiesChangedListener notificationFilterReceivedListener=info -> {
      if (info.containsFeature(UserTuneManager.USERTUNE_NODE + "+notify")) {
        notificationFilterReceived.signal();
      }
    }
;
    discoManager.addEntityCapabilitiesChangedListener(notificationFilterReceivedListener);
    try {
      userTuneManager.addUserTuneListener(listener);
      notificationFilterReceived.waitForResult(timeout);
    }
  finally {
      discoManager.removeEntityCapabilitiesChangedListener(notificationFilterReceivedListener);
    }
  }
  /** 
 * The functionally reverse of  {@link #registerListenerAndWait(UserTuneManager,ServiceDiscoveryManager,PepEventListener)}with the difference of not being a blocking operation.
 * @param userTuneManager The UserTuneManager instance for the connection that was expected to receive data.
 * @param listener A listener instance for UserTune data that is to be removed.
 */
  public void unregisterListener(  UserTuneManager userTuneManager,  PepEventListener<UserTuneElement> listener){
    userTuneManager.removeUserTuneListener(listener);
  }
  /** 
 * Publish data using PEP, and block until the server has echoed the publication back to the publishing user.
 * @param userTuneManager The UserTuneManager instance for the connection that is expected to publish data.
 * @param discoManager The ServiceDiscoveryManager instance for the connection that is expected to publish data.
 * @param data The data to be published.
 * @throws Exception if the test fails
 */
  public void publishAndWait(  UserTuneManager userTuneManager,  ServiceDiscoveryManager discoManager,  UserTuneElement data) throws Exception {
    final SimpleResultSyncPoint publicationEchoReceived=new SimpleResultSyncPoint();
    final PepEventListener<UserTuneElement> publicationEchoListener=(jid,userTune,id,message) -> {
      if (userTune.equals(data)) {
        publicationEchoReceived.signal();
      }
    }
;
    try {
      registerListenerAndWait(userTuneManager,discoManager,publicationEchoListener);
      userTuneManager.addUserTuneListener(publicationEchoListener);
      userTuneManager.publishUserTune(data);
    }
  finally {
      userTuneManager.removeUserTuneListener(publicationEchoListener);
    }
  }
}
