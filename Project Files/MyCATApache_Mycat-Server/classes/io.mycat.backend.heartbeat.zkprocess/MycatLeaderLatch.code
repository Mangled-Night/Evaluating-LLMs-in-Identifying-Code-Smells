public class MycatLeaderLatch {
  public static final Logger LOGGER=LoggerFactory.getLogger(MycatLeaderLatch.class);
  private final String latchPath;
  volatile LeaderLatch latch;
  String myId;
  CuratorFramework client;
  int isLeaderCount=0;
  int isSlaveCount=0;
  volatile boolean isLeader;
  final ScheduledExecutorService service=Executors.newScheduledThreadPool(1);
  ConcurrentSet<ManageHeartBeatChange> manageHeartBeatChangeSet=new ConcurrentSet<>();
  public MycatLeaderLatch(  String latchPath){
    this.myId=ZkConfig.getInstance().getValue(ZkParamCfg.ZK_CFG_MYID);
    this.latchPath=ZKUtils.getZKBasePath() + latchPath;
    this.client=ZKUtils.getConnection();
    isLeader=false;
    latch=new LeaderLatch(client,this.latchPath,this.myId);
    Map<String,PhysicalDBPool> dataSourceHosts=MycatServer.getInstance().getConfig().getDataHosts();
    try {
      for (      String dataSource : dataSourceHosts.keySet()) {
        manageHeartBeatChangeSet.add(new ManageHeartBeatChange(this,dataSource));
      }
    }
 catch (    Exception e) {
      LOGGER.warn("init ManageHeartBeatChange err:",e);
    }
  }
  private void isLeaderRunnable(){
    LOGGER.debug(ZkConfig.getInstance().getValue(ZkParamCfg.ZK_CFG_MYID) + " success to leader");
    for (    ManageHeartBeatChange manageHeartBeatChange : manageHeartBeatChangeSet) {
      manageHeartBeatChange.leaderlisten();
    }
  }
  private void notLeaderRunnable(){
    LOGGER.debug(ZkConfig.getInstance().getValue(ZkParamCfg.ZK_CFG_MYID) + " fail to leader, now is slave");
    for (    ManageHeartBeatChange manageHeartBeatChange : manageHeartBeatChangeSet) {
      manageHeartBeatChange.stop();
    }
  }
  public void start() throws Exception {
    latch.start();
    service.scheduleAtFixedRate(checkIsLeader(),0,5,TimeUnit.SECONDS);
  }
  public void stop() throws IOException {
    latch.close();
    service.shutdown();
  }
  private Runnable checkIsLeader(){
    return new Runnable(){
      @Override public void run(){
        boolean isExist=false;
        try {
          Collection<Participant> participants=latch.getParticipants();
          for (          Participant participant : participants) {
            if (myId.equals(participant.getId())) {
              isExist=true;
              break;
            }
          }
          if (!isExist) {
            LOGGER.info(myId + " current does not exist on zk");
            latch.close();
            latch=new LeaderLatch(client,latchPath,myId);
            latch.start();
            LOGGER.info(myId + " success reset leaderLatch @ " + latchPath);
          }
          Participant leader=latch.getLeader();
          boolean hashLeaderShip=myId.equals(leader.getId());
          judgeIsLeader(hashLeaderShip);
        }
 catch (        Exception e) {
          judgeIsLeader(false);
          e.printStackTrace();
        }
      }
    }
;
  }
  public void judgeIsLeader(  boolean hashLeaderShip){
    if (hashLeaderShip) {
      isLeaderCount++;
      isSlaveCount=0;
    }
 else {
      isLeaderCount=0;
      isSlaveCount++;
    }
    if (isLeaderCount > 3 && !isLeader) {
      LOGGER.info(myId + " Currently run as leader");
      isLeader=true;
      isLeaderRunnable();
    }
    if (isSlaveCount > 3 && isLeader) {
      LOGGER.info(myId + " Currently run as slave");
      isLeader=false;
      notLeaderRunnable();
    }
  }
  public boolean isLeaderShip(){
    return isSlaveCount == 0 && isLeader;
  }
  public Collection<Participant> getParticipants() throws Exception {
    return latch.getParticipants();
  }
  public int getParticipantsCount(){
    try {
      return latch.getParticipants().size();
    }
 catch (    Exception e) {
      e.printStackTrace();
      LOGGER.error("get clusters number error");
      return 0;
    }
  }
}
