/** 
 * Write a printable representation of a byte array.
 * @param b byte array
 * @return string
 * @see #toStringBinary(byte[],int,int)
 */
public static String toStringBinary(final byte[] b){
  if (b == null)   return "null";
  return toStringBinary(b,0,b.length);
}
/** 
 * Converts the given byte buffer to a printable representation, from the index 0 (inclusive) to the limit (exclusive), regardless of the current position. The position and the other index parameters are not changed.
 * @param buf a byte buffer
 * @return a string representation of the buffer's binary contents
 * @see #toBytes(ByteBuffer)
 */
public static String toStringBinary(ByteBuffer buf){
  if (buf == null)   return "null";
  if (buf.hasArray()) {
    return toStringBinary(buf.array(),buf.arrayOffset(),buf.limit());
  }
  return toStringBinary(toBytes(buf));
}
/** 
 * Write a printable representation of a byte array. Non-printable characters are hex escaped in the format \\x%02X, eg: \x00 \x05 etc
 * @param b array to write out
 * @param off offset to start at
 * @param len length to write
 * @return string output
 */
public static String toStringBinary(final byte[] b,int off,int len){
  StringBuilder result=new StringBuilder();
  if (off >= b.length)   return result.toString();
  if (off + len > b.length)   len=b.length - off;
  for (int i=off; i < off + len; ++i) {
    int ch=b[i] & 0xFF;
    if (ch >= ' ' && ch <= '~' && ch != '\\') {
      result.append((char)ch);
    }
 else {
      result.append("\\x");
      result.append(HEX_CHARS_UPPER[ch / 0x10]);
      result.append(HEX_CHARS_UPPER[ch % 0x10]);
    }
  }
  return result.toString();
}
