public class WorldGeneratorManager {
  private static final Logger logger=LoggerFactory.getLogger(WorldGeneratorManager.class);
  private final Context context;
  private ImmutableList<WorldGeneratorInfo> generatorInfo;
  public WorldGeneratorManager(  Context context){
    this.context=context;
    refresh();
  }
  public void refresh(){
    ModuleManager moduleManager=verifyNotNull(context.get(ModuleManager.class),"no ModuleManager");
    List<WorldGeneratorInfo> infos=Lists.newArrayList();
    for (    Name moduleId : moduleManager.getRegistry().getModuleIds()) {
      Module module=moduleManager.getRegistry().getLatestModuleVersion(moduleId);
      DependencyResolver resolver=new DependencyResolver(moduleManager.getRegistry());
      ResolutionResult resolutionResult=resolver.resolve(module.getId());
      if (resolutionResult.isSuccess()) {
        try (ModuleEnvironment tempEnvironment=moduleManager.loadEnvironment(resolutionResult.getModules(),false)){
          for (          Class<?> generatorClass : tempEnvironment.getTypesAnnotatedWith(RegisterWorldGenerator.class)) {
            Name providedBy=tempEnvironment.getModuleProviding(generatorClass);
            if (providedBy == null) {
              String s="{} found while inspecting {} but is not provided by any module.";
              if (!ModuleManager.isLoadingClasspathModules()) {
                logger.warn(s,generatorClass,moduleId);
              }
 else {
                logger.debug(s,generatorClass,moduleId);
              }
            }
 else             if (providedBy.equals(module.getId())) {
              RegisterWorldGenerator annotation=generatorClass.getAnnotation(RegisterWorldGenerator.class);
              if (isValidWorldGenerator(generatorClass)) {
                SimpleUri uri=new SimpleUri(moduleId,annotation.id());
                infos.add(new WorldGeneratorInfo(uri,annotation.displayName(),annotation.description()));
                logger.debug("{} added from {}",uri,generatorClass);
              }
 else {
                logger.error("{} marked to be registered as a World Generator, " + "but is not a subclass of WorldGenerator or lacks the correct constructor",generatorClass);
              }
            }
          }
        }
 catch (        Exception e) {
          logger.error("Error loading world generator in module {}, skipping",module.getId(),e);
        }
      }
 else {
        logger.warn("Could not resolve dependencies for module: {}",module);
      }
    }
    Collections.sort(infos);
    generatorInfo=ImmutableList.copyOf(infos);
  }
  public List<WorldGeneratorInfo> getWorldGenerators(){
    return generatorInfo;
  }
  public WorldGeneratorInfo getWorldGeneratorInfo(  SimpleUri uri){
    for (    WorldGeneratorInfo info : generatorInfo) {
      if (info.getUri().equals(uri)) {
        return info;
      }
    }
    return null;
  }
  /** 
 * @param uri uri of the world generator to create.
 * @param context objects from this context will be injected into the
 * @return The instantiated world generator.
 */
  public static WorldGenerator createGenerator(  SimpleUri uri,  Context context) throws UnresolvedWorldGeneratorException {
    ModuleManager moduleManager=context.get(ModuleManager.class);
    Module module=moduleManager.getEnvironment().get(uri.getModuleName());
    if (module == null) {
      DependencyResolver resolver=new DependencyResolver(moduleManager.getRegistry());
      ResolutionResult result=resolver.resolve(uri.getModuleName());
      if (!result.isSuccess()) {
        if (moduleManager.getRegistry().getLatestModuleVersion(uri.getModuleName()) == null) {
          throw new UnresolvedWorldGeneratorException("Unable to resolve world generator '" + uri + "' - not found");
        }
 else {
          throw new UnresolvedWorldGeneratorException("Unable to resolve world generator '" + uri + "' - unable to resolve module dependencies");
        }
      }
      try (ModuleEnvironment environment=moduleManager.loadEnvironment(result.getModules(),false)){
        return createWorldGenerator(uri,context,environment);
      }
     }
 else {
      return createWorldGenerator(uri,context,moduleManager.getEnvironment());
    }
  }
  /** 
 * @param uri uri of the world generator to create.
 * @param context that will be used to inject teh world generator.
 * @param environment to be searched for the world generator class.
 * @return a new world generator with the specified uri.
 */
  public static WorldGenerator createWorldGenerator(  SimpleUri uri,  Context context,  ModuleEnvironment environment) throws UnresolvedWorldGeneratorException {
    for (    Class<?> generatorClass : environment.getTypesAnnotatedWith(RegisterWorldGenerator.class)) {
      RegisterWorldGenerator annotation=generatorClass.getAnnotation(RegisterWorldGenerator.class);
      Name moduleName=environment.getModuleProviding(generatorClass);
      if (moduleName == null) {
        throw new UnresolvedWorldGeneratorException("Cannot find module for world generator " + generatorClass);
      }
      SimpleUri generatorUri=new SimpleUri(moduleName,annotation.id());
      if (generatorUri.equals(uri)) {
        WorldGenerator worldGenerator=loadGenerator(generatorClass,generatorUri);
        InjectionHelper.inject(worldGenerator,context);
        return worldGenerator;
      }
    }
    throw new UnresolvedWorldGeneratorException("Unable to resolve world generator '" + uri + "' - not found");
  }
  private static WorldGenerator loadGenerator(  Class<?> generatorClass,  SimpleUri uri) throws UnresolvedWorldGeneratorException {
    if (isValidWorldGenerator(generatorClass)) {
      try {
        return (WorldGenerator)generatorClass.getConstructor(SimpleUri.class).newInstance(uri);
      }
 catch (      InstantiationException|IllegalAccessException|InvocationTargetException|NoSuchMethodException e) {
        throw new UnresolvedWorldGeneratorException("Failed to instantiate world generator '" + uri + "'",e);
      }
    }
 else {
      throw new UnresolvedWorldGeneratorException(uri + " is not a valid world generator");
    }
  }
  private static boolean isValidWorldGenerator(  Class<?> generatorClass){
    try {
      if (WorldGenerator.class.isAssignableFrom(generatorClass)) {
        if (generatorClass.getConstructor(SimpleUri.class) != null) {
          return true;
        }
      }
      return false;
    }
 catch (    NoSuchMethodException|RuntimeException e) {
      return false;
    }
  }
}
