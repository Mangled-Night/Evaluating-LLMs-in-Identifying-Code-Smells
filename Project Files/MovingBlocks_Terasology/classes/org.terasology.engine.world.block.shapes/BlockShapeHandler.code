private static class BlockShapeHandler implements JsonDeserializer<BlockShapeData> {
  public static final String DISPLAY_NAME="displayName";
  public static final String PITCH_SYMMETRIC="pitchSymmetric";
  public static final String YAW_SYMMETRIC="yawSymmetric";
  public static final String ROLL_SYMMETRIC="rollSymmetric";
  public static final String SYMMETRIC="symmetric";
  public static final String CONVEX_HULL="convexHull";
  public static final String COLLIDERS="colliders";
  public static final String COLLISION="collision";
  public static final String FULL_SIDE="fullSide";
  public static final String TYPE="type";
  public static final String AABB="AABB";
  public static final String SPHERE="Sphere";
  public static final String POSITION="position";
  public static final String EXTENTS="extents";
  public static final String RADIUS="radius";
  @Override public BlockShapeData deserialize(  JsonElement json,  Type typeOfT,  JsonDeserializationContext context) throws JsonParseException {
    BlockShapeData shape=new BlockShapeData();
    JsonObject shapeObj=json.getAsJsonObject();
    if (shapeObj.has(DISPLAY_NAME)) {
      shape.setDisplayName(shapeObj.getAsJsonPrimitive(DISPLAY_NAME).getAsString());
    }
    for (    BlockPart part : BlockPart.values()) {
      if (shapeObj.has(part.toString().toLowerCase(Locale.ENGLISH))) {
        JsonObject meshObj=shapeObj.getAsJsonObject(part.toString().toLowerCase(Locale.ENGLISH));
        shape.setMeshPart(part,(BlockMeshPart)context.deserialize(meshObj,BlockMeshPart.class));
        if (part.isSide() && meshObj.has(FULL_SIDE)) {
          shape.setBlockingSide(part.getSide(),meshObj.get(FULL_SIDE).getAsBoolean());
        }
      }
    }
    if (shapeObj.has(COLLISION) && shapeObj.get(COLLISION).isJsonObject()) {
      JsonObject collisionInfo=shapeObj.get(COLLISION).getAsJsonObject();
      processCollision(context,shape,collisionInfo);
    }
 else {
      shape.setCollisionShape(COLLISION_SHAPE_FACTORY.getNewUnitCube());
      shape.setCollisionSymmetric(true);
    }
    return shape;
  }
  private void processCollision(  JsonDeserializationContext context,  BlockShapeData shape,  JsonObject collisionInfo){
    if (collisionInfo.has(PITCH_SYMMETRIC) && collisionInfo.get(PITCH_SYMMETRIC).isJsonPrimitive() && collisionInfo.get(PITCH_SYMMETRIC).getAsJsonPrimitive().isBoolean()) {
      shape.setPitchSymmetric(collisionInfo.get(PITCH_SYMMETRIC).getAsBoolean());
    }
    if (collisionInfo.has(YAW_SYMMETRIC) && collisionInfo.get(YAW_SYMMETRIC).isJsonPrimitive() && collisionInfo.get(YAW_SYMMETRIC).getAsJsonPrimitive().isBoolean()) {
      shape.setYawSymmetric(collisionInfo.get(YAW_SYMMETRIC).getAsBoolean());
    }
    if (collisionInfo.has(ROLL_SYMMETRIC) && collisionInfo.get(ROLL_SYMMETRIC).isJsonPrimitive() && collisionInfo.get(ROLL_SYMMETRIC).getAsJsonPrimitive().isBoolean()) {
      shape.setRollSymmetric(collisionInfo.get(ROLL_SYMMETRIC).getAsBoolean());
    }
    if (collisionInfo.has(SYMMETRIC) && collisionInfo.get(SYMMETRIC).isJsonPrimitive() && collisionInfo.get(SYMMETRIC).getAsJsonPrimitive().isBoolean()) {
      if (collisionInfo.get(SYMMETRIC).getAsBoolean()) {
        shape.setCollisionSymmetric(true);
      }
    }
    if (collisionInfo.has(CONVEX_HULL) && collisionInfo.get(CONVEX_HULL).isJsonPrimitive() && collisionInfo.get(CONVEX_HULL).getAsJsonPrimitive().isBoolean()) {
      List<Vector3f> verts=buildVertList(shape);
      ConvexHullShape convexHull=COLLISION_SHAPE_FACTORY.getNewConvexHull(new ArrayList<>(verts));
      shape.setCollisionShape(convexHull);
    }
 else     if (collisionInfo.has(COLLIDERS) && collisionInfo.get(COLLIDERS).isJsonArray() && collisionInfo.get(COLLIDERS).getAsJsonArray().size() > 0) {
      JsonArray colliderArray=collisionInfo.get(COLLIDERS).getAsJsonArray();
      processColliders(context,colliderArray,shape);
    }
 else {
      shape.setCollisionShape(COLLISION_SHAPE_FACTORY.getNewUnitCube());
      shape.setCollisionSymmetric(true);
    }
  }
  private List<Vector3f> buildVertList(  BlockShapeData shape){
    List<Vector3f> result=new ArrayList<>();
    for (    BlockPart part : BlockPart.values()) {
      BlockMeshPart meshPart=shape.getMeshPart(part);
      if (meshPart != null) {
        for (int i=0; i < meshPart.size(); ++i) {
          result.add(meshPart.getVertex(i));
        }
      }
    }
    return result;
  }
  private void processColliders(  JsonDeserializationContext context,  JsonArray colliderArray,  BlockShapeData shape){
    List<ColliderInfo> colliders=Lists.newArrayList();
    for (    JsonElement elem : colliderArray) {
      if (elem.isJsonObject()) {
        JsonObject colliderObj=elem.getAsJsonObject();
        if (colliderObj.has(TYPE) && colliderObj.get(TYPE).isJsonPrimitive() && colliderObj.getAsJsonPrimitive(TYPE).isString()) {
          String type=colliderObj.get(TYPE).getAsString();
          if (AABB.equals(type)) {
            colliders.add(processAABBShape(context,colliderObj));
          }
 else           if (SPHERE.equals(type)) {
            colliders.add(processSphereShape(context,colliderObj));
          }
        }
      }
    }
    if (colliders.size() > 1) {
      ColliderInfo info=processCompoundShape(colliders);
      shape.setCollisionShape(info.collisionShape);
      shape.setCollisionOffset(info.offset);
    }
 else     if (colliders.size() == 1) {
      shape.setCollisionShape(colliders.get(0).collisionShape);
      shape.setCollisionOffset(colliders.get(0).offset);
    }
 else {
      shape.setCollisionShape(COLLISION_SHAPE_FACTORY.getNewUnitCube());
      shape.setCollisionOffset(new Vector3f(0,0,0));
      shape.setCollisionSymmetric(true);
    }
  }
  private ColliderInfo processCompoundShape(  List<ColliderInfo> colliders){
    CompoundShape collisionShape=COLLISION_SHAPE_FACTORY.getNewCompoundShape();
    for (    ColliderInfo collider : colliders) {
      collisionShape.addChildShape(collider.offset,Rotation.none().orientation(),1.0f,collider.collisionShape);
    }
    return new ColliderInfo(new Vector3f(),collisionShape);
  }
  private ColliderInfo processAABBShape(  JsonDeserializationContext context,  JsonObject colliderDef){
    Vector3f offset=context.deserialize(colliderDef.get(POSITION),Vector3f.class);
    Vector3f extent=context.deserialize(colliderDef.get(EXTENTS),Vector3f.class);
    if (offset == null) {
      throw new JsonParseException("AABB Collider missing position");
    }
    if (extent == null) {
      throw new JsonParseException("AABB Collider missing extents");
    }
    extent.absolute();
    return new ColliderInfo(offset,COLLISION_SHAPE_FACTORY.getNewBox(extent));
  }
  private ColliderInfo processSphereShape(  JsonDeserializationContext context,  JsonObject colliderDef){
    Vector3f offset=context.deserialize(colliderDef.get(POSITION),Vector3f.class);
    float radius=colliderDef.get(RADIUS).getAsFloat();
    if (offset == null) {
      throw new JsonParseException("Sphere Collider missing position");
    }
    return new ColliderInfo(offset,COLLISION_SHAPE_FACTORY.getNewSphere(radius));
  }
private static class ColliderInfo {
    public Vector3f offset;
    public CollisionShape collisionShape;
    ColliderInfo(    Vector3f offset,    CollisionShape shape){
      this.offset=offset;
      this.collisionShape=shape;
    }
  }
}
