/** 
 * Implement the Jingle Session state using the State Behavioral pattern. (From the book Design Patterns, AKA GoF.) These classes also employ the Flyweight and Singleton patterns as recommended for the State pattern by GoF. There seems to be three ways to go with the State pattern in Java: interface, abstract class and enums. Most of the accepted models use abstract classes.  It wasn't clear to me that any of the three models was superior, so I went with the most common example.
 * @author Jeff Williams
 */
public abstract class JingleSessionState {
  /** 
 * Called when entering the state.
 * @return the jingle session state.
 */
  public static JingleSessionState getInstance(){
    return null;
  }
  /** 
 * Called when entering the state.
 */
  public abstract void enter();
  /** 
 * Called when exiting the state.
 */
  public abstract void exit();
  /** 
 * Process an incoming Jingle Packet. When you look at the GoF State pattern this method roughly corresponds to example on p310: ProcessOctect()
 * @param session the jingle session.
 * @param jingle the jingle stanza.
 * @param action the jingle action.
 * @return the resulting IQ.
 * @throws SmackException if Smack detected an exceptional situation.
 * @throws InterruptedException if the calling thread was interrupted.
 */
  public abstract IQ processJingle(  JingleSession session,  Jingle jingle,  JingleActionEnum action) throws SmackException, InterruptedException ;
  /** 
 * For debugging just emit the short name of the class.
 */
  @Override public String toString(){
    return this.getClass().getSimpleName();
  }
}
