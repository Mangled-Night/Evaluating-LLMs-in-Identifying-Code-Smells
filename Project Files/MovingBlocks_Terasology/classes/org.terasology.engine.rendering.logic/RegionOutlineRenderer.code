/** 
 * Renderes region outlines for all entities with   {@link RegionOutlineComponent}s.
 */
@RegisterSystem(RegisterMode.CLIENT) public class RegionOutlineRenderer extends BaseComponentSystem implements RenderSystem {
  @In private AssetManager assetManager;
  @In private WorldRenderer worldRenderer;
  @In private EntityManager entityManager;
  private StandardMeshData meshData=new StandardMeshData(DrawingMode.LINES,AllocationType.STREAM);
  private Mesh mesh;
  private Material material;
  private Map<EntityRef,RegionOutlineComponent> entityToRegionOutlineMap=Maps.newLinkedHashMap();
  @Override public void initialise(){
    Preconditions.checkArgument(!Strings.isNullOrEmpty("engine:white"));
    this.material=assetManager.getAsset("engine:white",Material.class).get();
    mesh=Assets.generateAsset(meshData,Mesh.class);
  }
  @ReceiveEvent public void onRegionOutlineComponentActivation(  OnActivatedComponent event,  EntityRef entity,  RegionOutlineComponent component){
    entityToRegionOutlineMap.put(entity,component);
  }
  @ReceiveEvent public void onRegionOutlineComponentDeactivation(  BeforeDeactivateComponent event,  EntityRef entity,  RegionOutlineComponent component){
    entityToRegionOutlineMap.remove(entity);
  }
  @Override public void renderOverlay(){
    if (entityToRegionOutlineMap.isEmpty()) {
      return;
    }
    GL33.glDepthFunc(GL33.GL_ALWAYS);
    Vector3f cameraPosition=worldRenderer.getActiveCamera().getPosition();
    Vector3f worldPos=new Vector3f();
    Vector3f worldPositionCameraSpace=new Vector3f();
    worldPos.sub(cameraPosition,worldPositionCameraSpace);
    Matrix4f matrixCameraSpace=new Matrix4f().translationRotateScale(worldPositionCameraSpace,new Quaternionf(),1.0f);
    Matrix4f modelViewMatrix=new Matrix4f(worldRenderer.getActiveCamera().getViewMatrix()).mul(matrixCameraSpace);
    material.setMatrix4("projectionMatrix",worldRenderer.getActiveCamera().getProjectionMatrix());
    material.setMatrix4("modelViewMatrix",modelViewMatrix,true);
    meshData.reallocate(0,0);
    meshData.indices.rewind();
    meshData.position.rewind();
    meshData.color0.rewind();
    int index=0;
    Vector3f pos=new Vector3f();
    for (    RegionOutlineComponent regionOutline : entityToRegionOutlineMap.values()) {
      if (regionOutline.corner1 == null || regionOutline.corner2 == null) {
        continue;
      }
      BlockRegion region=new BlockRegion(regionOutline.corner1).union(regionOutline.corner2);
      AABBf bounds=region.getBounds(new AABBf());
      meshData.position.put(pos.set(bounds.minX,bounds.minY,bounds.minZ));
      meshData.position.put(pos.set(bounds.maxX,bounds.minY,bounds.minZ));
      meshData.position.put(pos.set(bounds.maxX,bounds.minY,bounds.maxZ));
      meshData.position.put(pos.set(bounds.minX,bounds.minY,bounds.maxZ));
      meshData.position.put(pos.set(bounds.minX,bounds.maxY,bounds.minZ));
      meshData.position.put(pos.set(bounds.maxX,bounds.maxY,bounds.minZ));
      meshData.position.put(pos.set(bounds.maxX,bounds.maxY,bounds.maxZ));
      meshData.position.put(pos.set(bounds.minX,bounds.maxY,bounds.maxZ));
      meshData.color0.put(regionOutline.color);
      meshData.color0.put(regionOutline.color);
      meshData.color0.put(regionOutline.color);
      meshData.color0.put(regionOutline.color);
      meshData.color0.put(regionOutline.color);
      meshData.color0.put(regionOutline.color);
      meshData.color0.put(regionOutline.color);
      meshData.color0.put(regionOutline.color);
      meshData.indices.putAll(new int[]{index,index + 1,index + 1,index + 2,index + 2,index + 3,index + 3,index,index,index + 4,index + 1,index + 5,index + 2,index + 6,index + 3,index + 7,index + 4,index + 5,index + 5,index + 6,index + 6,index + 7,index + 7,index + 4});
      index+=8;
    }
    material.enable();
    mesh.reload(meshData);
    mesh.render();
    GL33.glDepthFunc(GL33.GL_LEQUAL);
  }
}
