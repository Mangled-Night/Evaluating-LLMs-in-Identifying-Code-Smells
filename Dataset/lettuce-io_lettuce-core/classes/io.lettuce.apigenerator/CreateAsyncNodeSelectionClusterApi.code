/** 
 * Create async API based on the templates.
 * @author Mark Paluch
 * @author Mikhael Sokolov
 */
class CreateAsyncNodeSelectionClusterApi {
  private static final Set<String> FILTER_TEMPLATES=LettuceSets.unmodifiableSet("RedisSentinelCommands","RedisTransactionalCommands");
  private static final Set<String> FILTER_METHODS=LettuceSets.unmodifiableSet("shutdown","debugOom","debugSegfault","digest","close","isOpen","BaseRedisCommands.reset","readOnly","readWrite","setAutoFlushCommands","flushCommands");
  /** 
 * Mutate type comment.
 * @return
 */
  Function<String,String> commentMutator(){
    return s -> s.replaceAll("\\$\\{intent\\}","Asynchronous executed commands on a node selection") + "* @generated by " + getClass().getName()+ "\r\n ";
  }
  /** 
 * Method filter
 * @return
 */
  Predicate<MethodDeclaration> methodFilter(){
    return method -> !CompilationUnitFactory.contains(FILTER_METHODS,method);
  }
  /** 
 * Mutate type to async result.
 * @return
 */
  Function<MethodDeclaration,Type> methodTypeMutator(){
    return method -> CompilationUnitFactory.createParametrizedType("AsyncExecutions",method.getType().toString());
  }
  /** 
 * Supply additional imports.
 * @return
 */
  Supplier<List<String>> importSupplier(){
    return () -> Collections.singletonList("io.lettuce.core.RedisFuture");
  }
  @ParameterizedTest @MethodSource("arguments") void createInterface(  String argument) throws Exception {
    createFactory(argument).createInterface();
  }
  static List<String> arguments(){
    return Stream.of(Constants.TEMPLATE_NAMES).filter(t -> !FILTER_TEMPLATES.contains(t)).collect(Collectors.toList());
  }
  private CompilationUnitFactory createFactory(  String templateName){
    String targetName=templateName.replace("Commands","AsyncCommands").replace("Redis","NodeSelection");
    File templateFile=new File(Constants.TEMPLATES,"io/lettuce/core/api/" + templateName + ".java");
    String targetPackage="io.lettuce.core.cluster.api.async";
    CompilationUnitFactory factory=new CompilationUnitFactory(templateFile,Constants.SOURCES,targetPackage,targetName,commentMutator(),methodTypeMutator(),methodFilter(),importSupplier(),null,Function.identity());
    factory.keepMethodSignaturesFor(FILTER_METHODS);
    return factory;
  }
}
