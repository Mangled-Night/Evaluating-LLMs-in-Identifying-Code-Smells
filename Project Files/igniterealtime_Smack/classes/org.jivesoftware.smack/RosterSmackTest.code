/** 
 * Tests the Roster functionality by creating and removing roster entries.
 * @author Gaston Dombiak
 */
public class RosterSmackTest extends SmackTestCase {
  /** 
 * Constructor for RosterSmackTest.
 * @param name TODO javadoc me please
 */
  public RosterSmackTest(  String name){
    super(name);
  }
  /** 
 * 1. Create entries in roster groups 2. Iterate on the groups and remove the entry from each group 3. Check that the entries are kept as unfiled entries
 */
  public void testDeleteAllRosterGroupEntries(){
    try {
      Roster roster=getConnection(0).getRoster();
      CountDownLatch latch=new CountDownLatch(2);
      setupCountdown(latch,roster);
      roster.createEntry(getBareJID(1),"gato11",new String[]{"Friends","Family"});
      roster.createEntry(getBareJID(2),"gato12",new String[]{"Family"});
      waitForCountdown(latch,roster,2);
      final CountDownLatch removeLatch=new CountDownLatch(3);
      RosterListener latchCounter=new RosterListener(){
        @Override public void presenceChanged(        Presence presence){
        }
        @Override public void entriesUpdated(        Collection<String> addresses){
          removeLatch.countDown();
        }
        @Override public void entriesDeleted(        Collection<String> addresses){
        }
        @Override public void entriesAdded(        Collection<String> addresses){
        }
      }
;
      roster.addRosterListener(latchCounter);
      for (      RosterEntry entry : roster.getEntries()) {
        for (        RosterGroup rosterGroup : entry.getGroups()) {
          rosterGroup.removeEntry(entry);
        }
      }
      removeLatch.await(5,TimeUnit.SECONDS);
      roster.removeRosterListener(latchCounter);
      assertEquals("The number of entries in connection 1 should be 1",1,getConnection(1).getRoster().getEntryCount());
      assertEquals("The number of groups in connection 1 should be 0",0,getConnection(1).getRoster().getGroupCount());
      assertEquals("The number of entries in connection 2 should be 1",1,getConnection(2).getRoster().getEntryCount());
      assertEquals("The number of groups in connection 2 should be 0",0,getConnection(2).getRoster().getGroupCount());
      assertEquals("The number of entries in connection 0 should be 2",2,roster.getEntryCount());
      assertEquals("The number of groups in connection 0 should be 0",0,roster.getGroupCount());
    }
 catch (    Exception e) {
      fail(e.getMessage());
    }
  }
  private void setupCountdown(  final CountDownLatch latch,  Roster roster){
    roster.addRosterListener(new RosterListener(){
      @Override public void presenceChanged(      Presence presence){
      }
      @Override public void entriesUpdated(      Collection<String> addresses){
        latch.countDown();
      }
      @Override public void entriesDeleted(      Collection<String> addresses){
      }
      @Override public void entriesAdded(      Collection<String> addresses){
      }
    }
);
  }
  private void waitForCountdown(  CountDownLatch latch,  Roster roster,  int entryCount) throws InterruptedException {
    latch.await(5,TimeUnit.SECONDS);
    assertEquals(entryCount,roster.getEntryCount());
  }
  /** 
 * 1. Create entries in roster groups 2. Iterate on all the entries and remove them from the roster 3. Check that the number of entries and groups is zero
 */
  public void testDeleteAllRosterEntries() throws Exception {
    Roster roster=getConnection(0).getRoster();
    CountDownLatch latch=new CountDownLatch(2);
    setupCountdown(latch,roster);
    roster.createEntry(getBareJID(1),"gato11",new String[]{"Friends"});
    roster.createEntry(getBareJID(2),"gato12",new String[]{"Family"});
    waitForCountdown(latch,roster,2);
    CountDownLatch removeLatch=new CountDownLatch(2);
    RosterListener latchCounter=new RemovalListener(removeLatch);
    roster.addRosterListener(latchCounter);
    for (    RosterEntry entry : roster.getEntries()) {
      roster.removeEntry(entry);
    }
    removeLatch.await(5,TimeUnit.SECONDS);
    roster.removeRosterListener(latchCounter);
    assertEquals("Wrong number of entries in connection 0",0,roster.getEntryCount());
    assertEquals("Wrong number of groups in connection 0",0,roster.getGroupCount());
    assertEquals("Wrong number of entries in connection 1",0,getConnection(1).getRoster().getEntryCount());
    assertEquals("Wrong number of groups in connection 1",0,getConnection(1).getRoster().getGroupCount());
  }
  /** 
 * 1. Create unfiled entries 2. Iterate on all the entries and remove them from the roster 3. Check that the number of entries and groups is zero
 */
  public void testDeleteAllUnfiledRosterEntries(){
    try {
      Roster roster=getConnection(0).getRoster();
      CountDownLatch latch=new CountDownLatch(2);
      setupCountdown(latch,roster);
      roster.createEntry(getBareJID(1),"gato11",null);
      roster.createEntry(getBareJID(2),"gato12",null);
      waitForCountdown(latch,roster,2);
      CountDownLatch removeLatch=new CountDownLatch(2);
      RosterListener latchCounter=new RemovalListener(removeLatch);
      roster.addRosterListener(latchCounter);
      for (      RosterEntry entry : roster.getEntries()) {
        roster.removeEntry(entry);
      }
      removeLatch.await(5,TimeUnit.SECONDS);
      roster.removeRosterListener(latchCounter);
      assertEquals("Wrong number of entries in connection 0",0,roster.getEntryCount());
      assertEquals("Wrong number of groups in connection 0",0,roster.getGroupCount());
      assertEquals("Wrong number of entries in connection 1",0,getConnection(1).getRoster().getEntryCount());
      assertEquals("Wrong number of groups in connection 1",0,getConnection(1).getRoster().getGroupCount());
    }
 catch (    Exception e) {
      fail(e.getMessage());
    }
  }
  /** 
 * 1. Create an unfiled entry 2. Change its name 3. Check that the name has been modified 4. Reload the whole roster 5. Check that the name has been modified
 */
  public void testChangeNameToUnfiledEntry(){
    try {
      Roster roster=getConnection(0).getRoster();
      CountDownLatch latch=new CountDownLatch(1);
      setupCountdown(latch,roster);
      roster.createEntry(getBareJID(1),null,null);
      waitForCountdown(latch,roster,1);
      final CountDownLatch updateLatch=new CountDownLatch(2);
      RosterListener latchCounter=new RosterListener(){
        @Override public void entriesAdded(        Collection<String> addresses){
        }
        @Override public void entriesUpdated(        Collection<String> addresses){
          updateLatch.countDown();
        }
        @Override public void entriesDeleted(        Collection<String> addresses){
        }
        @Override public void presenceChanged(        Presence presence){
        }
      }
;
      roster.addRosterListener(latchCounter);
      for (      RosterEntry entry : roster.getEntries()) {
        entry.setName("gato11");
        assertEquals("gato11",entry.getName());
      }
      roster.reload();
      updateLatch.await(5,TimeUnit.SECONDS);
      for (      RosterEntry entry : roster.getEntries()) {
        assertEquals("gato11",entry.getName());
      }
    }
 catch (    Exception e) {
      fail(e.getMessage());
    }
  }
  /** 
 * 1. Create an unfiled entry with no name 2. Check that the the entry does not belong to any group 3. Change its name and add it to a group 4. Check that the name has been modified and that the entry belongs to a group
 */
  public void testChangeGroupAndNameToUnfiledEntry(){
    try {
      Roster roster=getConnection(0).getRoster();
      roster.createEntry(getBareJID(1),null,null);
      Thread.sleep(500);
      getConnection(1).getRoster().createEntry(getBareJID(0),null,null);
      long initial=System.currentTimeMillis();
      while (System.currentTimeMillis() - initial < 5000 && !roster.getPresence(getBareJID(0)).isAvailable()) {
        Thread.sleep(100);
      }
      for (      RosterEntry entry : roster.getEntries()) {
        assertFalse("The roster entry belongs to a group",!entry.getGroups().isEmpty());
      }
      roster.createEntry(getBareJID(1),"NewName",new String[]{"Friends"});
      Thread.sleep(200);
      for (      RosterEntry entry : roster.getEntries()) {
        assertEquals("Name of roster entry is wrong","NewName",entry.getName());
        assertTrue("The roster entry does not belong to any group",!entry.getGroups().isEmpty());
      }
      initial=System.currentTimeMillis();
      while (System.currentTimeMillis() - initial < 5000 && !roster.getPresence(getBareJID(1)).isAvailable()) {
        Thread.sleep(100);
      }
      assertTrue("Presence not received",roster.getPresence(getBareJID(1)).isAvailable());
    }
 catch (    Exception e) {
      fail(e.getMessage());
    }
  }
  /** 
 * Tests that adding an existing roster entry that belongs to a group to another group works fine.
 */
  public void testAddEntryToNewGroup(){
    try {
      Thread.sleep(500);
      Roster roster=getConnection(0).getRoster();
      roster.createEntry(getBareJID(1),"gato11",new String[]{"Friends"});
      roster.createEntry(getBareJID(2),"gato12",new String[]{"Family"});
      long initial=System.currentTimeMillis();
      while (System.currentTimeMillis() - initial < 2000 && roster.getEntryCount() != 2) {
        Thread.sleep(100);
      }
      assertEquals("Wrong number of entries in connection 0",2,roster.getEntryCount());
      roster.createGroup("NewGroup").addEntry(roster.getEntry(getBareJID(1)));
      XMPPTCPConnection con2=createConnection();
      con2.connect();
      con2.login(getUsername(0),getUsername(0),"MyNewResource");
      Roster roster2=con2.getRoster();
      assertEquals("Wrong number of entries in new connection",2,roster2.getEntryCount());
      assertEquals("Wrong number of groups in new connection",3,roster2.getGroupCount());
      RosterEntry entry=roster2.getEntry(getBareJID(1));
      assertNotNull("No entry for user 1 was found",entry);
      List<String> groupNames=new ArrayList<String>();
      for (      RosterGroup rosterGroup : entry.getGroups()) {
        groupNames.add(rosterGroup.getName());
      }
      assertTrue("Friends group was not found",groupNames.contains("Friends"));
      assertTrue("NewGroup group was not found",groupNames.contains("NewGroup"));
      con2.disconnect();
      Thread.sleep(500);
    }
 catch (    Exception e) {
      fail(e.getMessage());
    }
  }
  /** 
 * Test if renaming a roster group works fine.
 */
  public void testRenameRosterGroup(){
    try {
      Thread.sleep(200);
      Roster roster=getConnection(0).getRoster();
      roster.createEntry(getBareJID(1),"gato11",new String[]{"Friends"});
      roster.createEntry(getBareJID(2),"gato12",new String[]{"Friends"});
      long initial=System.currentTimeMillis();
      while (System.currentTimeMillis() - initial < 2000 && (!roster.getPresence(getBareJID(1)).isAvailable() || !roster.getPresence(getBareJID(2)).isAvailable())) {
        Thread.sleep(100);
      }
      roster.getGroup("Friends").setName("Amigos");
      initial=System.currentTimeMillis();
      while (System.currentTimeMillis() - initial < 2000 && (roster.getGroup("Friends") != null)) {
        Thread.sleep(100);
      }
      assertNull("The group Friends still exists",roster.getGroup("Friends"));
      assertNotNull("The group Amigos does not exist",roster.getGroup("Amigos"));
      assertEquals("Wrong number of entries in the group Amigos",2,roster.getGroup("Amigos").getEntryCount());
      roster.getGroup("Amigos").setName("");
      initial=System.currentTimeMillis();
      while (System.currentTimeMillis() - initial < 2000 && (roster.getGroup("Amigos") != null)) {
        Thread.sleep(100);
      }
      assertNull("The group Amigos still exists",roster.getGroup("Amigos"));
      assertNull("The group with no name does exist",roster.getGroup(""));
      assertEquals("There are still groups in the roster",0,roster.getGroupCount());
      assertEquals("Wrong number of unfiled entries",2,roster.getUnfiledEntryCount());
      Thread.sleep(200);
    }
 catch (    Exception e) {
      fail(e.getMessage());
    }
  }
  /** 
 * Test presence management.<p> 1. Log in user0 from a client and user1 from 2 clients 2. Create presence subscription of type BOTH between 2 users 3. Check that presence is correctly delivered to both users 4. User1 logs out from a client 5. Check that presence for each connected resource is correct
 */
  public void testRosterPresences() throws Exception {
    Presence presence;
    ConnectionConfiguration connectionConfiguration=new ConnectionConfiguration(getHost(),getPort(),getXMPPServiceDomain());
    XMPPTCPConnection conn4=new XMPPConnection(connectionConfiguration);
    conn4.connect();
    conn4.login(getUsername(1),getPassword(1),"Home");
    Roster roster=getConnection(0).getRoster();
    roster.createEntry(getBareJID(1),"gato11",null);
    long initial=System.currentTimeMillis();
    while (System.currentTimeMillis() - initial < 2000 && (roster.getPresence(getBareJID(1)).getType() == Presence.Type.unavailable)) {
      Thread.sleep(100);
    }
    presence=roster.getPresence(getBareJID(1));
    assertTrue("Returned a null Presence for an existing user",presence.isAvailable());
    presence=roster.getPresenceResource(getUsername(1) + "@" + conn4.getXMPPServiceDomain()+ "/Home");
    assertEquals("Returned the wrong Presence","Home",StringUtils.parseResource(presence.getFrom()));
    presence=roster.getPresenceResource(getFullJID(1));
    assertTrue("Presence not found for user " + getFullJID(1),presence.isAvailable());
    assertEquals("Returned the wrong Presence","Smack",StringUtils.parseResource(presence.getFrom()));
    presence=roster.getPresenceResource("noname@" + getXMPPServiceDomain() + "/Smack");
    assertFalse("Available presence was returned for a non-existing user",presence.isAvailable());
    assertEquals("Returned Presence for a non-existing user has the incorrect type",Presence.Type.unavailable,presence.getType());
    Iterator<Presence> presences=roster.getPresences(getBareJID(1));
    int count=0;
    while (presences.hasNext()) {
      count++;
      presences.next();
    }
    assertEquals("Wrong number of returned presences",count,2);
    conn4.disconnect();
    presences=roster.getPresences(getBareJID(1));
    count=0;
    while (presences.hasNext()) {
      count++;
      presences.next();
    }
    assertEquals("Wrong number of returned presences",count,1);
  }
  /** 
 * User1 is connected from 2 resources. User1 adds User0 to his roster. Ensure that both resources of user1 get the available presence of User0. Remove User0 from User1's roster and check presences again.
 */
  public void testMultipleResources() throws Exception {
    ConnectionConfiguration connectionConfiguration=new ConnectionConfiguration(getHost(),getPort(),getXMPPServiceDomain());
    XMPPTCPConnection conn4=new XMPPConnection(connectionConfiguration);
    conn4.connect();
    conn4.login(getUsername(1),getPassword(1),"Home");
    Roster roster=conn4.getRoster();
    roster.createEntry(getBareJID(0),"gato11",null);
    long initial=System.currentTimeMillis();
    while (System.currentTimeMillis() - initial < 2000 && (!roster.getPresence(getBareJID(0)).isAvailable() || !getConnection(1).getRoster().getPresence(getBareJID(0)).isAvailable())) {
      Thread.sleep(100);
    }
    Presence presence=roster.getPresence(getBareJID(0));
    assertTrue("Returned a null Presence for an existing user",presence.isAvailable());
    presence=getConnection(1).getRoster().getPresence(getBareJID(0));
    assertTrue("Returned a null Presence for an existing user",presence.isAvailable());
    roster.removeEntry(roster.getEntry(getBareJID(0)));
    initial=System.currentTimeMillis();
    while (System.currentTimeMillis() - initial < 2000 && (roster.getPresence(getBareJID(0)).getType() != Presence.Type.unavailable || getConnection(1).getRoster().getPresence(getBareJID(0)).getType() != Presence.Type.unavailable)) {
      Thread.sleep(100);
    }
    presence=roster.getPresence(getBareJID(0));
    assertFalse("Available presence was returned for removed contact",presence.isAvailable());
    assertEquals("Returned Presence for removed contact has incorrect type",Presence.Type.unavailable,presence.getType());
    presence=getConnection(1).getRoster().getPresence(getBareJID(0));
    assertFalse("Available presence was returned for removed contact",presence.isAvailable());
    assertEquals("Returned Presence for removed contact has incorrect type",Presence.Type.unavailable,presence.getType());
  }
  /** 
 * Tests that the server and Smack are able to handle nicknames that include < > characters.
 */
  public void testNotCommonNickname() throws Exception {
    Roster roster=getConnection(0).getRoster();
    roster.createEntry(getBareJID(1),"Thiago <12001200>",null);
    Thread.sleep(500);
    assertEquals("Created entry was never received",1,roster.getEntryCount());
    ConnectionConfiguration connectionConfiguration=new ConnectionConfiguration(getHost(),getPort(),getXMPPServiceDomain());
    XMPPTCPConnection conn2=new XMPPConnection(connectionConfiguration);
    conn2.connect();
    conn2.login(getUsername(0),getPassword(0),"Home");
    Roster roster2=conn2.getRoster();
    assertEquals("Created entry was never received",1,roster2.getEntryCount());
    RosterEntry entry=roster2.getEntry(getBareJID(1));
    assertNotNull("New entry was not returned from the server",entry);
    assertEquals("Roster item name is incorrect","Thiago <12001200>",entry.getName());
  }
  /** 
 * Clean up all the entries in the roster
 */
  private void cleanUpRoster(){
    for (int i=0; i < getMaxConnections(); i++) {
      Roster roster=getConnection(i).getRoster();
      final CountDownLatch removalLatch=new CountDownLatch(roster.getEntryCount());
      roster.addRosterListener(new RosterListener(){
        @Override public void presenceChanged(        Presence presence){
        }
        @Override public void entriesUpdated(        Collection<String> addresses){
        }
        @Override public void entriesDeleted(        Collection<String> addresses){
          removalLatch.countDown();
        }
        @Override public void entriesAdded(        Collection<String> addresses){
        }
      }
);
      for (      RosterEntry entry : roster.getEntries()) {
        try {
          roster.removeEntry(entry);
        }
 catch (        XMPPException e) {
          e.printStackTrace();
          fail(e.getMessage());
        }
      }
      try {
        removalLatch.await(5,TimeUnit.SECONDS);
      }
 catch (      InterruptedException e) {
        fail(e.getMessage());
      }
    }
    assertEquals("Wrong number of entries in connection 0",0,getConnection(0).getRoster().getEntryCount());
    assertEquals("Wrong number of entries in connection 1",0,getConnection(1).getRoster().getEntryCount());
    assertEquals("Wrong number of entries in connection 2",0,getConnection(2).getRoster().getEntryCount());
  }
  /** 
 * Tests the creation of a roster and then simulates abrupt termination. Cached presences must go offline. At reconnection, presences must go back to online. <ol> <li> Create some entries <li> Breack the connection <li> Check offline presences <li> Whait for automatic reconnection <li> Check online presences </ol>
 */
  public void testOfflinePresencesAfterDisconnection() throws Exception {
    Roster roster=getConnection(0).getRoster();
    roster.createEntry(getBareJID(1),"gato11",null);
    roster.createEntry(getBareJID(2),"gato12",null);
    long initial=System.currentTimeMillis();
    while (System.currentTimeMillis() - initial < 2000 && (!roster.getPresence(getBareJID(1)).isAvailable() || !roster.getPresence(getBareJID(2)).isAvailable())) {
      Thread.sleep(100);
    }
    Thread.sleep(200);
    getConnection(0).notifyConnectionError(new Exception("Simulated Error"));
    Presence presence=roster.getPresence(getBareJID(1));
    assertFalse("Unavailable presence not found for offline user",presence.isAvailable());
    assertEquals("Unavailable presence not found for offline user",Presence.Type.unavailable,presence.getType());
    Thread.sleep(12200);
    presence=roster.getPresence(getBareJID(1));
    assertTrue("Presence not found for user",presence.isAvailable());
    assertEquals("Presence should be online after a connection reconnection",Presence.Type.available,presence.getType());
  }
  protected int getMaxConnections(){
    return 3;
  }
  protected void setUp() throws Exception {
    super.setUp();
    cleanUpRoster();
  }
  @Override protected void tearDown() throws Exception {
    cleanUpRoster();
    super.tearDown();
  }
private class RemovalListener implements RosterListener {
    private CountDownLatch latch;
    private RemovalListener(    CountDownLatch removalLatch){
      latch=removalLatch;
    }
    @Override public void presenceChanged(    Presence presence){
    }
    @Override public void entriesUpdated(    Collection<String> addresses){
    }
    @Override public void entriesDeleted(    Collection<String> addresses){
      latch.countDown();
    }
    @Override public void entriesAdded(    Collection<String> addresses){
    }
  }
}
