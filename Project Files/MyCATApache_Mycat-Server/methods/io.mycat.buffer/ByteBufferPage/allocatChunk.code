public ByteBuffer allocatChunk(int theChunkCount){
  if (!allocLockStatus.compareAndSet(false,true)) {
    return null;
  }
  int startChunk=-1;
  int contiueCount=0;
  try {
    for (int i=0; i < chunkCount; i++) {
      if (chunkAllocateTrack.get(i) == false) {
        if (startChunk == -1) {
          startChunk=i;
          contiueCount=1;
          if (theChunkCount == 1) {
            break;
          }
        }
 else {
          if (++contiueCount == theChunkCount) {
            break;
          }
        }
      }
 else {
        startChunk=-1;
        contiueCount=0;
      }
    }
    if (contiueCount == theChunkCount) {
      int offStart=startChunk * chunkSize;
      int offEnd=offStart + theChunkCount * chunkSize;
      buf.limit(offEnd);
      buf.position(offStart);
      ByteBuffer newBuf=buf.slice();
      markChunksUsed(startChunk,theChunkCount);
      relationBufferThreadId.put(((DirectBuffer)newBuf).address(),Thread.currentThread().getId());
      return newBuf;
    }
 else {
      return null;
    }
  }
  finally {
    allocLockStatus.set(false);
  }
}
