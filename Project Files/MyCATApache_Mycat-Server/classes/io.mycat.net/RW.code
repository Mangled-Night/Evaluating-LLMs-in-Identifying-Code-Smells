private final class RW implements Runnable {
  private volatile Selector selector;
  private final ConcurrentLinkedQueue<AbstractConnection> registerQueue;
  private long reactCount;
  private RW() throws IOException {
    this.selector=Selector.open();
    this.registerQueue=new ConcurrentLinkedQueue<AbstractConnection>();
  }
  @Override public void run(){
    int invalidSelectCount=0;
    Set<SelectionKey> keys=null;
    for (; ; ) {
      ++reactCount;
      try {
        final Selector tSelector=this.selector;
        long start=System.nanoTime();
        tSelector.select(500L);
        long end=System.nanoTime();
        register(tSelector);
        keys=tSelector.selectedKeys();
        if (keys.size() == 0 && (end - start) < SelectorUtil.MIN_SELECT_TIME_IN_NANO_SECONDS) {
          invalidSelectCount++;
        }
 else {
          invalidSelectCount=0;
          for (          SelectionKey key : keys) {
            AbstractConnection con=null;
            try {
              Object att=key.attachment();
              if (att != null) {
                con=(AbstractConnection)att;
                if (key.isValid() && key.isReadable()) {
                  try {
                    con.asynRead();
                  }
 catch (                  IOException e) {
                    con.close("program err:" + e.toString());
                    continue;
                  }
catch (                  Exception e) {
                    LOGGER.warn("caught err:",e);
                    con.close("program err:" + e.toString());
                    continue;
                  }
                }
                if (key.isValid() && key.isWritable()) {
                  con.doNextWriteCheck();
                }
              }
 else {
                key.cancel();
              }
            }
 catch (            CancelledKeyException e) {
              if (LOGGER.isDebugEnabled()) {
                LOGGER.debug(con + " socket key canceled");
              }
            }
catch (            Exception e) {
              LOGGER.warn(con + " " + e);
            }
catch (            final Throwable e) {
              if (con != null) {
                con.close("Bad: " + e);
              }
              LOGGER.error("caught err: ",e);
              continue;
            }
          }
        }
        if (invalidSelectCount > SelectorUtil.REBUILD_COUNT_THRESHOLD) {
          final Selector rebuildSelector=SelectorUtil.rebuildSelector(this.selector);
          if (rebuildSelector != null) {
            this.selector=rebuildSelector;
          }
          invalidSelectCount=0;
        }
      }
 catch (      Exception e) {
        LOGGER.warn(name,e);
      }
catch (      final Throwable e) {
        LOGGER.error("caught err: ",e);
      }
 finally {
        if (keys != null) {
          keys.clear();
        }
      }
    }
  }
  private void register(  Selector selector){
    AbstractConnection c=null;
    if (registerQueue.isEmpty()) {
      return;
    }
    while ((c=registerQueue.poll()) != null) {
      try {
        ((NIOSocketWR)c.getSocketWR()).register(selector);
        c.register();
      }
 catch (      Exception e) {
        c.close("register err" + e.toString());
      }
    }
  }
}
