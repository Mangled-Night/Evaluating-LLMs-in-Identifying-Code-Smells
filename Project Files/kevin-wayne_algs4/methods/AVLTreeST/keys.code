/** 
 * Returns all keys in the symbol table.
 * @return all keys in the symbol table
 */
public Iterable<Key> keys(){
  return keysInOrder();
}
/** 
 * Returns all keys in the symbol table in the given range.
 * @param lo the lowest key
 * @param hi the highest key
 * @return all keys in the symbol table between {@code lo} (inclusive)and  {@code hi} (exclusive)
 * @throws IllegalArgumentException if either {@code lo} or {@code hi}is  {@code null}
 */
public Iterable<Key> keys(Key lo,Key hi){
  if (lo == null)   throw new IllegalArgumentException("first argument to keys() is null");
  if (hi == null)   throw new IllegalArgumentException("second argument to keys() is null");
  Queue<Key> queue=new Queue<Key>();
  keys(root,queue,lo,hi);
  return queue;
}
/** 
 * Adds the keys between  {@code lo} and {@code hi} in the subtreeto the  {@code queue}.
 * @param x the subtree
 * @param queue the queue
 * @param lo the lowest key
 * @param hi the highest key
 */
private void keys(Node x,Queue<Key> queue,Key lo,Key hi){
  if (x == null)   return;
  int cmplo=lo.compareTo(x.key);
  int cmphi=hi.compareTo(x.key);
  if (cmplo < 0)   keys(x.left,queue,lo,hi);
  if (cmplo <= 0 && cmphi >= 0)   queue.enqueue(x.key);
  if (cmphi > 0)   keys(x.right,queue,lo,hi);
}
