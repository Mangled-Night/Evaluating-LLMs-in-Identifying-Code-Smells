public void run(List<? extends XMPPConnection> connections,final long replyTimeoutMillis) throws InterruptedException, NotAllMessagesReceivedException, ErrorsWhileSendingOrReceivingException {
  final MultiMap<XMPPConnection,Message> messages=new MultiMap<>();
  final Random random=new Random(configuration.seed);
  final Map<XMPPConnection,Exception> sendExceptions=new ConcurrentHashMap<>();
  final Map<XMPPConnection,Exception> receiveExceptions=new ConcurrentHashMap<>();
  waitStart=-1;
  for (  XMPPConnection fromConnection : connections) {
    MultiMap<XMPPConnection,Message> toConnectionMessages=new MultiMap<>();
    for (    XMPPConnection toConnection : connections) {
      for (int i=0; i < configuration.messagesPerConnection; i++) {
        MessageBuilder messageBuilder=fromConnection.getStanzaFactory().buildMessageStanza();
        messageBuilder.to(toConnection.getUser());
        final int payloadChunkCount;
        if (configuration.maxPayloadChunks == 0) {
          payloadChunkCount=0;
        }
 else {
          payloadChunkCount=random.nextInt(configuration.maxPayloadChunks) + 1;
        }
        for (int c=0; c < payloadChunkCount; c++) {
          int payloadChunkSize=random.nextInt(configuration.maxPayloadChunkSize) + 1;
          String payloadCunk=StringUtils.randomString(payloadChunkSize,random);
          JivePropertiesManager.addProperty(messageBuilder,"payload-chunk-" + c,payloadCunk);
        }
        JivePropertiesManager.addProperty(messageBuilder,MESSAGE_NUMBER_PROPERTY,i);
        Message message=messageBuilder.build();
        toConnectionMessages.put(toConnection,message);
      }
    }
    if (configuration.intermixMessages) {
      while (!toConnectionMessages.isEmpty()) {
        int next=random.nextInt(connections.size());
        Message message=null;
        while (message == null) {
          XMPPConnection toConnection=connections.get(next);
          message=toConnectionMessages.getFirst(toConnection);
          next=(next + 1) % connections.size();
        }
        messages.put(fromConnection,message);
      }
    }
 else {
      for (      XMPPConnection toConnection : connections) {
        for (        Message message : toConnectionMessages.getAll(toConnection)) {
          messages.put(fromConnection,message);
        }
      }
    }
  }
  Semaphore receivedSemaphore=new Semaphore(-connections.size() + 1);
  Map<XMPPConnection,Map<EntityFullJid,boolean[]>> receiveMarkers=new ConcurrentHashMap<>(connections.size());
  for (  XMPPConnection connection : connections) {
    final Map<EntityFullJid,boolean[]> myReceiveMarkers=new HashMap<>(connections.size());
    receiveMarkers.put(connection,myReceiveMarkers);
    for (    XMPPConnection otherConnection : connections) {
      boolean[] fromMarkers=new boolean[configuration.messagesPerConnection];
      myReceiveMarkers.put(otherConnection.getUser(),fromMarkers);
    }
    connection.addSyncStanzaListener(new StanzaListener(){
      @Override public void processStanza(      Stanza stanza){
        waitStart=System.currentTimeMillis();
        EntityFullJid from=stanza.getFrom().asEntityFullJidOrThrow();
        Message message=(Message)stanza;
        JivePropertiesExtension extension=JivePropertiesExtension.from(message);
        Integer messageNumber=(Integer)extension.getProperty(MESSAGE_NUMBER_PROPERTY);
        boolean[] fromMarkers=myReceiveMarkers.get(from);
        for (int i=0; i < fromMarkers.length; i++) {
          final String inOrderViolation;
          if (i < messageNumber && !fromMarkers[i]) {
            inOrderViolation="not yet message #";
          }
 else           if (i >= messageNumber && fromMarkers[i]) {
            inOrderViolation="we already received a later (or the same) message #";
          }
 else {
            continue;
          }
          StringBuilder exceptionMessage=new StringBuilder();
          exceptionMessage.append("We received message #").append(messageNumber).append(" but ");
          exceptionMessage.append(inOrderViolation);
          exceptionMessage.append(i);
          exceptionMessage.append("\nMessage with id ").append(stanza.getStanzaId()).append(" from ").append(from).append(" to ").append(stanza.getTo()).append('\n');
          exceptionMessage.append("From Markers: ").append(Arrays.toString(fromMarkers)).append('\n');
          Exception exception=new Exception(exceptionMessage.toString());
          receiveExceptions.put(connection,exception);
          connection.removeSyncStanzaListener(this);
          receivedSemaphore.release();
          return;
        }
        fromMarkers[messageNumber]=true;
        for (        boolean[] markers : myReceiveMarkers.values()) {
          if (BooleansUtils.contains(markers,false)) {
            return;
          }
        }
        receivedSemaphore.release();
      }
    }
,new AndFilter(MessageTypeFilter.NORMAL,new StanzaExtensionFilter(JivePropertiesExtension.ELEMENT,JivePropertiesExtension.NAMESPACE)));
  }
  Semaphore sendSemaphore=new Semaphore(-connections.size() + 1);
  for (  XMPPConnection connection : connections) {
    Async.go(() -> {
      List<Message> messagesToSend;
synchronized (messages) {
        messagesToSend=messages.getAll(connection);
      }
      try {
        for (        Message messageToSend : messagesToSend) {
          connection.sendStanza(messageToSend);
        }
      }
 catch (      NotConnectedException|InterruptedException e) {
        sendExceptions.put(connection,e);
      }
 finally {
        sendSemaphore.release();
      }
    }
);
  }
  sendSemaphore.acquire();
  if (waitStart < 0) {
    waitStart=System.currentTimeMillis();
  }
  boolean acquired;
  do {
    long acquireWait=waitStart + replyTimeoutMillis - System.currentTimeMillis();
    acquired=receivedSemaphore.tryAcquire(acquireWait,TimeUnit.MILLISECONDS);
  }
 while (!acquired && System.currentTimeMillis() < waitStart + replyTimeoutMillis);
  if (!acquired && receiveExceptions.isEmpty() && sendExceptions.isEmpty()) {
    throw new StressTestFailedException.NotAllMessagesReceivedException(receiveMarkers,connections);
  }
  if (!receiveExceptions.isEmpty() || !sendExceptions.isEmpty()) {
    throw new StressTestFailedException.ErrorsWhileSendingOrReceivingException(sendExceptions,receiveExceptions);
  }
}
