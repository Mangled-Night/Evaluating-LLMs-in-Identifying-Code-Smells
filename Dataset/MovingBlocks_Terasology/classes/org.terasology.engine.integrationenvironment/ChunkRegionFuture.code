/** 
 * Completes when all the chunks in a region are loaded.
 * @see MainLoop#makeBlocksRelevant
 * @see MainLoop#makeChunksRelevant
 */
@SuppressWarnings("checkstyle:finalclass") public class ChunkRegionFuture {
  public static final int REQUIRED_CHUNK_MARGIN=1;
  private static final Logger logger=LoggerFactory.getLogger(ChunkRegionFuture.class);
  protected final SettableFuture<ChunkRegionFuture> future=SettableFuture.create();
  protected final Set<Chunk> loadedChunks=new HashSet<>();
  protected final BlockRegion chunks=new BlockRegion(BlockRegion.INVALID);
  private final EntityRef entity;
  private ChunkRegionFuture(  EntityRef entity,  Function<ChunkRegionListener,BlockRegionc> chunks){
    this.entity=entity;
    this.chunks.set(chunks.apply(new Listener(this::onChunkRelevant)));
  }
  /** 
 * Load an area of the world. <p> The area is defined as a  {@index "relevance region"} and will not be unloaded as long as {@link #entity} existsand has a  {@link LocationComponent}.
 * @param entityManager used to create the entity that depends on this region
 * @param relevanceSystem the authority on what is relevant
 * @param center a point to center the region around, in block coordinates
 * @param sizeInChunks the size of the region, in chunks
 */
  static ChunkRegionFuture create(  EntityManager entityManager,  RelevanceSystem relevanceSystem,  Vector3fc center,  Vector3ic sizeInChunks){
    EntityRef entity=entityManager.create(new LocationComponent(center));
    entity.setScope(EntityScope.GLOBAL);
    Vector3ic correctedSizeInChunks=addMargin(sizeInChunks);
    Function<ChunkRegionListener,BlockRegionc> makeChunksRelevant=listener -> {
      BlockRegionc paddedRegion=relevanceSystem.addRelevanceEntity(entity,correctedSizeInChunks,listener);
      return removeMargin(paddedRegion);
    }
;
    return new ChunkRegionFuture(entity,makeChunksRelevant);
  }
  /** 
 * Removes the margin added by  {@link #addMargin}.
 * @return new instance of the contained region
 */
  private static BlockRegionc removeMargin(  BlockRegionc relRegion){
    return relRegion.expand(-REQUIRED_CHUNK_MARGIN,-REQUIRED_CHUNK_MARGIN,-REQUIRED_CHUNK_MARGIN,new BlockRegion(BlockRegion.INVALID));
  }
  private static Vector3ic addMargin(  Vector3ic sizeInChunks){
    Vector3i desiredSize=new Vector3i(sizeInChunks);
    desiredSize.x|=1;
    desiredSize.y|=1;
    desiredSize.z|=1;
    desiredSize.add(2 * REQUIRED_CHUNK_MARGIN,2 * REQUIRED_CHUNK_MARGIN,2 * REQUIRED_CHUNK_MARGIN);
    return desiredSize;
  }
  /** 
 * Completes when all expected chunks have loaded. <p> <b>Experimental:</b> Unsure which objects are useful to return, I made a bunch of them available through this class and we return the whole thing. Though returning a future for an object the caller already has doesn't make a lot of sense.
 * @return complete when all expected chunks have loaded
 */
  public ListenableFuture<ChunkRegionFuture> getFuture(){
    return future;
  }
  @SuppressWarnings("unused") public Set<Chunk> getLoadedChunks(){
    return Collections.unmodifiableSet(loadedChunks);
  }
  /** 
 * The entity defining the relevance region. 
 */
  public EntityRef getEntity(){
    return entity;
  }
  @SuppressWarnings("unused") public BlockRegionc getChunkRegion(){
    return chunks;
  }
  protected void onChunkRelevant(  Chunk chunk){
    loadedChunks.add(chunk);
    if (chunks.isValid()) {
      logger.debug("Got chunk {} / {}",loadedChunks.size(),chunks.volume());
      if (loadedChunks.size() >= chunks.volume() && !future.isDone()) {
        future.set(this);
      }
    }
  }
  /** 
 * Adapts a  {@code Consumer<Chunk>} to a {@code ChunkRegionListener}. 
 */
private static class Listener implements ChunkRegionListener {
    private final Consumer<Chunk> onChunk;
    Listener(    Consumer<Chunk> onChunk){
      this.onChunk=onChunk;
    }
    @Override public void onChunkRelevant(    Vector3ic pos,    Chunk chunk){
      onChunk.accept(chunk);
    }
    @Override public void onChunkIrrelevant(    Vector3ic pos){
    }
  }
}
