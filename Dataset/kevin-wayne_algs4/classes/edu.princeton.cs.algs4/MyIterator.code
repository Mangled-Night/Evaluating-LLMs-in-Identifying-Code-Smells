private class MyIterator implements Iterator<Key> {
  BinomialMinPQ<Key> data;
  public MyIterator(){
    data=new BinomialMinPQ<Key>(comp);
    data.head=clone(head,null);
  }
  private Node clone(  Node x,  Node parent){
    if (x == null)     return null;
    Node node=new Node();
    node.key=x.key;
    node.sibling=clone(x.sibling,parent);
    node.child=clone(x.child,node);
    return node;
  }
  public boolean hasNext(){
    return !data.isEmpty();
  }
  public Key next(){
    if (!hasNext())     throw new NoSuchElementException();
    return data.delMin();
  }
  public void remove(){
    throw new UnsupportedOperationException();
  }
}
private class MyIterator implements Iterator<Key> {
  private FibonacciMinPQ<Key> copy;
  public MyIterator(){
    copy=new FibonacciMinPQ<Key>(comp);
    insertAll(head);
  }
  private void insertAll(  Node head){
    if (head == null)     return;
    Node x=head;
    do {
      copy.insert(x.key);
      insertAll(x.child);
      x=x.next;
    }
 while (x != head);
  }
  public void remove(){
    throw new UnsupportedOperationException();
  }
  public boolean hasNext(){
    return !copy.isEmpty();
  }
  public Key next(){
    if (!hasNext())     throw new NoSuchElementException();
    return copy.delMin();
  }
}
private class MyIterator implements Iterator<Integer> {
  IndexBinomialMinPQ<Key> data;
  public MyIterator(){
    data=new IndexBinomialMinPQ<Key>(n,comparator);
    data.head=clone(head,null);
  }
  private Node<Key> clone(  Node<Key> x,  Node<Key> parent){
    if (x == null)     return null;
    Node<Key> node=new Node<Key>();
    node.index=x.index;
    node.key=x.key;
    data.nodes[node.index]=node;
    node.parent=parent;
    node.sibling=clone(x.sibling,parent);
    node.child=clone(x.child,node);
    return node;
  }
  public boolean hasNext(){
    return !data.isEmpty();
  }
  public Integer next(){
    if (!hasNext())     throw new NoSuchElementException();
    return data.delMin();
  }
  public void remove(){
    throw new UnsupportedOperationException();
  }
}
private class MyIterator implements Iterator<Integer> {
  private IndexFibonacciMinPQ<Key> copy;
  public MyIterator(){
    copy=new IndexFibonacciMinPQ<Key>(comp,n);
    for (    Node<Key> x : nodes) {
      if (x != null)       copy.insert(x.index,x.key);
    }
  }
  public void remove(){
    throw new UnsupportedOperationException();
  }
  public boolean hasNext(){
    return !copy.isEmpty();
  }
  public Integer next(){
    if (!hasNext())     throw new NoSuchElementException();
    return copy.delMin();
  }
}
private class MyIterator implements Iterator<Integer> {
  IndexMultiwayMinPQ<Key> clone;
  public MyIterator(){
    clone=new IndexMultiwayMinPQ<Key>(nmax,comp,d);
    for (int i=0; i < n; i++) {
      clone.insert(pq[i + d],keys[pq[i + d] + d]);
    }
  }
  public boolean hasNext(){
    return !clone.isEmpty();
  }
  public Integer next(){
    if (!hasNext())     throw new NoSuchElementException();
    return clone.delMin();
  }
  public void remove(){
    throw new UnsupportedOperationException();
  }
}
private class MyIterator implements Iterator<Key> {
  MultiwayMinPQ<Key> data;
  public MyIterator(){
    data=new MultiwayMinPQ<Key>(comp,d);
    data.keys=(Key[])new Comparable[keys.length];
    data.n=n;
    for (int i=0; i < keys.length; i++) {
      data.keys[i]=keys[i];
    }
  }
  public boolean hasNext(){
    return !data.isEmpty();
  }
  public Key next(){
    if (!hasNext())     throw new NoSuchElementException();
    return data.delMin();
  }
  public void remove(){
    throw new UnsupportedOperationException();
  }
}
