@SuppressWarnings("UnusedVariable") @Override public void run(){
  try {
    LOGGER.fine("Listening for ECHO: " + socket.getLocalAddress().getHostAddress() + ":"+ socket.getLocalPort());
    while (true) {
      DatagramPacket packet=new DatagramPacket(new byte[150],150);
      socket.receive(packet);
      boolean accept=false;
      ByteBuffer buf=ByteBuffer.wrap(packet.getData());
      byte[] content=new byte[packet.getLength()];
      buf=buf.get(content,0,packet.getLength());
      packet.setData(content);
      for (      DatagramListener listener : listeners) {
        accept=listener.datagramReceived(packet);
        if (accept)         break;
      }
      long delay=100 / replyTries;
      String[] str=new String(packet.getData(),"UTF-8").split(";");
      String pass=str[0];
      String[] address=str[1].split(":");
      String ip=address[0];
      String port=address[1];
      if (pass.equals(candidate.getPassword()) && !accept) {
        byte[] cont=null;
        try {
          cont=(password + ";" + candidate.getIp()+ ":"+ candidate.getPort()).getBytes("UTF-8");
        }
 catch (        UnsupportedEncodingException e) {
          LOGGER.log(Level.WARNING,"exception",e);
        }
        packet.setData(cont);
        packet.setLength(cont.length);
        packet.setAddress(InetAddress.getByName(ip));
        packet.setPort(Integer.parseInt(port));
        for (int i=0; i < replyTries; i++) {
          socket.send(packet);
          if (!enabled)           break;
          try {
            Thread.sleep(delay);
          }
 catch (          InterruptedException e) {
            LOGGER.log(Level.WARNING,"exception",e);
          }
        }
      }
    }
  }
 catch (  UnknownHostException uhe) {
    if (enabled) {
    }
  }
catch (  SocketException se) {
    if (enabled) {
    }
  }
catch (  IOException ioe) {
    if (enabled) {
    }
  }
catch (  Exception e) {
    if (enabled) {
    }
  }
}
@Override public void run(){
  DatagramListener listener=new DatagramListener(){
    @Override public boolean datagramReceived(    DatagramPacket datagramPacket){
      try {
        LOGGER.fine("ECHO Received to: " + candidate.getIp() + ":"+ candidate.getPort()+ "  data: "+ new String(datagramPacket.getData(),"UTF-8"));
        String[] str=new String(datagramPacket.getData(),"UTF-8").split(";");
        String pass=str[0];
        String[] addr=str[1].split(":");
        String ip=addr[0];
        String pt=addr[1];
        if (pass.equals(password) && transportCandidate.getIp().indexOf(ip) != -1 && transportCandidate.getPort() == Integer.parseInt(pt)) {
          LOGGER.fine("ECHO OK: " + candidate.getIp() + ":"+ candidate.getPort()+ " <-> "+ transportCandidate.getIp()+ ":"+ transportCandidate.getPort());
          TestResult testResult=new TestResult();
          testResult.setResult(true);
          ended=true;
          fireTestResult(testResult,transportCandidate);
          return true;
        }
      }
 catch (      UnsupportedEncodingException e) {
        LOGGER.log(Level.WARNING,"exception",e);
      }
      LOGGER.fine("ECHO Wrong Data: " + datagramPacket.getAddress().getHostAddress() + ":"+ datagramPacket.getPort());
      return false;
    }
  }
;
  addListener(listener);
  byte[] content=null;
  try {
    content=new String(password + ";" + getIp()+ ":"+ getPort()).getBytes("UTF-8");
  }
 catch (  UnsupportedEncodingException e) {
    LOGGER.log(Level.WARNING,"exception",e);
  }
  DatagramPacket packet=new DatagramPacket(content,content.length);
  try {
    packet.setAddress(InetAddress.getByName(transportCandidate.getIp()));
  }
 catch (  UnknownHostException e) {
    LOGGER.log(Level.WARNING,"exception",e);
  }
  packet.setPort(transportCandidate.getPort());
  long delay=200;
  try {
    for (int i=0; i < tries; i++) {
      socket.send(packet);
      if (ended)       break;
      try {
        Thread.sleep(delay);
      }
 catch (      InterruptedException e) {
        LOGGER.log(Level.WARNING,"exception",e);
      }
    }
  }
 catch (  IOException e) {
  }
  try {
    Thread.sleep(2000);
  }
 catch (  InterruptedException e) {
    LOGGER.log(Level.WARNING,"exception",e);
  }
  removeListener(listener);
}
