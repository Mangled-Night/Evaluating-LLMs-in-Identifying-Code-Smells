/** 
 * Unit tests for  {@link ClusterNodeEndpoint}.
 * @author Mark Paluch
 */
@ExtendWith(MockitoExtension.class) class ClusterNodeEndpointUnitTests {
  private AsyncCommand<String,String,String> command=new AsyncCommand<>(new Command<>(CommandType.APPEND,new StatusOutput<>(StringCodec.UTF8),null));
  private Queue<RedisCommand<String,String,?>> disconnectedBuffer;
  @Mock private ClientOptions clientOptions;
  @Mock private ClientResources clientResources;
  @Mock private RedisChannelWriter clusterChannelWriter;
  private ClusterNodeEndpoint sut;
  @BeforeEach void before(){
    when(clientOptions.getRequestQueueSize()).thenReturn(1000);
    when(clientOptions.getDisconnectedBehavior()).thenReturn(ClientOptions.DisconnectedBehavior.DEFAULT);
    prepareNewEndpoint();
  }
  @Test void closeWithoutCommands(){
    sut.closeAsync();
    verifyNoInteractions(clusterChannelWriter);
  }
  @Test void closeWithQueuedCommands(){
    disconnectedBuffer.add(command);
    sut.closeAsync();
    verify(clusterChannelWriter).write(command);
  }
  @Test void closeWithCancelledQueuedCommands(){
    disconnectedBuffer.add(command);
    command.cancel();
    sut.closeAsync();
    verifyNoInteractions(clusterChannelWriter);
  }
  @Test void closeWithQueuedCommandsFails(){
    disconnectedBuffer.add(command);
    when(clusterChannelWriter.write(any(RedisCommand.class))).thenThrow(new RedisException("meh"));
    sut.closeAsync();
    assertThat(command.isDone()).isTrue();
    assertThatThrownBy(() -> TestFutures.awaitOrTimeout(command)).isInstanceOf(RedisException.class);
  }
  @Test void closeWithBufferedCommands(){
    when(clientOptions.getDisconnectedBehavior()).thenReturn(ClientOptions.DisconnectedBehavior.ACCEPT_COMMANDS);
    prepareNewEndpoint();
    sut.write(command);
    sut.closeAsync();
    verify(clusterChannelWriter).write(command);
  }
  @Test void closeWithCancelledBufferedCommands(){
    when(clientOptions.getDisconnectedBehavior()).thenReturn(ClientOptions.DisconnectedBehavior.ACCEPT_COMMANDS);
    prepareNewEndpoint();
    sut.write(command);
    command.cancel();
    sut.closeAsync();
    verifyNoInteractions(clusterChannelWriter);
  }
  @Test void closeWithBufferedCommandsFails(){
    when(clientOptions.getDisconnectedBehavior()).thenReturn(ClientOptions.DisconnectedBehavior.ACCEPT_COMMANDS);
    prepareNewEndpoint();
    sut.write(command);
    when(clusterChannelWriter.write(any(RedisCommand.class))).thenThrow(new RedisException(""));
    sut.closeAsync();
    assertThatThrownBy(() -> TestFutures.awaitOrTimeout(command)).isInstanceOf(RedisException.class);
  }
  private void prepareNewEndpoint(){
    sut=new ClusterNodeEndpoint(clientOptions,clientResources,clusterChannelWriter);
    disconnectedBuffer=(Queue)ReflectionTestUtils.getField(sut,"disconnectedBuffer");
  }
}
