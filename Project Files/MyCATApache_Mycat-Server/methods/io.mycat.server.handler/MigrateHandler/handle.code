public static void handle(String stmt,ServerConnection c){
  Map<String,String> map=parse(stmt);
  String table=map.get("table");
  String add=map.get("add");
  String timeoutString=map.get("timeout");
  String charset=map.get("charset");
  boolean forceBinlog=false;
  int timeout=120;
  String schema="";
  if (table == null) {
    writeErrMessage(c,"table cannot be null");
    return;
  }
  if (table.contains(".")) {
    String[] split=table.split("\\.");
    schema=split[0];
    table=split[1];
  }
  if (add == null) {
    writeErrMessage(c,"add cannot be null");
    return;
  }
  if (timeoutString != null) {
    try {
      timeout=Integer.parseInt(timeoutString);
      if (timeout <= 0) {
        throw new NumberFormatException("");
      }
    }
 catch (    Exception e) {
      writeErrMessage(c,String.format("timeout:%s format is wrong,it should be 1-" + Integer.MAX_VALUE + " (unit:minute)",timeoutString));
      return;
    }
  }
  if (StringUtil.isEmpty(charset)) {
    charset=Charset.defaultCharset().name();
  }
  if (!Charset.isSupported(charset)) {
    writeErrMessage(c,"Not support charset " + charset);
    return;
  }
  ZkConfig zkConfig=ZkConfig.getInstance();
  boolean loadZk="true".equalsIgnoreCase(zkConfig.getValue(ZK_CFG_FLAG));
  boolean force="true".equalsIgnoreCase(map.get("force"));
  CuratorFramework zk=ZKUtils.getConnection();
  if (!loadZk) {
    if (!force) {
      String msg="";
      msg+="Mycat can temporarily execute the migration command.If other mycat does not connect to this zookeeper, they will not be able to perceive changes in the migration task.\n";
      msg+="You can command as follow:\n\nmigrate -table=schema.test -add=dn2,dn3 -force=true\n\nto perform the migration.\n";
      LOGGER.error(msg);
      writeErrMessage(c,msg);
      return;
    }
    boolean changed=false;
    if (!forceInit) {
synchronized (slaveIDsLock) {
        if (!forceInit) {
          forceInit=true;
          changed=true;
        }
      }
    }
    if (changed) {
      MigrateTaskWatch.start();
    }
  }
  if (zk == null) {
    writeErrMessage(c,"Mycat is not connected to zookeeper");
    return;
  }
  String taskID=getUUID();
  try {
    if (StringUtil.isEmpty(schema)) {
      schema=c.getSchema();
    }
    if (StringUtil.isEmpty(schema)) {
      writeErrMessage(c,"No database selected");
      return;
    }
    SchemaConfig schemaConfig=MycatServer.getInstance().getConfig().getSchemas().get(schema);
    if (schemaConfig == null) {
      writeErrMessage(c,String.format("Unknown database '" + schema + "'",table.toUpperCase(),schema));
      return;
    }
    TableConfig tableConfig=schemaConfig.getTables().get(table.toUpperCase());
    if (tableConfig == null) {
      writeErrMessage(c,String.format("Table '%s' doesn't define in schema '%s'\n",table.toUpperCase(),schema));
      return;
    }
    AbstractPartitionAlgorithm algorithm=tableConfig.getRule().getRuleAlgorithm();
    if (!(algorithm instanceof PartitionByCRC32PreSlot)) {
      writeErrMessage(c,"table: " + table + " rule is not be PartitionByCRC32PreSlot");
      return;
    }
    Map<Integer,List<Range>> integerListMap=((PartitionByCRC32PreSlot)algorithm).getRangeMap();
    integerListMap=(Map<Integer,List<Range>>)ObjectUtil.copyObject(integerListMap);
    ArrayList<String> oldDataNodes=tableConfig.getDataNodes();
    Map<String,PhysicalDBNode> allDataNodes=MycatServer.getInstance().getConfig().getDataNodes();
    List<String> newDataNodes=Splitter.on(",").omitEmptyStrings().trimResults().splitToList(add);
    for (    String newDataNode : newDataNodes) {
      if (tableConfig.getDataNodes().contains(newDataNode)) {
        writeErrMessage(c,"The dataNode " + newDataNode + " that needs to be added already exists\n");
        return;
      }
      if (!allDataNodes.containsKey(newDataNode)) {
        writeErrMessage(c,"The dataNode " + newDataNode + " does not exist\n");
        return;
      }
    }
    Map<String,List<MigrateTask>> tasks=MigrateUtils.balanceExpand(table,integerListMap,oldDataNodes,newDataNodes,PartitionByCRC32PreSlot.DEFAULT_SLOTS_NUM);
    CuratorTransactionFinal transactionFinal=null;
    String taskBase=ZKUtils.getZKBasePath() + "migrate/" + schema;
    String taskPath=taskBase + "/" + taskID;
    CuratorFramework client=ZKUtils.getConnection();
    if (client.checkExists().forPath(taskBase) != null) {
      List<String> childTaskList=client.getChildren().forPath(taskBase);
      for (      String child : childTaskList) {
        String path=taskBase + "/" + child;
        String str=new String(ZKUtils.getConnection().getData().forPath(path));
        if (!isJson(str)) {
          writeErrMessage(c,path + "in zookeeper is abnormal state,please repair manual!");
          return;
        }
        TaskNode taskNode=JSON.parseObject(str,TaskNode.class);
        if (taskNode.getSchema().equalsIgnoreCase(schema) && table.equalsIgnoreCase(taskNode.getTable()) && taskNode.getStatus() < 5) {
          writeErrMessage(c,"table: " + table + " previous migrate task is still running,on the same time one table only one task");
          return;
        }
      }
    }
    String backupPath=backup();
    client.create().creatingParentsIfNeeded().forPath(taskPath);
    TaskNode taskNode=new TaskNode();
    taskNode.setSchema(schema);
    taskNode.setSql(stmt);
    taskNode.setTable(table);
    taskNode.setAdd(add);
    taskNode.setStatus(0);
    taskNode.setTimeout(timeout);
    taskNode.setCharset(charset);
    taskNode.setForceBinlog(forceBinlog);
    taskNode.setBackupFile(backupPath);
    Map<String,Integer> fromNodeSlaveIdMap=new HashMap<>();
    List<MigrateTask> allTaskList=new ArrayList<>();
    for (    Map.Entry<String,List<MigrateTask>> entry : tasks.entrySet()) {
      String key=entry.getKey();
      List<MigrateTask> value=entry.getValue();
      for (      MigrateTask migrateTask : value) {
        migrateTask.setSchema(schema);
        String dataHost=getDataHostNameFromNode(migrateTask.getFrom());
        if (fromNodeSlaveIdMap.containsKey(dataHost)) {
          migrateTask.setSlaveId(fromNodeSlaveIdMap.get(dataHost));
        }
 else {
          migrateTask.setSlaveId(getSlaveIdFromZKForDataNode(migrateTask.getFrom()));
          fromNodeSlaveIdMap.put(dataHost,migrateTask.getSlaveId());
        }
      }
      allTaskList.addAll(value);
    }
    transactionFinal=client.inTransaction().setData().forPath(taskPath,JSON.toJSONBytes(taskNode)).and();
    Map<String,List<MigrateTask>> dataHostMigrateMap=mergerTaskForDataHost(allTaskList);
    String boosterDataHosts=ZkConfig.getInstance().getValue(ZkParamCfg.MYCAT_BOOSTER_DATAHOSTS);
    Set<String> dataNodes=new HashSet<>(Splitter.on(",").trimResults().omitEmptyStrings().splitToList(boosterDataHosts));
    boolean isFirst=true;
    for (    String s : dataHostMigrateMap.keySet()) {
      if (!dataNodes.contains(s)) {
        if (isFirst) {
          LOGGER.warn("--------------------------------check dataNode--------------------------------");
          isFirst=false;
        }
        LOGGER.warn("dataNode %s will be not participate in migration");
      }
    }
    for (    Map.Entry<String,List<MigrateTask>> entry : dataHostMigrateMap.entrySet()) {
      String key=entry.getKey();
      List<MigrateTask> value=entry.getValue();
      String path=taskPath + "/" + key;
      transactionFinal=transactionFinal.create().forPath(path,JSON.toJSONBytes(value)).and();
    }
    transactionFinal.commit();
  }
 catch (  Exception e) {
    LOGGER.error("migrate error",e);
    writeErrMessage(c,"migrate error:" + e);
    return;
  }
  writePackToClient(c,taskID);
  LOGGER.info("--------------------------------task created success--------------------------------");
  LOGGER.info("task start",new Date());
}
