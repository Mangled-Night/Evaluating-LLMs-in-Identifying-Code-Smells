public class SmackIntegrationTestFrameworkUnitTest {
  private static boolean beforeClassInvoked;
  private static boolean afterClassInvoked;
  @BeforeAll public static void prepareSinttestUnitTest(){
    SmackIntegrationTestFramework.SINTTEST_UNIT_TEST=true;
  }
  @AfterAll public static void disallowSinntestUnitTest(){
    SmackIntegrationTestFramework.SINTTEST_UNIT_TEST=false;
  }
  @Test public void throwsRuntimeExceptionsTest() throws KeyManagementException, NoSuchAlgorithmException, SmackException, IOException, XMPPException, InterruptedException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
    DummySmackIntegrationTestFramework sinttest=getFrameworkForUnitTest(ThrowsRuntimeExceptionDummyTest.class);
    assertThrows(RuntimeException.class,() -> {
      sinttest.run();
    }
);
  }
public static class ThrowsRuntimeExceptionDummyTest extends AbstractSmackIntegrationTest {
    public ThrowsRuntimeExceptionDummyTest(    SmackIntegrationTestEnvironment environment){
      super(environment);
    }
    public static final String RUNTIME_EXCEPTION_MESSAGE="Dummy RuntimeException";
    @SmackIntegrationTest public void throwRuntimeExceptionTest(){
      throw new RuntimeException(RUNTIME_EXCEPTION_MESSAGE);
    }
  }
  @Test public void logsNonFatalExceptionTest() throws KeyManagementException, NoSuchAlgorithmException, SmackException, IOException, XMPPException, InterruptedException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
    DummySmackIntegrationTestFramework sinttest=getFrameworkForUnitTest(ThrowsNonFatalExceptionDummyTest.class);
    TestRunResult testRunResult=sinttest.run();
    List<FailedTest> failedTests=testRunResult.getFailedTests();
    assertEquals(1,failedTests.size());
    FailedTest failedTest=failedTests.get(0);
    assertTrue(failedTest.failureReason instanceof XMPPErrorException);
    XMPPErrorException ex=(XMPPErrorException)failedTest.failureReason;
    assertEquals(StanzaError.Condition.bad_request,ex.getStanzaError().getCondition());
    assertEquals(ThrowsNonFatalExceptionDummyTest.DESCRIPTIVE_TEXT,ex.getStanzaError().getDescriptiveText());
  }
public static class ThrowsNonFatalExceptionDummyTest extends AbstractSmackIntegrationTest {
    public static final String DESCRIPTIVE_TEXT="I'm not fatal";
    public ThrowsNonFatalExceptionDummyTest(    SmackIntegrationTestEnvironment environment){
      super(environment);
    }
    @SmackIntegrationTest public void throwRuntimeExceptionTest() throws XMPPErrorException {
      Message message=StanzaBuilder.buildMessage().build();
      throw new XMPPException.XMPPErrorException(message,StanzaError.from(StanzaError.Condition.bad_request,DESCRIPTIVE_TEXT).build());
    }
  }
  @Test public void testInvoking() throws KeyManagementException, NoSuchAlgorithmException, SmackException, IOException, XMPPException, InterruptedException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {
    beforeClassInvoked=false;
    afterClassInvoked=false;
    DummySmackIntegrationTestFramework sinttest=getFrameworkForUnitTest(BeforeAfterClassTest.class);
    sinttest.run();
    assertTrue(beforeClassInvoked,"A before class method should have been executed to this time");
    assertTrue(afterClassInvoked,"A after class method should have been executed to this time");
  }
public static class BeforeAfterClassTest extends AbstractSmackIntegrationTest {
    public BeforeAfterClassTest(    SmackIntegrationTestEnvironment environment){
      super(environment);
    }
    @BeforeClass public void setUp(){
      beforeClassInvoked=true;
    }
    @AfterClass public void tearDown(){
      afterClassInvoked=true;
    }
    @SmackIntegrationTest public void test(){
      assertTrue(beforeClassInvoked,"A before class method should have been executed to this time");
      assertFalse(afterClassInvoked,"A after class method shouldn't have been executed to this time");
    }
  }
}
