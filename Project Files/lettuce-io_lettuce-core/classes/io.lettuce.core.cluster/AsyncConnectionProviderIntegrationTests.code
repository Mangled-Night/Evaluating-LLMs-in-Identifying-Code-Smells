/** 
 * @author Mark Paluch
 */
@ExtendWith(LettuceExtension.class) class AsyncConnectionProviderIntegrationTests {
  private final ClientResources resources;
  private RedisClusterClient client;
  private ServerSocket serverSocket;
  private CountDownLatch connectInitiated=new CountDownLatch(1);
  private AsyncConnectionProvider<ConnectionKey,StatefulRedisConnection<String,String>,ConnectionFuture<StatefulRedisConnection<String,String>>> sut;
  @Inject AsyncConnectionProviderIntegrationTests(  ClientResources resources){
    this.resources=resources;
  }
  @BeforeEach void before() throws Exception {
    serverSocket=new ServerSocket(9393,1);
    client=RedisClusterClient.create(resources,"redis://localhost");
    client.setOptions(ClusterClientOptions.builder().protocolVersion(ProtocolVersion.RESP2).build());
    sut=new AsyncConnectionProvider<>(new AbstractClusterNodeConnectionFactory<String,String>(resources){
      @Override public ConnectionFuture<StatefulRedisConnection<String,String>> apply(      ConnectionKey connectionKey){
        RedisURI redisURI=RedisURI.create(TestSettings.host(),serverSocket.getLocalPort());
        redisURI.setTimeout(Duration.ofSeconds(5));
        ConnectionFuture<StatefulRedisConnection<String,String>> future=client.connectToNodeAsync(StringCodec.UTF8,"",null,Mono.just(new InetSocketAddress(connectionKey.host,serverSocket.getLocalPort())));
        connectInitiated.countDown();
        return future;
      }
    }
);
  }
  @AfterEach void after() throws Exception {
    serverSocket.close();
  }
  @Test void shouldCloseConnectionByKey() throws IOException {
    ConnectionKey connectionKey=new ConnectionKey(ConnectionIntent.READ,TestSettings.host(),TestSettings.port());
    sut.getConnection(connectionKey);
    sut.close(connectionKey);
    assertThat(sut.getConnectionCount()).isEqualTo(0);
    sut.close();
    serverSocket.accept();
  }
  @Test void shouldCloseConnections() throws IOException {
    ConnectionKey connectionKey=new ConnectionKey(ConnectionIntent.READ,TestSettings.host(),TestSettings.port());
    sut.getConnection(connectionKey);
    TestFutures.awaitOrTimeout(sut.close());
    assertThat(sut.getConnectionCount()).isEqualTo(0);
    TestFutures.awaitOrTimeout(sut.close());
    serverSocket.accept();
  }
  @Test void connectShouldFail() throws Exception {
    Socket socket=new Socket(TestSettings.host(),serverSocket.getLocalPort());
    ClusterClientOptions clientOptions=ClusterClientOptions.builder().protocolVersion(ProtocolVersion.RESP2).socketOptions(SocketOptions.builder().connectTimeout(1,TimeUnit.SECONDS).build()).build();
    client.setOptions(clientOptions);
    ConnectionKey connectionKey=new ConnectionKey(ConnectionIntent.READ,"8.8.8.8",TestSettings.port());
    StopWatch stopWatch=new StopWatch();
    assertThatThrownBy(() -> TestFutures.awaitOrTimeout(sut.getConnection(connectionKey))).hasCauseInstanceOf(ConnectTimeoutException.class);
    stopWatch.start();
    assertThatThrownBy(() -> TestFutures.awaitOrTimeout(sut.getConnection(connectionKey))).hasCauseInstanceOf(ConnectTimeoutException.class);
    stopWatch.stop();
    assertThat(TimeUnit.NANOSECONDS.toMillis(stopWatch.getNanoTime())).isBetween(0L,1200L);
    sut.close();
    socket.close();
  }
  @Test void connectShouldFailConcurrently() throws Exception {
    Socket socket=new Socket(TestSettings.host(),serverSocket.getLocalPort());
    ClusterClientOptions clientOptions=ClusterClientOptions.builder().protocolVersion(ProtocolVersion.RESP2).socketOptions(SocketOptions.builder().connectTimeout(1,TimeUnit.SECONDS).build()).build();
    client.setOptions(clientOptions);
    ConnectionKey connectionKey=new ConnectionKey(ConnectionIntent.READ,"8.8.8.8",TestSettings.port());
    Thread t1=new Thread(() -> {
      try {
        sut.getConnection(connectionKey);
      }
 catch (      Exception e) {
      }
    }
);
    Thread t2=new Thread(() -> {
      try {
        sut.getConnection(connectionKey);
      }
 catch (      Exception e) {
      }
    }
);
    t1.start();
    t2.start();
    connectInitiated.await();
    StopWatch stopWatch=new StopWatch();
    stopWatch.start();
    t1.join(2000);
    t2.join(2000);
    stopWatch.stop();
    assertThat(TimeUnit.NANOSECONDS.toMillis(stopWatch.getNanoTime())).isBetween(0L,1300L);
    sut.close();
    socket.close();
  }
}
