/** 
 * Like mergeLo, except that this method should be called only if len1 >= len2; mergeLo should be called if len1 <= len2.  (Either method may be called if len1 == len2.)
 * @param base1 index of first element in first run to be merged
 * @param len1  length of first run to be merged (must be > 0)
 * @param base2 index of first element in second run to be merged(must be aBase + aLen)
 * @param len2  length of second run to be merged (must be > 0)
 */
private void mergeHi(int base1,int len1,int base2,int len2){
  assert len1 > 0 && len2 > 0 && base1 + len1 == base2;
  Buffer a=this.a;
  Buffer tmp=ensureCapacity(len2);
  s.copyRange(a,base2,tmp,0,len2);
  int cursor1=base1 + len1 - 1;
  int cursor2=len2 - 1;
  int dest=base2 + len2 - 1;
  K key0=s.newKey();
  K key1=s.newKey();
  s.copyElement(a,cursor1--,a,dest--);
  if (--len1 == 0) {
    s.copyRange(tmp,0,a,dest - (len2 - 1),len2);
    return;
  }
  if (len2 == 1) {
    dest-=len1;
    cursor1-=len1;
    s.copyRange(a,cursor1 + 1,a,dest + 1,len1);
    s.copyElement(tmp,cursor2,a,dest);
    return;
  }
  Comparator<? super K> c=this.c;
  int minGallop=this.minGallop;
  outer:   while (true) {
    int count1=0;
    int count2=0;
    do {
      assert len1 > 0 && len2 > 1;
      if (c.compare(s.getKey(tmp,cursor2,key0),s.getKey(a,cursor1,key1)) < 0) {
        s.copyElement(a,cursor1--,a,dest--);
        count1++;
        count2=0;
        if (--len1 == 0)         break outer;
      }
 else {
        s.copyElement(tmp,cursor2--,a,dest--);
        count2++;
        count1=0;
        if (--len2 == 1)         break outer;
      }
    }
 while ((count1 | count2) < minGallop);
    do {
      assert len1 > 0 && len2 > 1;
      count1=len1 - gallopRight(s.getKey(tmp,cursor2,key0),a,base1,len1,len1 - 1,c);
      if (count1 != 0) {
        dest-=count1;
        cursor1-=count1;
        len1-=count1;
        s.copyRange(a,cursor1 + 1,a,dest + 1,count1);
        if (len1 == 0)         break outer;
      }
      s.copyElement(tmp,cursor2--,a,dest--);
      if (--len2 == 1)       break outer;
      count2=len2 - gallopLeft(s.getKey(a,cursor1,key0),tmp,0,len2,len2 - 1,c);
      if (count2 != 0) {
        dest-=count2;
        cursor2-=count2;
        len2-=count2;
        s.copyRange(tmp,cursor2 + 1,a,dest + 1,count2);
        if (len2 <= 1)         break outer;
      }
      s.copyElement(a,cursor1--,a,dest--);
      if (--len1 == 0)       break outer;
      minGallop--;
    }
 while (count1 >= MIN_GALLOP | count2 >= MIN_GALLOP);
    if (minGallop < 0)     minGallop=0;
    minGallop+=2;
  }
  this.minGallop=minGallop < 1 ? 1 : minGallop;
  if (len2 == 1) {
    assert len1 > 0;
    dest-=len1;
    cursor1-=len1;
    s.copyRange(a,cursor1 + 1,a,dest + 1,len1);
    s.copyElement(tmp,cursor2,a,dest);
  }
 else   if (len2 == 0) {
    throw new IllegalArgumentException("Comparison method violates its general contract!");
  }
 else {
    assert len1 == 0;
    assert len2 > 0;
    s.copyRange(tmp,0,a,dest - (len2 - 1),len2);
  }
}
