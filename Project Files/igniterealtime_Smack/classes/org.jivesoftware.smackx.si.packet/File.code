/** 
 * <ul> <li>size: The size, in bytes, of the data to be sent.</li> <li>name: The name of the file that the Sender wishes to send.</li> <li>date: The last modification time of the file. This is specified using the DateTime profile as described in Jabber Date and Time Profiles.</li> <li>hash: The MD5 sum of the file contents.</li> </ul> <p> &lt;desc&gt; is used to provide a sender-generated description of the file so the receiver can better understand what is being sent. It MUST NOT be sent in the result. </p> <p> When &lt;range&gt; is sent in the offer, it should have no attributes. This signifies that the sender can do ranged transfers. When a Stream Initiation result is sent with the &lt;range&gt; element, it uses these attributes: </p> <ul> <li>offset: Specifies the position, in bytes, to start transferring the file data from. This defaults to zero (0) if not specified.</li> <li>length - Specifies the number of bytes to retrieve starting at offset. This defaults to the length of the file from offset to the end.</li> </ul> Both attributes are OPTIONAL on the &lt;range&gt; element. Sending no attributes is synonymous with not sending the &lt;range&gt; element. When no &lt;range&gt; element is sent in the Stream Initiation result, the Sender MUST send the complete file starting at offset 0. More generally, data is sent over the stream byte for byte starting at the offset position for the length specified.
 * @author Alexander Wenckus
 */
public static class File implements ExtensionElement {
  public static final String ELEMENT="file";
  public static final String NAMESPACE="http://jabber.org/protocol/si/profile/file-transfer";
  public static final QName QNAME=new QName(NAMESPACE,ELEMENT);
  private final String name;
  private final long size;
  private String hash;
  private Date date;
  private String desc;
  private boolean isRanged;
  /** 
 * Constructor providing the name of the file and its size.
 * @param name The name of the file.
 * @param size The size of the file in bytes.
 */
  public File(  final String name,  final long size){
    if (name == null) {
      throw new NullPointerException("name cannot be null");
    }
    this.name=name;
    this.size=size;
  }
  /** 
 * Returns the file's name.
 * @return Returns the file's name.
 */
  public String getName(){
    return name;
  }
  /** 
 * Returns the file's size.
 * @return Returns the file's size.
 */
  public long getSize(){
    return size;
  }
  /** 
 * Sets the MD5 sum of the file's contents.
 * @param hash The MD5 sum of the file's contents.
 */
  public void setHash(  final String hash){
    this.hash=hash;
  }
  /** 
 * Returns the MD5 sum of the file's contents.
 * @return Returns the MD5 sum of the file's contents
 */
  public String getHash(){
    return hash;
  }
  /** 
 * Sets the date that the file was last modified.
 * @param date The date that the file was last modified.
 */
  public void setDate(  Date date){
    this.date=date;
  }
  /** 
 * Returns the date that the file was last modified.
 * @return Returns the date that the file was last modified.
 */
  public Date getDate(){
    return date;
  }
  /** 
 * Sets the description of the file.
 * @param desc The description of the file so that the file receiver canknow what file it is.
 */
  public void setDesc(  final String desc){
    this.desc=desc;
  }
  /** 
 * Returns the description of the file.
 * @return Returns the description of the file.
 */
  public String getDesc(){
    return desc;
  }
  /** 
 * True if a range can be provided and false if it cannot.
 * @param isRanged True if a range can be provided and false if it cannot.
 */
  public void setRanged(  final boolean isRanged){
    this.isRanged=isRanged;
  }
  /** 
 * Returns whether or not the initiator can support a range for the file transfer.
 * @return Returns whether or not the initiator can support a range forthe file transfer.
 */
  public boolean isRanged(){
    return isRanged;
  }
  @Override public String getElementName(){
    return QNAME.getLocalPart();
  }
  @Override public String getNamespace(){
    return QNAME.getNamespaceURI();
  }
  @Override public String toXML(  org.jivesoftware.smack.packet.XmlEnvironment enclosingNamespace){
    StringBuilder buffer=new StringBuilder();
    buffer.append('<').append(getElementName()).append(" xmlns=\"").append(getNamespace()).append("\" ");
    if (getName() != null) {
      buffer.append("name=\"").append(StringUtils.escapeForXmlAttribute(getName())).append("\" ");
    }
    if (getSize() > 0) {
      buffer.append("size=\"").append(getSize()).append("\" ");
    }
    if (getDate() != null) {
      buffer.append("date=\"").append(XmppDateTime.formatXEP0082Date(date)).append("\" ");
    }
    if (getHash() != null) {
      buffer.append("hash=\"").append(getHash()).append("\" ");
    }
    if ((desc != null && desc.length() > 0) || isRanged) {
      buffer.append('>');
      if (getDesc() != null && desc.length() > 0) {
        buffer.append("<desc>").append(StringUtils.escapeForXmlText(getDesc())).append("</desc>");
      }
      if (isRanged()) {
        buffer.append("<range/>");
      }
      buffer.append("</").append(getElementName()).append('>');
    }
 else {
      buffer.append("/>");
    }
    return buffer.toString();
  }
}
