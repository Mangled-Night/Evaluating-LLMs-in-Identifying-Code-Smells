public class BlockMeshGeneratorSingleShape extends BlockMeshShapeGenerator {
  private final Block block;
  private final ResourceUrn baseUrn=new ResourceUrn("engine","blockmesh");
  public BlockMeshGeneratorSingleShape(  Block block){
    this.block=block;
  }
  @Override public Block getBlock(){
    return block;
  }
  @Override public ResourceUrn getBaseUrn(){
    return this.baseUrn;
  }
  @Override public void generateChunkMesh(  ChunkView view,  ChunkMesh chunkMesh,  int x,  int y,  int z){
    final BlockAppearance blockAppearance=block.getPrimaryAppearance();
    if (!blockAppearance.hasAppearance()) {
      return;
    }
    Color colorCache=new Color();
    Block[] adjacentBlocks=new Block[Side.allSides().size()];
    for (    Side side : Side.allSides()) {
      Vector3ic offset=side.direction();
      Block blockToCheck=view.getBlock(x + offset.x(),y + offset.y(),z + offset.z());
      adjacentBlocks[side.ordinal()]=blockToCheck;
    }
    final ChunkMesh.RenderType renderType=getRenderType(block);
    final ChunkVertexFlag vertexFlag=getChunkVertexFlag(view,x,y,z,block);
    boolean isRendered=false;
    for (    final Side side : Side.allSides()) {
      if (isSideVisibleForBlockTypes(adjacentBlocks[side.ordinal()],block,side)) {
        isRendered=true;
        BlockMeshPart blockMeshPart=blockAppearance.getPart(BlockPart.fromSide(side));
        if (block.isLiquid()) {
          final Block topBlock=adjacentBlocks[Side.TOP.ordinal()];
          if (topBlock.isLiquid() && Side.horizontalSides().contains(side)) {
            final Vector3ic offset=side.direction();
            final Block adjacentAbove=view.getBlock(x + offset.x(),y + 1,z + offset.z());
            final Block adjacent=adjacentBlocks[side.ordinal()];
            if (adjacent.isLiquid() && !adjacentAbove.isLiquid()) {
              blockMeshPart=block.getTopLiquidMesh(side);
            }
          }
 else {
            if (blockMeshPart != null) {
              blockMeshPart=block.getLowLiquidMesh(side);
            }
          }
        }
        if (blockMeshPart != null) {
          ChunkVertexFlag sideVertexFlag=vertexFlag;
          if (block.isGrass() && side != Side.TOP && side != Side.BOTTOM) {
            sideVertexFlag=ChunkVertexFlag.COLOR_MASK;
          }
          Colorc colorOffset=block.getColorOffset(BlockPart.fromSide(side));
          Colorc colorSource=block.getColorSource(BlockPart.fromSide(side)).calcColor(view,x,y,z);
          colorCache.setRed(colorSource.rf() * colorOffset.rf()).setGreen(colorSource.gf() * colorOffset.gf()).setBlue(colorSource.bf() * colorOffset.bf()).setAlpha(colorSource.af() * colorOffset.af());
          blockMeshPart.appendTo(chunkMesh,view,x,y,z,renderType,colorCache,sideVertexFlag);
        }
      }
    }
    if (isRendered && blockAppearance.getPart(BlockPart.CENTER) != null) {
      Colorc colorOffset=block.getColorOffset(BlockPart.CENTER);
      Colorc colorSource=block.getColorSource(BlockPart.CENTER).calcColor(view,x,y,z);
      colorCache.setRed(colorSource.rf() * colorOffset.rf()).setGreen(colorSource.gf() * colorOffset.gf()).setBlue(colorSource.bf() * colorOffset.bf()).setAlpha(colorSource.af() * colorOffset.af());
      blockAppearance.getPart(BlockPart.CENTER).appendTo(chunkMesh,view,x,y,z,renderType,colorCache,vertexFlag);
    }
  }
  private ChunkVertexFlag getChunkVertexFlag(  ChunkView view,  int x,  int y,  int z,  Block selfBlock){
    ChunkVertexFlag vertexFlag=ChunkVertexFlag.NORMAL;
    if (selfBlock.isWater()) {
      if (view.getBlock(x,y + 1,z).isWater()) {
        vertexFlag=ChunkVertexFlag.WATER;
      }
 else {
        vertexFlag=ChunkVertexFlag.WATER_SURFACE;
      }
    }
 else     if (selfBlock.isWaving() && selfBlock.isDoubleSided()) {
      vertexFlag=ChunkVertexFlag.WAVING;
    }
 else     if (selfBlock.isWaving()) {
      vertexFlag=ChunkVertexFlag.WAVING_BLOCK;
    }
    return vertexFlag;
  }
  /** 
 * Determine the render process of the block.
 * @return The render process for the block
 */
  private ChunkMesh.RenderType getRenderType(  final Block selfBlock){
    ChunkMesh.RenderType renderType=ChunkMesh.RenderType.TRANSLUCENT;
    if (!selfBlock.isTranslucent()) {
      renderType=ChunkMesh.RenderType.OPAQUE;
    }
    if (selfBlock.isWater() || selfBlock.isIce()) {
      renderType=ChunkMesh.RenderType.WATER_AND_ICE;
    }
    if (selfBlock.isDoubleSided()) {
      renderType=ChunkMesh.RenderType.BILLBOARD;
    }
    return renderType;
  }
  /** 
 * Returns true if the side should be rendered adjacent to the second side provided.
 * @param blockToCheck The block to check
 * @param currentBlock The current block
 * @return True if the side is visible for the given block types
 */
  private boolean isSideVisibleForBlockTypes(  Block blockToCheck,  Block currentBlock,  Side side){
    if (currentBlock.isLiquid() && blockToCheck.isLiquid()) {
      return false;
    }
    if (currentBlock.isWater() && (side == Side.TOP) && !blockToCheck.isWater()) {
      return true;
    }
    if (blockToCheck.getURI().equals(BlockManager.UNLOADED_ID)) {
      return false;
    }
    return currentBlock.isWaving() != blockToCheck.isWaving() || blockToCheck.getMeshGenerator() == null || !blockToCheck.isFullSide(side.reverse()) || (!currentBlock.isTranslucent() && blockToCheck.isTranslucent());
  }
}
