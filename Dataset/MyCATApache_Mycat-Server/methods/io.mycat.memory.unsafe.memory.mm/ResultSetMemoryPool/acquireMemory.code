/** 
 * Try to acquire up to `numBytes` of memory for the given task and return the number of bytes obtained, or 0 if none can be allocated. This call may block until there is enough free memory in some situations, to make sure each task has a chance to ramp up to at least 1 / 8N of the total memory pool (where N is the # of active tasks) before it is forced to spill. This can happen if the number of tasks increase but an older task had a lot of memory already.
 * @param numBytes number of bytes to acquire
 * @param connAttemptId the task attempt acquiring memory
 * @return the number of bytes granted to the task.
 */
public long acquireMemory(long numBytes,long connAttemptId) throws InterruptedException {
synchronized (lock) {
    assert (numBytes > 0);
    if (!memoryForConnection.containsKey(connAttemptId)) {
      memoryForConnection.put(connAttemptId,0L);
      lock.notifyAll();
    }
    while (true) {
      long numActiveConns=memoryForConnection.size();
      long curMem=memoryForConnection.get(connAttemptId);
      long maxPoolSize=poolSize();
      long maxMemoryPerTask=maxPoolSize / numActiveConns;
      long minMemoryPerTask=poolSize() / (8 * numActiveConns);
      long maxToGrant=Math.min(numBytes,Math.max(0,maxMemoryPerTask - curMem));
      long toGrant=Math.min(maxToGrant,memoryFree());
      if (toGrant < numBytes && curMem + toGrant < minMemoryPerTask) {
        LOG.info("Thread " + connAttemptId + " waiting for at least 1/8N of "+ poolName()+ " pool to be free");
        lock.wait();
      }
 else {
        long temp=memoryForConnection.get(connAttemptId);
        memoryForConnection.put(connAttemptId,(temp + toGrant));
        return toGrant;
      }
    }
  }
}
