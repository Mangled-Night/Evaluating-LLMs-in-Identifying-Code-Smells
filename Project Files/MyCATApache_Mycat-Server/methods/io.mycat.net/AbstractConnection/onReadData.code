/** 
 * 读取可能的Socket字节流
 */
public void onReadData(int got) throws IOException {
  if (isClosed.get()) {
    return;
  }
  lastReadTime=TimeUtil.currentTimeMillis();
  if (got < 0) {
    this.close("stream closed");
    return;
  }
 else   if (got == 0 && !this.channel.isOpen()) {
    this.close("socket closed");
    return;
  }
  netInBytes+=got;
  processor.addNetInBytes(got);
  int offset=readBufferOffset, length=0, position=readBuffer.position();
  for (; ; ) {
    length=getPacketLength(readBuffer,offset);
    if (length == -1) {
      if (offset != 0) {
        this.readBuffer=compactReadBuffer(readBuffer,offset);
      }
 else       if (readBuffer != null && !readBuffer.hasRemaining()) {
        throw new RuntimeException("invalid readbuffer capacity ,too little buffer size " + readBuffer.capacity());
      }
      break;
    }
    if (position >= offset + length && readBuffer != null) {
      readBuffer.position(offset);
      byte[] data=new byte[length];
      readBuffer.get(data,0,length);
      handle(data);
      if (isClosed()) {
        return;
      }
      offset+=length;
      if (position == offset) {
        if (readBuffer != null && !readBuffer.isDirect() && lastLargeMessageTime < lastReadTime - 30 * 1000L) {
          if (LOGGER.isDebugEnabled()) {
            LOGGER.debug("change to direct con read buffer ,cur temp buf size :" + readBuffer.capacity());
          }
          recycle(readBuffer);
          readBuffer=processor.getBufferPool().allocate(processor.getBufferPool().getConReadBuferChunk());
        }
 else {
          if (readBuffer != null) {
            readBuffer.clear();
          }
        }
        readBufferOffset=0;
        break;
      }
 else {
        readBufferOffset=offset;
        if (readBuffer != null) {
          readBuffer.position(position);
        }
        continue;
      }
    }
 else {
      if (!readBuffer.hasRemaining()) {
        readBuffer=ensureFreeSpaceOfReadBuffer(readBuffer,offset,length);
      }
      break;
    }
  }
}
