/** 
 * Filters for packets which are a valid reply to an IQ request. <p> Such a stanza must have the same stanza id and must be an IQ stanza of type <code>RESULT</code> or <code>ERROR</code>. Moreover, it is necessary to check the <code>from</code> address to ignore forged replies. <p> We accept a <code>from</code> address if one of the following is true: <ul> <li>It matches the <code>to</code> address of the request. <li>The <code>to</code> address of the request was empty and the <code>from</code> address matches either the bare jid of the server or the (bare or full jid) of the client. <li>To <code>to</code> was our bare address and the <code>from</code> is empty. </ul> <p> For a discussion of the issues, see the thread "Spoofing of iq ids and misbehaving servers" from 2014-01 on the jdev@jabber.org mailing list and following discussion in February and March.
 * @param iqPacket An IQ request. Filter for replies to this packet.
 * @param conn connection.
 */
public IQReplyFilter(IQ iqPacket,XMPPConnection conn){
  if (!iqPacket.isRequestIQ()) {
    throw new IllegalArgumentException("IQ must be a request IQ, i.e. of type 'get' or 'set'.");
  }
  to=iqPacket.getTo();
  local=conn.getUser();
  if (local == null) {
    throw new IllegalArgumentException("Must have a local (user) JID set. Either you didn't configure one or you where not connected at least once");
  }
  server=conn.getXMPPServiceDomain();
  packetId=iqPacket.getStanzaId();
  StanzaFilter iqFilter=new OrFilter(IQTypeFilter.ERROR,IQTypeFilter.RESULT);
  StanzaFilter idFilter=new StanzaIdFilter(iqPacket);
  iqAndIdFilter=new AndFilter(iqFilter,idFilter);
  fromFilter=new OrFilter();
  fromFilter.addFilter(FromMatchesFilter.createFull(to));
  if (to == null) {
    fromFilter.addFilter(FromMatchesFilter.createBare(local));
    fromFilter.addFilter(FromMatchesFilter.createFull(server));
  }
 else   if (to.equals(local.asBareJid())) {
    fromFilter.addFilter(FromMatchesFilter.createFull(null));
  }
}
