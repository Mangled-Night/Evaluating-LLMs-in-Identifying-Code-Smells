private ChatMarkersManager(XMPPConnection connection){
  super(connection);
  chatManager=ChatManager.getInstanceFor(connection);
  connection.addMessageInterceptor(mb -> mb.addExtension(ChatMarkersElements.MarkableExtension.INSTANCE),m -> {
    return OUTGOING_MESSAGE_FILTER.accept(m);
  }
);
  connection.addSyncStanzaListener(new StanzaListener(){
    @Override public void processStanza(    Stanza packet) throws NotConnectedException, InterruptedException, SmackException.NotLoggedInException {
      final Message message=(Message)packet;
      EntityBareJid bareFrom=message.getFrom().asEntityBareJidOrThrow();
      final Chat chat=chatManager.chatWith(bareFrom);
      asyncButOrdered.performAsyncButOrdered(chat,new Runnable(){
        @Override public void run(){
          for (          ChatMarkersListener listener : incomingListeners) {
            if (ChatMarkersElements.MarkableExtension.from(message) != null) {
              listener.newChatMarkerMessage(ChatMarkersState.markable,message,chat);
            }
 else             if (ChatMarkersElements.ReceivedExtension.from(message) != null) {
              listener.newChatMarkerMessage(ChatMarkersState.received,message,chat);
            }
 else             if (ChatMarkersElements.DisplayedExtension.from(message) != null) {
              listener.newChatMarkerMessage(ChatMarkersState.displayed,message,chat);
            }
 else             if (ChatMarkersElements.AcknowledgedExtension.from(message) != null) {
              listener.newChatMarkerMessage(ChatMarkersState.acknowledged,message,chat);
            }
          }
        }
      }
);
    }
  }
,INCOMING_MESSAGE_FILTER);
  serviceDiscoveryManager=ServiceDiscoveryManager.getInstanceFor(connection);
}
