public final class ModularXmppClientToServerConnection extends AbstractXMPPConnection {
  private static final Logger LOGGER=Logger.getLogger(ModularXmppClientToServerConnectionConfiguration.class.getName());
  private final ArrayBlockingQueueWithShutdown<TopLevelStreamElement> outgoingElementsQueue=new ArrayBlockingQueueWithShutdown<>(100,true);
  private XmppClientToServerTransport activeTransport;
  private final List<ConnectionStateMachineListener> connectionStateMachineListeners=new CopyOnWriteArrayList<>();
  private boolean featuresReceived;
  private boolean streamResumed;
  private GraphVertex<State> currentStateVertex;
  private List<State> walkFromDisconnectToAuthenticated;
  private final ModularXmppClientToServerConnectionConfiguration configuration;
  private final ModularXmppClientToServerConnectionInternal connectionInternal;
  private final Map<Class<? extends ModularXmppClientToServerConnectionModuleDescriptor>,ModularXmppClientToServerConnectionModule<? extends ModularXmppClientToServerConnectionModuleDescriptor>> connectionModules=new HashMap<>();
  private final Map<Class<? extends ModularXmppClientToServerConnectionModuleDescriptor>,XmppClientToServerTransport> transports=new HashMap<>();
  /** 
 * This is one of those cases where the field is modified by one thread and read by another. We currently use CopyOnWriteArrayList but should potentially use a VarHandle once Smack supports them.
 */
  private final List<XmppInputOutputFilter> inputOutputFilters=new CopyOnWriteArrayList<>();
  private List<XmppInputOutputFilter> previousInputOutputFilters;
  public ModularXmppClientToServerConnection(  ModularXmppClientToServerConnectionConfiguration configuration){
    super(configuration);
    this.configuration=configuration;
    connectionInternal=new ModularXmppClientToServerConnectionInternal(this,getReactor(),debugger,outgoingElementsQueue){
      @Override public void parseAndProcessElement(      String wrappedCompleteElement){
        ModularXmppClientToServerConnection.this.parseAndProcessElement(wrappedCompleteElement);
      }
      @Override public void notifyConnectionError(      Exception e){
        ModularXmppClientToServerConnection.this.notifyConnectionError(e);
      }
      @Override public String onStreamOpen(      XmlPullParser parser){
        return ModularXmppClientToServerConnection.this.onStreamOpen(parser);
      }
      @Override public void onStreamClosed(){
        ModularXmppClientToServerConnection.this.closingStreamReceived=true;
        notifyWaitingThreads();
      }
      @Override public void fireFirstLevelElementSendListeners(      TopLevelStreamElement element){
        ModularXmppClientToServerConnection.this.firePacketSendingListeners(element);
      }
      @Override public void invokeConnectionStateMachineListener(      ConnectionStateEvent connectionStateEvent){
        ModularXmppClientToServerConnection.this.invokeConnectionStateMachineListener(connectionStateEvent);
      }
      @Override public XmlEnvironment getOutgoingStreamXmlEnvironment(){
        return outgoingStreamXmlEnvironment;
      }
      @Override public void addXmppInputOutputFilter(      XmppInputOutputFilter xmppInputOutputFilter){
        inputOutputFilters.add(0,xmppInputOutputFilter);
      }
      @Override public ListIterator<XmppInputOutputFilter> getXmppInputOutputFilterBeginIterator(){
        return inputOutputFilters.listIterator();
      }
      @Override public ListIterator<XmppInputOutputFilter> getXmppInputOutputFilterEndIterator(){
        return inputOutputFilters.listIterator(inputOutputFilters.size());
      }
      @Override public void waitForFeaturesReceived(      String waitFor) throws InterruptedException, SmackException, XMPPException {
        ModularXmppClientToServerConnection.this.waitForFeaturesReceived(waitFor);
      }
      @Override public void newStreamOpenWaitForFeaturesSequence(      String waitFor) throws InterruptedException, SmackException, XMPPException {
        ModularXmppClientToServerConnection.this.newStreamOpenWaitForFeaturesSequence(waitFor);
      }
      @Override public SmackTlsContext getSmackTlsContext(){
        return ModularXmppClientToServerConnection.this.getSmackTlsContext();
      }
      @Override public <SN extends Nonza,FN extends Nonza>SN sendAndWaitForResponse(      Nonza nonza,      Class<SN> successNonzaClass,      Class<FN> failedNonzaClass) throws NoResponseException, NotConnectedException, FailedNonzaException, InterruptedException {
        return ModularXmppClientToServerConnection.this.sendAndWaitForResponse(nonza,successNonzaClass,failedNonzaClass);
      }
      @Override public void asyncGo(      Runnable runnable){
        AbstractXMPPConnection.asyncGo(runnable);
      }
      @Override public void waitForConditionOrThrowConnectionException(      Supplier<Boolean> condition,      String waitFor) throws InterruptedException, SmackException, XMPPException {
        ModularXmppClientToServerConnection.this.waitForConditionOrThrowConnectionException(condition,waitFor);
      }
      @Override public void notifyWaitingThreads(){
        ModularXmppClientToServerConnection.this.notifyWaitingThreads();
      }
      @Override public void setCompressionEnabled(      boolean compressionEnabled){
        ModularXmppClientToServerConnection.this.compressionEnabled=compressionEnabled;
      }
      @Override public void setTransport(      XmppClientToServerTransport xmppTransport){
        ModularXmppClientToServerConnection.this.activeTransport=xmppTransport;
        ModularXmppClientToServerConnection.this.connected=true;
      }
    }
;
    for (    ModularXmppClientToServerConnectionModuleDescriptor moduleDescriptor : configuration.moduleDescriptors) {
      Class<? extends ModularXmppClientToServerConnectionModuleDescriptor> moduleDescriptorClass=moduleDescriptor.getClass();
      ModularXmppClientToServerConnectionModule<? extends ModularXmppClientToServerConnectionModuleDescriptor> connectionModule=moduleDescriptor.constructXmppConnectionModule(connectionInternal);
      connectionModules.put(moduleDescriptorClass,connectionModule);
      XmppClientToServerTransport transport=connectionModule.getTransport();
      if (transport != null) {
        transports.put(moduleDescriptorClass,transport);
      }
    }
    GraphVertex<StateDescriptor> initialStateDescriptorVertex=configuration.initialStateDescriptorVertex;
    currentStateVertex=StateDescriptorGraph.convertToStateGraph(initialStateDescriptorVertex,connectionInternal);
  }
  @SuppressWarnings("unchecked") public <CM extends ModularXmppClientToServerConnectionModule<? extends ModularXmppClientToServerConnectionModuleDescriptor>>CM getConnectionModuleFor(  Class<? extends ModularXmppClientToServerConnectionModuleDescriptor> descriptorClass){
    return (CM)connectionModules.get(descriptorClass);
  }
  @Override protected void loginInternal(  String username,  String password,  Resourcepart resource) throws XMPPException, SmackException, IOException, InterruptedException {
    WalkStateGraphContext walkStateGraphContext=buildNewWalkTo(AuthenticatedAndResourceBoundStateDescriptor.class).withLoginContext(username,password,resource).build();
    walkStateGraph(walkStateGraphContext);
  }
  private WalkStateGraphContext.Builder buildNewWalkTo(  Class<? extends StateDescriptor> finalStateClass){
    return WalkStateGraphContext.builder(currentStateVertex.getElement().getStateDescriptor().getClass(),finalStateClass);
  }
  /** 
 * Unwind the state. This will revert the effects of the state by calling  {@link State#resetState()} prior issuing aconnection state event of  {@link ConnectionStateEvent#StateRevertBackwardsWalk}.
 * @param revertedState the state which is going to get reverted.
 */
  private void unwindState(  State revertedState){
    invokeConnectionStateMachineListener(new ConnectionStateEvent.StateRevertBackwardsWalk(revertedState));
    revertedState.resetState();
  }
  private void walkStateGraph(  WalkStateGraphContext walkStateGraphContext) throws XMPPException, IOException, SmackException, InterruptedException {
    GraphVertex<State> previousStateVertex=currentStateVertex;
    try {
      walkStateGraphInternal(walkStateGraphContext);
    }
 catch (    IOException|SmackException|InterruptedException|XMPPException e) {
      currentStateVertex=previousStateVertex;
      State revertedState=currentStateVertex.getElement();
      unwindState(revertedState);
      throw e;
    }
  }
  private void walkStateGraphInternal(  WalkStateGraphContext walkStateGraphContext) throws IOException, SmackException, InterruptedException, XMPPException {
    final GraphVertex<State> initialStateVertex=currentStateVertex;
    final State initialState=initialStateVertex.getElement();
    final StateDescriptor initialStateDescriptor=initialState.getStateDescriptor();
    walkStateGraphContext.recordWalkTo(initialState);
    if (walkStateGraphContext.isWalksFinalState(initialStateDescriptor)) {
      assert initialStateDescriptor.isFinalState();
      invokeConnectionStateMachineListener(new ConnectionStateEvent.FinalStateReached(initialState));
      return;
    }
    List<GraphVertex<State>> outgoingStateEdges=initialStateVertex.getOutgoingEdges();
    GraphVertex<State> mandatoryIntermediateStateVertex=walkStateGraphContext.maybeReturnMandatoryImmediateState(outgoingStateEdges);
    if (mandatoryIntermediateStateVertex != null) {
      StateTransitionResult reason=attemptEnterState(mandatoryIntermediateStateVertex,walkStateGraphContext);
      if (reason instanceof StateTransitionResult.Success) {
        walkStateGraph(walkStateGraphContext);
        return;
      }
      throw new StateMachineException.SmackMandatoryStateFailedException(mandatoryIntermediateStateVertex.getElement(),reason);
    }
    for (Iterator<GraphVertex<State>> it=outgoingStateEdges.iterator(); it.hasNext(); ) {
      GraphVertex<State> successorStateVertex=it.next();
      State successorState=successorStateVertex.getElement();
      if (walkStateGraphContext.wouldCauseCycle(successorStateVertex)) {
        invokeConnectionStateMachineListener(new ConnectionStateEvent.TransitionIgnoredDueCycle(initialStateVertex,successorStateVertex));
      }
 else {
        StateTransitionResult result=attemptEnterState(successorStateVertex,walkStateGraphContext);
        if (result instanceof StateTransitionResult.Success) {
          break;
        }
        if (result != null) {
          walkStateGraphContext.recordFailedState(successorState,result);
        }
      }
      if (!it.hasNext()) {
        throw StateMachineException.SmackStateGraphDeadEndException.from(walkStateGraphContext,initialStateVertex);
      }
    }
    walkStateGraph(walkStateGraphContext);
  }
  /** 
 * Attempt to enter a state. Note that this method may return <code>null</code> if this state can be safely ignored.
 * @param successorStateVertex the successor state vertex.
 * @param walkStateGraphContext the "walk state graph" context.
 * @return A state transition result or <code>null</code> if this state can be ignored.
 * @throws SmackException if Smack detected an exceptional situation.
 * @throws XMPPException if an XMPP protocol error was received.
 * @throws IOException if an I/O error occurred.
 * @throws InterruptedException if the calling thread was interrupted.
 */
  private StateTransitionResult attemptEnterState(  GraphVertex<State> successorStateVertex,  WalkStateGraphContext walkStateGraphContext) throws SmackException, XMPPException, IOException, InterruptedException {
    final GraphVertex<State> initialStateVertex=currentStateVertex;
    final State initialState=initialStateVertex.getElement();
    final State successorState=successorStateVertex.getElement();
    final StateDescriptor successorStateDescriptor=successorState.getStateDescriptor();
    if (!successorStateDescriptor.isMultiVisitState() && walkStateGraphContext.stateAlreadyVisited(successorState)) {
      return null;
    }
    if (successorStateDescriptor.isNotImplemented()) {
      StateTransitionResult.TransitionImpossibleBecauseNotImplemented transtionImpossibleBecauseNotImplemented=new StateTransitionResult.TransitionImpossibleBecauseNotImplemented(successorStateDescriptor);
      invokeConnectionStateMachineListener(new ConnectionStateEvent.TransitionNotPossible(initialState,successorState,transtionImpossibleBecauseNotImplemented));
      return transtionImpossibleBecauseNotImplemented;
    }
    final StateTransitionResult.AttemptResult transitionAttemptResult;
    try {
      StateTransitionResult.TransitionImpossible transitionImpossible=successorState.isTransitionToPossible(walkStateGraphContext);
      if (transitionImpossible != null) {
        invokeConnectionStateMachineListener(new ConnectionStateEvent.TransitionNotPossible(initialState,successorState,transitionImpossible));
        return transitionImpossible;
      }
      invokeConnectionStateMachineListener(new ConnectionStateEvent.AboutToTransitionInto(initialState,successorState));
      transitionAttemptResult=successorState.transitionInto(walkStateGraphContext);
    }
 catch (    SmackException|IOException|InterruptedException|XMPPException e) {
      unwindState(successorState);
      throw e;
    }
    if (transitionAttemptResult instanceof StateTransitionResult.Failure) {
      StateTransitionResult.Failure transitionFailureResult=(StateTransitionResult.Failure)transitionAttemptResult;
      invokeConnectionStateMachineListener(new ConnectionStateEvent.TransitionFailed(initialState,successorState,transitionFailureResult));
      return transitionAttemptResult;
    }
    StateTransitionResult.Success transitionSuccessResult=(StateTransitionResult.Success)transitionAttemptResult;
    currentStateVertex=successorStateVertex;
    invokeConnectionStateMachineListener(new ConnectionStateEvent.SuccessfullyTransitionedInto(successorState,transitionSuccessResult));
    return transitionSuccessResult;
  }
  @Override protected void sendInternal(  TopLevelStreamElement element) throws NotConnectedException, InterruptedException {
    final XmppClientToServerTransport transport=activeTransport;
    if (transport == null) {
      throw new NotConnectedException();
    }
    outgoingElementsQueue.put(element);
    transport.notifyAboutNewOutgoingElements();
  }
  @Override protected void sendNonBlockingInternal(  TopLevelStreamElement element) throws NotConnectedException, OutgoingQueueFullException {
    final XmppClientToServerTransport transport=activeTransport;
    if (transport == null) {
      throw new NotConnectedException();
    }
    boolean enqueued=outgoingElementsQueue.offer(element);
    if (!enqueued) {
      throw new OutgoingQueueFullException();
    }
    transport.notifyAboutNewOutgoingElements();
  }
  @Override protected void shutdown(){
    shutdown(false);
  }
  @Override public synchronized void instantShutdown(){
    shutdown(true);
  }
  @Override public ModularXmppClientToServerConnectionConfiguration getConfiguration(){
    return configuration;
  }
  private void shutdown(  boolean instant){
    Class<? extends StateDescriptor> mandatoryIntermediateState;
    if (instant) {
      mandatoryIntermediateState=InstantShutdownStateDescriptor.class;
    }
 else {
      mandatoryIntermediateState=ShutdownStateDescriptor.class;
    }
    WalkStateGraphContext context=buildNewWalkTo(DisconnectedStateDescriptor.class).withMandatoryIntermediateState(mandatoryIntermediateState).build();
    try {
      walkStateGraph(context);
    }
 catch (    IOException|SmackException|InterruptedException|XMPPException e) {
      throw new IllegalStateException("A walk to disconnected state should never throw",e);
    }
  }
  private SSLSession getSSLSession(){
    final XmppClientToServerTransport transport=activeTransport;
    if (transport == null) {
      return null;
    }
    return transport.getSslSession();
  }
  @Override protected void afterFeaturesReceived(){
    featuresReceived=true;
    notifyWaitingThreads();
  }
  private void parseAndProcessElement(  String element){
    try {
      XmlPullParser parser=PacketParserUtils.getParserFor(element);
      parser.next();
      XmlPullParser.Event event=parser.getEventType();
      outerloop:       while (true) {
switch (event) {
case START_ELEMENT:
          final String name=parser.getName();
switch (name) {
case Message.ELEMENT:
case IQ.IQ_ELEMENT:
case Presence.ELEMENT:
          try {
            parseAndProcessStanza(parser);
          }
  finally {
          }
        break;
case "error":
      StreamError streamError=PacketParserUtils.parseStreamError(parser,null);
    StreamErrorException streamErrorException=new StreamErrorException(streamError);
  currentXmppException=streamErrorException;
notifyWaitingThreads();
throw streamErrorException;
case "features":
parseFeatures(parser);
afterFeaturesReceived();
break;
default :
parseAndProcessNonza(parser);
break;
}
break;
case END_DOCUMENT:
break outerloop;
default :
}
event=parser.next();
}
}
 catch (XmlPullParserException|IOException|InterruptedException|StreamErrorException|SmackParsingException e) {
notifyConnectionError(e);
}
}
private synchronized void prepareToWaitForFeaturesReceived(){
featuresReceived=false;
}
private void waitForFeaturesReceived(String waitFor) throws InterruptedException, SmackException, XMPPException {
waitForConditionOrThrowConnectionException(() -> featuresReceived,waitFor);
}
@Override protected AbstractStreamOpen getStreamOpen(DomainBareJid to,CharSequence from,String id,String lang){
StreamOpenAndCloseFactory streamOpenAndCloseFactory=activeTransport.getStreamOpenAndCloseFactory();
return streamOpenAndCloseFactory.createStreamOpen(to,from,id,lang);
}
private void newStreamOpenWaitForFeaturesSequence(String waitFor) throws InterruptedException, SmackException, XMPPException {
prepareToWaitForFeaturesReceived();
StreamOpenAndCloseFactory streamOpenAndCloseFactory=activeTransport.getStreamOpenAndCloseFactory();
CharSequence from=null;
CharSequence localpart=connectionInternal.connection.getConfiguration().getUsername();
DomainBareJid xmppServiceDomain=getXMPPServiceDomain();
if (localpart != null) {
from=XmppStringUtils.completeJidFrom(localpart,xmppServiceDomain);
}
AbstractStreamOpen streamOpen=streamOpenAndCloseFactory.createStreamOpen(xmppServiceDomain,from,getStreamId(),getConfiguration().getXmlLang());
sendStreamOpen(streamOpen);
waitForFeaturesReceived(waitFor);
}
private void sendStreamOpen(AbstractStreamOpen streamOpen) throws NotConnectedException, InterruptedException {
sendNonza(streamOpen);
updateOutgoingStreamXmlEnvironmentOnStreamOpen(streamOpen);
}
public static class DisconnectedStateDescriptor extends StateDescriptor {
protected DisconnectedStateDescriptor(){
super(DisconnectedState.class,StateDescriptor.Property.finalState);
addSuccessor(LookupRemoteConnectionEndpointsStateDescriptor.class);
}
}
private final class DisconnectedState extends State {
private DisconnectedState(StateDescriptor stateDescriptor,ModularXmppClientToServerConnectionInternal connectionInternal){
super(stateDescriptor,connectionInternal);
}
@Override public StateTransitionResult.AttemptResult transitionInto(WalkStateGraphContext walkStateGraphContext){
synchronized (ModularXmppClientToServerConnection.this) {
if (inputOutputFilters.isEmpty()) {
previousInputOutputFilters=null;
}
 else {
previousInputOutputFilters=new ArrayList<>(inputOutputFilters.size());
previousInputOutputFilters.addAll(inputOutputFilters);
inputOutputFilters.clear();
}
}
ListIterator<State> it=walkFromDisconnectToAuthenticated.listIterator(walkFromDisconnectToAuthenticated.size());
while (it.hasPrevious()) {
State stateToReset=it.previous();
stateToReset.resetState();
}
walkFromDisconnectToAuthenticated=null;
return StateTransitionResult.Success.EMPTY_INSTANCE;
}
}
public static final class LookupRemoteConnectionEndpointsStateDescriptor extends StateDescriptor {
private LookupRemoteConnectionEndpointsStateDescriptor(){
super(LookupRemoteConnectionEndpointsState.class);
}
}
private final class LookupRemoteConnectionEndpointsState extends State {
boolean outgoingElementsQueueWasShutdown;
private LookupRemoteConnectionEndpointsState(StateDescriptor stateDescriptor,ModularXmppClientToServerConnectionInternal connectionInternal){
super(stateDescriptor,connectionInternal);
}
@Override public AttemptResult transitionInto(WalkStateGraphContext walkStateGraphContext) throws XMPPErrorException, SASLErrorException, IOException, SmackException, InterruptedException, FailedNonzaException {
Map<XmppClientToServerTransport,List<SmackFuture<LookupConnectionEndpointsResult,Exception>>> lookupFutures=new HashMap<>(transports.size());
final int numberOfFutures;
{
List<SmackFuture<?,?>> allFutures=new ArrayList<>();
for (XmppClientToServerTransport transport : transports.values()) {
transport.resetDiscoveredConnectionEndpoints();
List<SmackFuture<LookupConnectionEndpointsResult,Exception>> transportFutures=transport.lookupConnectionEndpoints();
lookupFutures.put(transport,transportFutures);
allFutures.addAll(transportFutures);
}
numberOfFutures=allFutures.size();
SmackFuture.await(allFutures,getReplyTimeout(),TimeUnit.MILLISECONDS);
}
List<LookupConnectionEndpointsFailed> lookupFailures=new ArrayList<>(numberOfFutures);
boolean atLeastOneConnectionEndpointDiscovered=false;
for (Map.Entry<XmppClientToServerTransport,List<SmackFuture<LookupConnectionEndpointsResult,Exception>>> entry : lookupFutures.entrySet()) {
XmppClientToServerTransport transport=entry.getKey();
for (SmackFuture<LookupConnectionEndpointsResult,Exception> future : entry.getValue()) {
LookupConnectionEndpointsResult result=future.getIfAvailable();
if (result == null) {
continue;
}
if (result instanceof LookupConnectionEndpointsFailed) {
LookupConnectionEndpointsFailed lookupFailure=(LookupConnectionEndpointsFailed)result;
lookupFailures.add(lookupFailure);
continue;
}
LookupConnectionEndpointsSuccess successResult=(LookupConnectionEndpointsSuccess)result;
transport.loadConnectionEndpoints(successResult);
atLeastOneConnectionEndpointDiscovered=true;
}
}
if (!atLeastOneConnectionEndpointDiscovered) {
throw SmackException.NoEndpointsDiscoveredException.from(lookupFailures);
}
if (!lookupFailures.isEmpty()) {
}
outgoingElementsQueueWasShutdown=outgoingElementsQueue.start();
return StateTransitionResult.Success.EMPTY_INSTANCE;
}
@Override public void resetState(){
for (XmppClientToServerTransport transport : transports.values()) {
transport.resetDiscoveredConnectionEndpoints();
}
if (outgoingElementsQueueWasShutdown) {
outgoingElementsQueue.shutdown();
}
}
}
public static final class ConnectedButUnauthenticatedStateDescriptor extends StateDescriptor {
private ConnectedButUnauthenticatedStateDescriptor(){
super(ConnectedButUnauthenticatedState.class,StateDescriptor.Property.finalState);
addSuccessor(SaslAuthenticationStateDescriptor.class);
addSuccessor(InstantShutdownStateDescriptor.class);
addSuccessor(ShutdownStateDescriptor.class);
}
}
private final class ConnectedButUnauthenticatedState extends State {
private ConnectedButUnauthenticatedState(StateDescriptor stateDescriptor,ModularXmppClientToServerConnectionInternal connectionInternal){
super(stateDescriptor,connectionInternal);
}
@Override public StateTransitionResult.AttemptResult transitionInto(WalkStateGraphContext walkStateGraphContext){
assert walkFromDisconnectToAuthenticated == null;
if (walkStateGraphContext.isWalksFinalState(getStateDescriptor())) {
walkFromDisconnectToAuthenticated=walkStateGraphContext.getWalk();
}
connected=true;
return StateTransitionResult.Success.EMPTY_INSTANCE;
}
@Override public void resetState(){
connected=false;
}
}
public static final class SaslAuthenticationStateDescriptor extends StateDescriptor {
private SaslAuthenticationStateDescriptor(){
super(SaslAuthenticationState.class,"RFC 6120 ยง 6");
addSuccessor(AuthenticatedButUnboundStateDescriptor.class);
}
}
private final class SaslAuthenticationState extends State {
private SaslAuthenticationState(StateDescriptor stateDescriptor,ModularXmppClientToServerConnectionInternal connectionInternal){
super(stateDescriptor,connectionInternal);
}
@Override public StateTransitionResult.AttemptResult transitionInto(WalkStateGraphContext walkStateGraphContext) throws IOException, SmackException, InterruptedException, XMPPException {
prepareToWaitForFeaturesReceived();
LoginContext loginContext=walkStateGraphContext.getLoginContext();
SASLMechanism usedSaslMechanism=authenticate(loginContext.username,loginContext.password,config.getAuthzid(),getSSLSession());
waitForFeaturesReceived("server stream features after SASL authentication");
return new SaslAuthenticationSuccessResult(usedSaslMechanism);
}
}
public static final class SaslAuthenticationSuccessResult extends StateTransitionResult.Success {
private final String saslMechanismName;
private SaslAuthenticationSuccessResult(SASLMechanism usedSaslMechanism){
super("SASL authentication successfull using " + usedSaslMechanism.getName());
this.saslMechanismName=usedSaslMechanism.getName();
}
public String getSaslMechanismName(){
return saslMechanismName;
}
}
public static final class AuthenticatedButUnboundStateDescriptor extends StateDescriptor {
private AuthenticatedButUnboundStateDescriptor(){
super(StateDescriptor.Property.multiVisitState);
addSuccessor(ResourceBindingStateDescriptor.class);
}
}
public static final class ResourceBindingStateDescriptor extends StateDescriptor {
private ResourceBindingStateDescriptor(){
super(ResourceBindingState.class,"RFC 6120 ยง 7");
addSuccessor(AuthenticatedAndResourceBoundStateDescriptor.class);
}
}
private final class ResourceBindingState extends State {
private ResourceBindingState(StateDescriptor stateDescriptor,ModularXmppClientToServerConnectionInternal connectionInternal){
super(stateDescriptor,connectionInternal);
}
@Override public StateTransitionResult.AttemptResult transitionInto(WalkStateGraphContext walkStateGraphContext) throws IOException, SmackException, InterruptedException, XMPPException {
lastFeaturesReceived=true;
notifyWaitingThreads();
LoginContext loginContext=walkStateGraphContext.getLoginContext();
Resourcepart resource=bindResourceAndEstablishSession(loginContext.resource);
streamResumed=false;
return new ResourceBoundResult(resource,loginContext.resource);
}
}
public static final class ResourceBoundResult extends StateTransitionResult.Success {
private final Resourcepart resource;
private ResourceBoundResult(Resourcepart boundResource,Resourcepart requestedResource){
super("Resource '" + boundResource + "' bound (requested: '"+ requestedResource+ "')");
this.resource=boundResource;
}
public Resourcepart getResource(){
return resource;
}
}
private boolean compressionEnabled;
@Override public boolean isUsingCompression(){
return compressionEnabled;
}
public static final class AuthenticatedAndResourceBoundStateDescriptor extends StateDescriptor {
private AuthenticatedAndResourceBoundStateDescriptor(){
super(AuthenticatedAndResourceBoundState.class,StateDescriptor.Property.finalState);
addSuccessor(InstantShutdownStateDescriptor.class);
addSuccessor(ShutdownStateDescriptor.class);
}
}
private final class AuthenticatedAndResourceBoundState extends State {
private AuthenticatedAndResourceBoundState(StateDescriptor stateDescriptor,ModularXmppClientToServerConnectionInternal connectionInternal){
super(stateDescriptor,connectionInternal);
}
@Override public StateTransitionResult.AttemptResult transitionInto(WalkStateGraphContext walkStateGraphContext) throws NotConnectedException, InterruptedException {
if (walkFromDisconnectToAuthenticated != null) {
assert walkStateGraphContext.getWalk().get(0).getStateDescriptor().getClass() != DisconnectedStateDescriptor.class;
walkStateGraphContext.appendWalkTo(walkFromDisconnectToAuthenticated);
}
 else {
walkFromDisconnectToAuthenticated=new ArrayList<>(walkStateGraphContext.getWalkLength() + 1);
walkStateGraphContext.appendWalkTo(walkFromDisconnectToAuthenticated);
}
walkFromDisconnectToAuthenticated.add(this);
afterSuccessfulLogin(streamResumed);
return StateTransitionResult.Success.EMPTY_INSTANCE;
}
@Override public void resetState(){
authenticated=false;
}
}
static final class ShutdownStateDescriptor extends StateDescriptor {
private ShutdownStateDescriptor(){
super(ShutdownState.class);
addSuccessor(CloseConnectionStateDescriptor.class);
}
}
private final class ShutdownState extends State {
private ShutdownState(StateDescriptor stateDescriptor,ModularXmppClientToServerConnectionInternal connectionInternal){
super(stateDescriptor,connectionInternal);
}
@Override public StateTransitionResult.TransitionImpossible isTransitionToPossible(WalkStateGraphContext walkStateGraphContext){
ensureNotOnOurWayToAuthenticatedAndResourceBound(walkStateGraphContext);
return null;
}
@Override public StateTransitionResult.AttemptResult transitionInto(WalkStateGraphContext walkStateGraphContext){
closingStreamReceived=false;
StreamOpenAndCloseFactory openAndCloseFactory=activeTransport.getStreamOpenAndCloseFactory();
AbstractStreamClose closeStreamElement=openAndCloseFactory.createStreamClose();
boolean streamCloseIssued=outgoingElementsQueue.offerAndShutdown(closeStreamElement);
if (streamCloseIssued) {
activeTransport.notifyAboutNewOutgoingElements();
boolean successfullyReceivedStreamClose=waitForClosingStreamTagFromServer();
if (successfullyReceivedStreamClose) {
for (Iterator<XmppInputOutputFilter> it=connectionInternal.getXmppInputOutputFilterBeginIterator(); it.hasNext(); ) {
XmppInputOutputFilter filter=it.next();
filter.closeInputOutput();
}
activeTransport.afterFiltersClosed();
for (Iterator<XmppInputOutputFilter> it=connectionInternal.getXmppInputOutputFilterBeginIterator(); it.hasNext(); ) {
XmppInputOutputFilter filter=it.next();
try {
filter.waitUntilInputOutputClosed();
}
 catch (IOException|CertificateException|InterruptedException|SmackException|XMPPException e) {
LOGGER.log(Level.WARNING,"waitUntilInputOutputClosed() threw",e);
}
}
authenticated=false;
}
}
return StateTransitionResult.Success.EMPTY_INSTANCE;
}
}
static final class InstantShutdownStateDescriptor extends StateDescriptor {
private InstantShutdownStateDescriptor(){
super(InstantShutdownState.class);
addSuccessor(CloseConnectionStateDescriptor.class);
}
}
private static final class InstantShutdownState extends NoOpState {
private InstantShutdownState(ModularXmppClientToServerConnection connection,StateDescriptor stateDescriptor,ModularXmppClientToServerConnectionInternal connectionInternal){
super(connection,stateDescriptor,connectionInternal);
}
@Override public StateTransitionResult.TransitionImpossible isTransitionToPossible(WalkStateGraphContext walkStateGraphContext){
ensureNotOnOurWayToAuthenticatedAndResourceBound(walkStateGraphContext);
return null;
}
}
private static final class CloseConnectionStateDescriptor extends StateDescriptor {
private CloseConnectionStateDescriptor(){
super(CloseConnectionState.class);
addSuccessor(DisconnectedStateDescriptor.class);
}
}
private final class CloseConnectionState extends State {
private CloseConnectionState(StateDescriptor stateDescriptor,ModularXmppClientToServerConnectionInternal connectionInternal){
super(stateDescriptor,connectionInternal);
}
@Override public StateTransitionResult.AttemptResult transitionInto(WalkStateGraphContext walkStateGraphContext){
activeTransport.disconnect();
activeTransport=null;
authenticated=connected=false;
return StateTransitionResult.Success.EMPTY_INSTANCE;
}
}
public void addConnectionStateMachineListener(ConnectionStateMachineListener connectionStateMachineListener){
connectionStateMachineListeners.add(connectionStateMachineListener);
}
public boolean removeConnectionStateMachineListener(ConnectionStateMachineListener connectionStateMachineListener){
return connectionStateMachineListeners.remove(connectionStateMachineListener);
}
private void invokeConnectionStateMachineListener(ConnectionStateEvent connectionStateEvent){
if (connectionStateMachineListeners.isEmpty()) {
return;
}
ASYNC_BUT_ORDERED.performAsyncButOrdered(this,() -> {
for (ConnectionStateMachineListener connectionStateMachineListener : connectionStateMachineListeners) {
connectionStateMachineListener.onConnectionStateEvent(connectionStateEvent,this);
}
}
);
}
@Override public boolean isSecureConnection(){
final XmppClientToServerTransport transport=activeTransport;
if (transport == null) {
return false;
}
return transport.isTransportSecured();
}
@Override protected void connectInternal() throws SmackException, IOException, XMPPException, InterruptedException {
WalkStateGraphContext walkStateGraphContext=buildNewWalkTo(ConnectedButUnauthenticatedStateDescriptor.class).build();
walkStateGraph(walkStateGraphContext);
}
private Map<String,Object> getFilterStats(){
Collection<XmppInputOutputFilter> filters;
synchronized (this) {
if (inputOutputFilters.isEmpty() && previousInputOutputFilters != null) {
filters=previousInputOutputFilters;
}
 else {
filters=inputOutputFilters;
}
}
Map<String,Object> filterStats=new HashMap<>(filters.size());
for (XmppInputOutputFilter xmppInputOutputFilter : filters) {
Object stats=xmppInputOutputFilter.getStats();
String filterName=xmppInputOutputFilter.getFilterName();
filterStats.put(filterName,stats);
}
return filterStats;
}
public Stats getStats(){
Map<Class<? extends ModularXmppClientToServerConnectionModuleDescriptor>,XmppClientToServerTransport.Stats> transportsStats=new HashMap<>(transports.size());
for (Map.Entry<Class<? extends ModularXmppClientToServerConnectionModuleDescriptor>,XmppClientToServerTransport> entry : transports.entrySet()) {
XmppClientToServerTransport.Stats transportStats=entry.getValue().getStats();
transportsStats.put(entry.getKey(),transportStats);
}
Map<String,Object> filterStats=getFilterStats();
return new Stats(transportsStats,filterStats);
}
public static final class Stats extends AbstractStats {
public final Map<Class<? extends ModularXmppClientToServerConnectionModuleDescriptor>,XmppClientToServerTransport.Stats> transportsStats;
public final Map<String,Object> filtersStats;
private Stats(Map<Class<? extends ModularXmppClientToServerConnectionModuleDescriptor>,XmppClientToServerTransport.Stats> transportsStats,Map<String,Object> filtersStats){
this.transportsStats=Collections.unmodifiableMap(transportsStats);
this.filtersStats=Collections.unmodifiableMap(filtersStats);
}
@Override public void appendStatsTo(ExtendedAppendable appendable) throws IOException {
StringUtils.appendHeading(appendable,"Connection stats",'#').append('\n');
for (Map.Entry<Class<? extends ModularXmppClientToServerConnectionModuleDescriptor>,XmppClientToServerTransport.Stats> entry : transportsStats.entrySet()) {
Class<? extends ModularXmppClientToServerConnectionModuleDescriptor> transportClass=entry.getKey();
XmppClientToServerTransport.Stats stats=entry.getValue();
StringUtils.appendHeading(appendable,transportClass.getName());
if (stats != null) {
appendable.append(stats.toString());
}
 else {
appendable.append("No stats available.");
}
appendable.append('\n');
}
for (Map.Entry<String,Object> entry : filtersStats.entrySet()) {
String filterName=entry.getKey();
Object filterStats=entry.getValue();
StringUtils.appendHeading(appendable,filterName);
appendable.append(filterStats.toString()).append('\n');
}
}
}
}
