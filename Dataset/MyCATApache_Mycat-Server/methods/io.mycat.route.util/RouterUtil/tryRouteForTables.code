/** 
 * 多表路由
 */
public static RouteResultset tryRouteForTables(SchemaConfig schema,DruidShardingParseInfo ctx,RouteCalculateUnit routeUnit,RouteResultset rrs,boolean isSelect,LayerCachePool cachePool) throws SQLNonTransientException {
  List<String> tables=ctx.getTables();
  if (schema.isNoSharding() || (tables.size() >= 1 && isNoSharding(schema,tables.get(0)))) {
    return routeToSingleNode(rrs,schema.getDataNode(),ctx.getSql());
  }
  if (tables.size() == 0) {
    return routeToSingleNode(rrs,schema.getDataNode(),ctx.getSql());
  }
  Map<String,Set<String>> tablesRouteMap=new HashMap<String,Set<String>>();
  for (  String tableName : tables) {
    TableConfig tableConfig=schema.getTables().get(tableName.toUpperCase());
    if (tableConfig == null) {
      String alias=ctx.getTableAliasMap().get(tableName);
      if (!StringUtil.isEmpty(alias)) {
        tableConfig=schema.getTables().get(alias.toUpperCase());
      }
      if (tableConfig == null) {
        if (StringUtils.isNotEmpty(schema.getDataNode())) {
          return routeToSingleNode(rrs,schema.getDataNode(),ctx.getSql());
        }
 else {
          String msg="can't find table define in schema " + tableName + " alias："+ alias+ ", schema:"+ schema.getName();
          LOGGER.warn(msg);
          throw new SQLNonTransientException(msg);
        }
      }
    }
    if (tableConfig.isGlobalTable()) {
      if (tablesRouteMap.get(tableName) == null) {
        tablesRouteMap.put(tableName,new HashSet<String>());
      }
      tablesRouteMap.get(tableName).addAll(tableConfig.getDataNodes());
    }
 else     if (tablesRouteMap.get(tableName) == null) {
      tablesRouteMap.put(tableName,new HashSet<String>());
      tablesRouteMap.get(tableName).addAll(tableConfig.getDataNodes());
    }
    if (tableConfig.getDistTables().size() > 0) {
      Map<String,List<String>> subTablesmap=rrs.getSubTableMaps();
      if (subTablesmap == null) {
        subTablesmap=Maps.newHashMap();
        rrs.setSubTableMaps(subTablesmap);
      }
      subTablesmap.put(tableName.toUpperCase(),tableConfig.getDistTables());
    }
  }
  if (tables.size() == 1) {
    return RouterUtil.tryRouteForOneTable(schema,ctx,routeUnit,tables.get(0),rrs,isSelect,cachePool);
  }
  Set<String> retNodesSet=new HashSet<String>();
  Map<String,Map<String,Set<ColumnRoutePair>>> tablesAndConditions=routeUnit.getTablesAndConditions();
  if (tablesAndConditions != null && tablesAndConditions.size() > 0) {
    RouterUtil.findRouteWithcConditionsForTables(schema,rrs,tablesAndConditions,tablesRouteMap,ctx.getSql(),cachePool,isSelect);
    if (rrs.isFinishedRoute()) {
      return rrs;
    }
  }
  boolean isFirstAdd=true;
  for (  Map.Entry<String,Set<String>> entry : tablesRouteMap.entrySet()) {
    if (entry.getValue() == null || entry.getValue().size() == 0) {
      throw new SQLNonTransientException("parent key can't find any valid datanode ");
    }
 else {
      if (isFirstAdd) {
        retNodesSet.addAll(entry.getValue());
        isFirstAdd=false;
      }
 else {
        retNodesSet.retainAll(entry.getValue());
        if (retNodesSet.size() == 0) {
          String errMsg="invalid route in sql, multi tables found but datanode has no intersection " + " sql:" + ctx.getSql();
          LOGGER.warn(errMsg);
          throw new SQLNonTransientException(errMsg);
        }
      }
    }
  }
  if (retNodesSet != null && retNodesSet.size() > 0) {
    String tableName=tables.get(0);
    TableConfig tableConfig=schema.getTables().get(tableName.toUpperCase());
    if (tableConfig.isDistTable()) {
      routeToDistTableNode(schema,rrs,ctx.getSql(),tablesAndConditions,cachePool,isSelect,null);
      return rrs;
    }
    if (retNodesSet.size() > 1 && isAllGlobalTable(ctx,schema)) {
      if (isSelect) {
        rrs.setCacheAble(false);
        ArrayList<String> retNodeList=new ArrayList<String>(retNodesSet);
        Collections.shuffle(retNodeList);
        routeToSingleNode(rrs,retNodeList.get(0),ctx.getSql());
      }
 else {
        routeToMultiNode(isSelect,rrs,retNodesSet,ctx.getSql(),true);
      }
    }
 else {
      routeToMultiNode(isSelect,rrs,retNodesSet,ctx.getSql());
    }
  }
  return rrs;
}
