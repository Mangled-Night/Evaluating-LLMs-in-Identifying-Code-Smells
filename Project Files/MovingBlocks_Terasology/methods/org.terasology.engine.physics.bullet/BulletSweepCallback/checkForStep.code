@Override public boolean checkForStep(Vector3f direction,float stepHeight,float slopeFactor,float checkForwardDistance){
  boolean moveUpStep;
  boolean hitStep=false;
  float stepSlope=1f;
  Vector3f lookAheadOffset=new Vector3f(direction.x,direction.y,direction.z);
  lookAheadOffset.y=0;
  lookAheadOffset.normalize();
  lookAheadOffset.mul(checkForwardDistance);
  Vector3f fromWorld=new Vector3f();
  this.getHitPointWorld(fromWorld);
  fromWorld.y+=stepHeight + 0.05f;
  fromWorld.add(lookAheadOffset);
  Vector3f toWorld=new Vector3f();
  this.getHitPointWorld(toWorld);
  toWorld.y-=0.05f;
  toWorld.add(lookAheadOffset);
  ClosestRayResultCallback rayResult=new ClosestRayResultCallback(fromWorld,toWorld);
  Matrix4f transformFrom=new Matrix4f().setTranslation(fromWorld);
  Matrix4f transformTo=new Matrix4f().setTranslation(toWorld);
  Matrix4f targetTransform=this.getHitCollisionObject().getWorldTransform();
  btDiscreteDynamicsWorld.rayTestSingle(transformFrom,transformTo,this.getHitCollisionObject(),this.getHitCollisionObject().getCollisionShape(),targetTransform,rayResult);
  if (rayResult.hasHit()) {
    hitStep=true;
    Vector3f hitNormal=new Vector3f();
    rayResult.getHitNormalWorld(hitNormal);
    stepSlope=hitNormal.dot(0,1,0);
  }
  fromWorld.add(lookAheadOffset);
  toWorld.add(lookAheadOffset);
  rayResult=new ClosestRayResultCallback(fromWorld,toWorld);
  transformFrom=new Matrix4f().setTranslation(fromWorld);
  transformTo=new Matrix4f().setTranslation(toWorld);
  targetTransform=this.getHitCollisionObject().getWorldTransform();
  btDiscreteDynamicsWorld.rayTestSingle(transformFrom,transformTo,this.getHitCollisionObject(),this.getHitCollisionObject().getCollisionShape(),targetTransform,rayResult);
  if (rayResult.hasHit()) {
    hitStep=true;
    Vector3f hitNormal=new Vector3f();
    rayResult.getHitNormalWorld(hitNormal);
    stepSlope=Math.min(stepSlope,hitNormal.dot(0,1,0));
  }
  moveUpStep=hitStep && stepSlope >= slopeFactor;
  return moveUpStep;
}
