/** 
 * Retrieves the  {@link TypeHandler} for the specified type, if available.<p> Each  {@link TypeHandlerFactory} added to this {@link TypeHandlerLibrary} is requested to generate a {@link TypeHandler} for the given type. Most recently added factories are requested first, hence a {@link TypeHandlerFactory} can override one that was added before it.
 * @param type The {@link Type} describing the type for which to retrieve the {@link TypeHandler}.
 * @return The {@link TypeHandler} for the specified type, if available.
 */
@SuppressWarnings("unchecked") public Optional<TypeHandler<?>> getTypeHandler(Type type){
  TypeInfo typeInfo=TypeInfo.of(type);
  return (Optional<TypeHandler<?>>)getTypeHandler(typeInfo);
}
/** 
 * Retrieves the  {@link TypeHandler} for the specified type, if available.<p> Each  {@link TypeHandlerFactory} added to this {@link TypeHandlerLibrary} is requested to generate a {@link TypeHandler} for the given type. Most recently added factories are requested first, hence a {@link TypeHandlerFactory} can override one that was added before it.
 * @param typeClass The {@link Class} of the type for which to retrieve the {@link TypeHandler}.
 * @param < T > The type for which to retrieve the {@link TypeHandler}.
 * @return The {@link TypeHandler} for the specified type, if available.
 */
public <T>Optional<TypeHandler<T>> getTypeHandler(Class<T> typeClass){
  return getTypeHandler(TypeInfo.of(typeClass));
}
/** 
 * Retrieves the  {@link TypeHandler} for the specified type, if available.<p> Each  {@link TypeHandlerFactory} added to this {@link TypeHandlerLibrary} is requested to generate a {@link TypeHandler} for the given type. Most recently added factories are requested first, hence a {@link TypeHandlerFactory} can override one that was added before it.
 * @param type The {@link TypeInfo} describing the type for which to retrieve the {@link TypeHandler}.
 * @param < T > The type for which to retrieve the {@link TypeHandler}.
 * @return The {@link TypeHandler} for the specified type, if available.
 */
@SuppressWarnings("unchecked") public <T>Optional<TypeHandler<T>> getTypeHandler(TypeInfo<T> type){
  TypeHandlerContext context=new TypeHandlerContext(this,sandbox);
  if (typeHandlerCache.containsKey(type)) {
    return Optional.of((TypeHandler<T>)typeHandlerCache.get(type));
  }
  Map<TypeInfo<?>,FutureTypeHandler<?>> futures=futureTypeHandlers.get();
  boolean cleanupFutureTypeHandlers=false;
  if (futures == null) {
    cleanupFutureTypeHandlers=true;
    futures=new HashMap<>();
    futureTypeHandlers.set(futures);
  }
  FutureTypeHandler<T> future=(FutureTypeHandler<T>)futures.get(type);
  if (future != null) {
    return Optional.of(future);
  }
  try {
    future=new FutureTypeHandler<>();
    futures.put(type,future);
    for (int i=typeHandlerFactories.size() - 1; i >= 0; i--) {
      TypeHandlerFactory typeHandlerFactory=typeHandlerFactories.get(i);
      Optional<TypeHandler<T>> typeHandler=typeHandlerFactory.create(type,context);
      if (typeHandler.isPresent()) {
        TypeHandler<T> handler=typeHandler.get();
        if (!sandbox.isValidTypeHandlerDeclaration(type,handler)) {
          continue;
        }
        typeHandlerCache.put(type,handler);
        future.typeHandler=handler;
        return Optional.of(handler);
      }
    }
    return Optional.empty();
  }
  finally {
    futures.remove(type);
    if (cleanupFutureTypeHandlers) {
      futureTypeHandlers.remove();
    }
  }
}
