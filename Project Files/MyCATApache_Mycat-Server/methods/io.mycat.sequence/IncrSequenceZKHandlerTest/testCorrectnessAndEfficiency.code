@Test public void testCorrectnessAndEfficiency() throws InterruptedException {
  final Thread threads[]=new Thread[MAX_CONNECTION];
  for (int i=0; i < MAX_CONNECTION; i++) {
    final int a=i;
    threads[i]=new Thread(){
      @Override public void run(){
        incrSequenceZKHandler[a]=new IncrSequenceZKHandler();
        Properties props=PropertiesUtil.loadProps("sequence_conf.properties");
        try {
          incrSequenceZKHandler[a].initializeZK(props,testingServer.getConnectString());
        }
 catch (        Exception e) {
          e.printStackTrace();
        }
        Thread threads[]=new Thread[threadCount];
        for (int j=0; j < threadCount; j++) {
          threads[j]=new Thread(){
            @Override public void run(){
              for (int k=0; k < LOOP; k++) {
                long key=incrSequenceZKHandler[a].nextId("GLOBAL");
                results.add(key);
              }
            }
          }
;
          threads[j].start();
        }
        for (int j=0; j < threadCount; j++) {
          try {
            threads[j].join();
          }
 catch (          InterruptedException e) {
            e.printStackTrace();
          }
        }
      }
    }
;
  }
  long start=System.currentTimeMillis();
  for (int i=0; i < MAX_CONNECTION; i++) {
    threads[i].start();
  }
  for (int i=0; i < MAX_CONNECTION; i++) {
    threads[i].join();
  }
  long end=System.currentTimeMillis();
  Assert.assertEquals(MAX_CONNECTION * LOOP * threadCount,results.size());
  System.out.println("Time elapsed:" + ((double)(end - start + 1) / 1000.0) + "s\n TPS:"+ ((double)(MAX_CONNECTION * LOOP * threadCount) / (double)(end - start + 1) * 1000.0)+ "/s");
}
