/** 
 * Verifies that a notification for a previously sent publication is received as soon as notification filtering has been adjusted to allow for the notification to be delivered.
 * @throws Exception if the test fails
 */
@SmackIntegrationTest public void testNotificationAfterFilterChange() throws Exception {
  GeoLocation.Builder builder=GeoLocation.builder();
  GeoLocation data=builder.setAccuracy(12d).setAlt(999d).setAltAccuracy(9d).setArea("Amsterdam").setBearing(9d).setBuilding("Test Building").setCountry("Netherlands").setCountryCode("NL").setDescription("My Description").setFloor("middle").setLat(25.098345d).setLocality("brilliant").setLon(77.992034).setPostalcode("110085").setRegion("North").setRoom("small").setSpeed(250.0d).setStreet("Wall Street").setText("Unit Testing GeoLocation 2").setTimestamp(XmppDateTime.parseDate("2007-02-19")).setTzo("+5:30").setUri(new URI("http://xmpp.org")).build();
  IntegrationTestRosterUtil.ensureBothAccountsAreSubscribedToEachOther(conOne,conTwo,timeout);
  final SimpleResultSyncPoint geoLocationReceived=new SimpleResultSyncPoint();
  final PepEventListener<GeoLocation> geoLocationListener=(jid,geoLocation,id,message) -> {
    if (geoLocation.equals(data)) {
      geoLocationReceived.signal();
    }
  }
;
  try {
    publishAndWait(glm1,ServiceDiscoveryManager.getInstanceFor(conOne),data);
    registerListenerAndWait(glm2,ServiceDiscoveryManager.getInstanceFor(conTwo),geoLocationListener);
    try {
      Object result=geoLocationReceived.waitForResult(timeout);
      Assertions.assertNotNull(result,"Expected to receive a PEP notification, but did not.");
    }
 catch (    TimeoutException e) {
      Assertions.fail("Expected to receive a PEP notification, but did not.");
    }
  }
  finally {
    unregisterListener(glm2,geoLocationListener);
  }
}
