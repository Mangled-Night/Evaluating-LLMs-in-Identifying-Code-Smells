/** 
 * Remove; match on key only if value null, else match both.
 */
V remove(Object key,int hash,Object value,boolean refRemove){
  lock();
  try {
    if (!refRemove) {
      removeStale();
    }
    int c=count - 1;
    HashEntry<K,V>[] tab=table;
    int index=hash & tab.length - 1;
    HashEntry<K,V> first=tab[index];
    HashEntry<K,V> e=first;
    while (e != null && key != e.keyRef && (refRemove || hash != e.hash || !keyEq(key,e.key()))) {
      e=e.next;
    }
    V oldValue=null;
    if (e != null) {
      V v=e.value();
      if (value == null || value.equals(v)) {
        oldValue=v;
        ++modCount;
        HashEntry<K,V> newFirst=e.next;
        for (HashEntry<K,V> p=first; p != e; p=p.next) {
          K pKey=p.key();
          if (pKey == null) {
            c--;
            continue;
          }
          newFirst=newHashEntry(pKey,p.hash,newFirst,p.value());
        }
        tab[index]=newFirst;
        count=c;
      }
    }
    return oldValue;
  }
  finally {
    unlock();
  }
}
/** 
 * Removes the key (and its corresponding value) from this map.  This method does nothing if the key is not in the map.
 * @param key the key that needs to be removed
 * @return the previous value associated with <tt>key</tt>, or <tt>null</tt>if there was no mapping for <tt>key</tt>
 * @throws NullPointerException if the specified key is null
 */
@Override public V remove(Object key){
  int hash=hashOf(key);
  return segmentFor(hash).remove(key,hash,null,false);
}
/** 
 * @throws NullPointerException if the specified key is null
 */
public boolean remove(Object key,Object value){
  int hash=hashOf(key);
  if (value == null) {
    return false;
  }
  return segmentFor(hash).remove(key,hash,value,false) != null;
}
public void remove(){
  if (lastReturned == null) {
    throw new IllegalStateException();
  }
  ConcurrentWeakKeyHashMap.this.remove(currentKey);
  lastReturned=null;
}
@Override public boolean remove(Object o){
  return ConcurrentWeakKeyHashMap.this.remove(o) != null;
}
@Override public boolean remove(Object o){
  if (!(o instanceof Map.Entry<?,?>)) {
    return false;
  }
  Map.Entry<?,?> e=(Map.Entry<?,?>)o;
  return ConcurrentWeakKeyHashMap.this.remove(e.getKey(),e.getValue());
}
