@SuppressWarnings("unchecked") @Override public Optional<T> deserialize(PersistedData data){
  if (!data.isValueMap()) {
    return deserializeViaDelegate(data);
  }
  PersistedDataMap valueMap=data.getAsValueMap();
  if (!valueMap.has(TYPE_FIELD)) {
    return deserializeViaDelegate(data);
  }
  String runtimeTypeName=valueMap.getAsString(TYPE_FIELD);
  Optional<Type> typeToDeserializeAs=findSubtypeWithName(runtimeTypeName);
  if (!typeToDeserializeAs.isPresent()) {
    LOGGER.warn("Cannot find subtype '{}' to deserialize as, " + "deserializing as base type '{}'",runtimeTypeName,typeInfo);
    return deserializeViaDelegate(data);
  }
  TypeHandler<T> runtimeTypeHandler=(TypeHandler<T>)typeHandlerLibrary.getTypeHandler(typeToDeserializeAs.get()).map(typeHandler -> (TypeHandler)typeHandler).orElseGet(() -> {
    LOGGER.warn("Cannot find TypeHandler for runtime type '{}', " + "deserializing as base type '{}'",runtimeTypeName,typeInfo);
    return delegateHandler;
  }
);
  PersistedData valueData;
  Set<Map.Entry<String,PersistedData>> valueEntries=valueMap.entrySet();
  if (valueEntries.size() == 2 && valueMap.has(VALUE_FIELD)) {
    valueData=valueMap.get(VALUE_FIELD);
  }
 else {
    Map<String,PersistedData> valueFields=Maps.newLinkedHashMap();
    for (    Map.Entry<String,PersistedData> entry : valueEntries) {
      valueFields.put(entry.getKey(),entry.getValue());
    }
    valueFields.remove(TYPE_FIELD);
    valueData=PersistedDataMap.of(valueFields);
  }
  return runtimeTypeHandler.deserialize(valueData);
}
