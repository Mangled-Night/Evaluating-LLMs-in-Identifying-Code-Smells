@Test void shouldPropagateCommandFailures(){
  List<RedisURI> seed=Arrays.asList(RedisURI.create("127.0.0.1",7380),RedisURI.create("127.0.0.1",7381));
  when(nodeConnectionFactory.connectToNodeAsync(any(RedisCodec.class),eq(InetSocketAddress.createUnresolved("127.0.0.1",7380)))).thenReturn(completedFuture((StatefulRedisConnection)connection1));
  when(nodeConnectionFactory.connectToNodeAsync(any(RedisCodec.class),eq(InetSocketAddress.createUnresolved("127.0.0.1",7381)))).thenReturn(completedFuture((StatefulRedisConnection)connection2));
  reset(connection1,connection2);
  when(connection1.async()).thenReturn(asyncCommands1);
  when(connection2.async()).thenReturn(asyncCommands2);
  when(connection1.closeAsync()).thenReturn(CompletableFuture.completedFuture(null));
  when(connection2.closeAsync()).thenReturn(CompletableFuture.completedFuture(null));
  when(connection1.dispatch(any(RedisCommand.class))).thenAnswer(invocation -> {
    TimedAsyncCommand command=invocation.getArgument(0);
    command.completeExceptionally(new RedisException("AUTH"));
    return command;
  }
);
  RedisException nestedException=new RedisException("NESTED");
  when(connection2.dispatch(any(RedisCommand.class))).thenAnswer(invocation -> {
    TimedAsyncCommand command=invocation.getArgument(0);
    command.completeExceptionally(nestedException);
    return command;
  }
);
  CompletionStage<Map<RedisURI,Partitions>> actual=sut.loadViews(seed,Duration.ofSeconds(1),true);
  assertThat(actual).isCompletedExceptionally();
  try {
    actual.toCompletableFuture().join();
    fail("Missing CompletionException");
  }
 catch (  CompletionException e) {
    assertThat(e.getCause()).hasSuppressedException(nestedException);
  }
}
