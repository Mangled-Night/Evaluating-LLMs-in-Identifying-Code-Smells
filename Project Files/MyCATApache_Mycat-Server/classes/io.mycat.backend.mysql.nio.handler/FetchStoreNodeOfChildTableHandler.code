/** 
 * company where id=(select company_id from customer where id=3); the one which return data (id) is the datanode to store child table's records
 * @author wuzhih
 */
public class FetchStoreNodeOfChildTableHandler implements ResponseHandler {
  private static final Logger LOGGER=LoggerFactory.getLogger(FetchStoreNodeOfChildTableHandler.class);
  private String sql;
  private volatile String result;
  private volatile String dataNode;
  private AtomicInteger finished=new AtomicInteger(0);
  protected final ReentrantLock lock=new ReentrantLock();
  private volatile ServerConnection sc;
  public String execute(  String schema,  String sql,  List<String> dataNodes,  ServerConnection sc){
    String key=schema + ":" + sql;
    CachePool cache=MycatServer.getInstance().getCacheService().getCachePool("ER_SQL2PARENTID");
    String result=(String)cache.get(key);
    if (result != null) {
      return result;
    }
    this.sql=sql;
    int totalCount=dataNodes.size();
    long startTime=System.currentTimeMillis();
    long endTime=startTime + 5 * 60 * 1000L;
    MycatConfig conf=MycatServer.getInstance().getConfig();
    this.sc=sc;
    LOGGER.debug("find child node with sql:" + sql);
    for (    String dn : dataNodes) {
      if (dataNode != null) {
        return dataNode;
      }
      PhysicalDBNode mysqlDN=conf.getDataNodes().get(dn);
      try {
        if (LOGGER.isDebugEnabled()) {
          LOGGER.debug(sc + "execute in datanode " + dn);
        }
        RouteResultsetNode node=new RouteResultsetNode(dn,ServerParse.SELECT,sql);
        node.setRunOnSlave(false);
        BackendConnection conn=sc.getSession2().getTarget(node);
        if (sc.getSession2().tryExistsCon(conn,node)) {
          _execute(conn,node,sc);
        }
 else {
          mysqlDN.getConnection(mysqlDN.getDatabase(),sc.isAutocommit(),node,this,node);
        }
      }
 catch (      Exception e) {
        LOGGER.warn("get connection err " + e);
      }
    }
    while (dataNode == null && System.currentTimeMillis() < endTime) {
      try {
        Thread.sleep(50);
      }
 catch (      InterruptedException e) {
        break;
      }
      if (dataNode != null || finished.get() >= totalCount) {
        break;
      }
    }
    if (dataNode != null) {
      cache.putIfAbsent(key,dataNode);
    }
    if (System.currentTimeMillis() > endTime) {
      LOGGER.error("timeout when executing fetch sql  " + sql);
    }
    return dataNode;
  }
  public String execute(  String schema,  String sql,  ArrayList<String> dataNodes){
    String key=schema + ":" + sql;
    CachePool cache=MycatServer.getInstance().getCacheService().getCachePool("ER_SQL2PARENTID");
    String result=(String)cache.get(key);
    if (result != null) {
      return result;
    }
    this.sql=sql;
    int totalCount=dataNodes.size();
    long startTime=System.currentTimeMillis();
    long endTime=startTime + 5 * 60 * 1000L;
    MycatConfig conf=MycatServer.getInstance().getConfig();
    LOGGER.debug("find child node with sql:" + sql);
    for (    String dn : dataNodes) {
      if (dataNode != null) {
        return dataNode;
      }
      PhysicalDBNode mysqlDN=conf.getDataNodes().get(dn);
      try {
        if (LOGGER.isDebugEnabled()) {
          LOGGER.debug("execute in datanode " + dn);
        }
        RouteResultsetNode node=new RouteResultsetNode(dn,ServerParse.SELECT,sql);
        node.setRunOnSlave(false);
        mysqlDN.getConnection(mysqlDN.getDatabase(),true,node,this,node);
      }
 catch (      Exception e) {
        LOGGER.warn("get connection err " + e);
      }
      try {
        Thread.sleep(200);
      }
 catch (      InterruptedException e) {
      }
    }
    while (dataNode == null && System.currentTimeMillis() < endTime) {
      try {
        Thread.sleep(50);
      }
 catch (      InterruptedException e) {
        break;
      }
      if (dataNode != null || finished.get() >= totalCount) {
        break;
      }
    }
    if (dataNode != null) {
      cache.putIfAbsent(key,dataNode);
    }
    return dataNode;
  }
  private void _execute(  BackendConnection conn,  RouteResultsetNode node,  ServerConnection sc){
    conn.setResponseHandler(this);
    try {
      conn.execute(node,sc,sc.isAutocommit());
    }
 catch (    IOException e) {
      connectionError(e,conn);
    }
  }
  @Override public void connectionAcquired(  BackendConnection conn){
    conn.setResponseHandler(this);
    try {
      conn.query(sql);
    }
 catch (    Exception e) {
      executeException(conn,e);
    }
  }
  @Override public void connectionError(  Throwable e,  BackendConnection conn){
    finished.incrementAndGet();
    LOGGER.warn("connectionError " + e);
  }
  @Override public void errorResponse(  byte[] data,  BackendConnection conn){
    finished.incrementAndGet();
    ErrorPacket err=new ErrorPacket();
    err.read(data);
    LOGGER.warn("errorResponse " + err.errno + " "+ new String(err.message));
    releaseConnection(conn);
    LOGGER.warn(this.sc + " connection release " + conn+ " errorResponse");
  }
  @Override public void okResponse(  byte[] ok,  BackendConnection conn){
    boolean executeResponse=conn.syncAndExcute();
    if (executeResponse) {
      finished.incrementAndGet();
      releaseConnection(conn);
    }
  }
  @Override public void rowResponse(  byte[] row,  BackendConnection conn){
    if (LOGGER.isDebugEnabled()) {
      LOGGER.debug(this.sc + "received rowResponse response," + getColumn(row)+ " from  "+ conn);
    }
    if (result == null) {
      result=getColumn(row);
      dataNode=((RouteResultsetNode)conn.getAttachment()).getName();
    }
 else {
      LOGGER.warn("find multi data nodes for child table store, sql is:  " + sql);
    }
  }
  private String getColumn(  byte[] row){
    RowDataPacket rowDataPkg=new RowDataPacket(1);
    rowDataPkg.read(row);
    byte[] columnData=rowDataPkg.fieldValues.get(0);
    return new String(columnData);
  }
  @Override public void rowEofResponse(  byte[] eof,  BackendConnection conn){
    finished.incrementAndGet();
    releaseConnection(conn);
  }
  private void executeException(  BackendConnection c,  Throwable e){
    finished.incrementAndGet();
    LOGGER.warn("executeException   " + e);
    c.close("exception:" + e);
  }
  @Override public void writeQueueAvailable(){
  }
  @Override public void connectionClose(  BackendConnection conn,  String reason){
    finished.incrementAndGet();
    LOGGER.warn("connection closed " + conn + " reason:"+ reason);
  }
  @Override public void fieldEofResponse(  byte[] header,  List<byte[]> fields,  byte[] eof,  BackendConnection conn){
  }
  private void releaseConnection(  BackendConnection conn){
    if (this.sc != null) {
      Map<RouteResultsetNode,BackendConnection> target=sc.getSession2().getTargetMap();
      for (      BackendConnection backConn : target.values()) {
        if (backConn != null && backConn.equals(conn)) {
          return;
        }
      }
    }
    conn.release();
  }
}
