/** 
 * @author mycat
 */
public class SingleNodeHandler implements ResponseHandler, Terminatable, LoadDataResponseHandler {
  private static final Logger LOGGER=LoggerFactory.getLogger(SingleNodeHandler.class);
  private final RouteResultsetNode node;
  private final RouteResultset rrs;
  private final NonBlockingSession session;
  private volatile byte packetId;
  protected volatile ByteBuffer buffer;
  private volatile boolean isRunning;
  private Runnable terminateCallBack;
  protected long startTime;
  protected long netInBytes;
  protected long netOutBytes;
  private long selectRows;
  protected long affectedRows;
  protected final AtomicBoolean errorRepsponsed=new AtomicBoolean(false);
  private boolean prepared;
  protected int fieldCount;
  protected List<FieldPacket> fieldPackets=new ArrayList<FieldPacket>();
  private volatile boolean isDefaultNodeShowTable;
  private volatile boolean isDefaultNodeShowFullTable;
  private Set<String> shardingTablesSet;
  private byte[] header=null;
  private List<byte[]> fields=null;
  public SingleNodeHandler(  RouteResultset rrs,  NonBlockingSession session){
    this.rrs=rrs;
    this.node=rrs.getNodes()[0];
    if (node == null) {
      throw new IllegalArgumentException("routeNode is null!");
    }
    if (session == null) {
      throw new IllegalArgumentException("session is null!");
    }
    this.session=session;
    ServerConnection source=session.getSource();
    String schema=source.getSchema();
    if (schema != null && ServerParse.SHOW == rrs.getSqlType()) {
      SchemaConfig schemaConfig=MycatServer.getInstance().getConfig().getSchemas().get(schema);
      int type=ServerParseShow.tableCheck(rrs.getStatement(),0);
      isDefaultNodeShowTable=(ServerParseShow.TABLES == type && !Strings.isNullOrEmpty(schemaConfig.getDataNode()));
      isDefaultNodeShowFullTable=(ServerParseShow.FULLTABLES == type && !Strings.isNullOrEmpty(schemaConfig.getDataNode()));
      if (isDefaultNodeShowTable) {
        shardingTablesSet=ShowTables.getTableSet(source,rrs.getStatement());
      }
 else       if (isDefaultNodeShowFullTable) {
        shardingTablesSet=ShowFullTables.getTableSet(source,rrs.getStatement());
      }
    }
    if (rrs != null && rrs.getStatement() != null) {
      netInBytes+=rrs.getStatement().getBytes().length;
    }
  }
  public NonBlockingSession getSession(){
    return this.session;
  }
  public RouteResultsetNode getRouteResultsetNode(){
    return this.node;
  }
  public RouteResultset getRouteResultset(){
    return this.rrs;
  }
  public ByteBuffer getBuffer(){
    return this.buffer;
  }
  @Override public void terminate(  Runnable callback){
    boolean zeroReached=false;
    if (isRunning) {
      terminateCallBack=callback;
    }
 else {
      zeroReached=true;
    }
    if (zeroReached) {
      callback.run();
    }
  }
  protected void endRunning(){
    Runnable callback=null;
    if (isRunning) {
      isRunning=false;
      callback=terminateCallBack;
      terminateCallBack=null;
    }
    if (callback != null) {
      callback.run();
    }
  }
  private void recycleResources(){
    ByteBuffer buf=buffer;
    if (buf != null) {
      session.getSource().recycle(buffer);
      buffer=null;
    }
  }
  public void execute() throws Exception {
    startTime=System.currentTimeMillis();
    ServerConnection sc=session.getSource();
    this.isRunning=true;
    if (rrs.isLoadData()) {
      this.packetId=session.getSource().getLoadDataInfileHandler().getLastPackId();
    }
 else {
      this.packetId=0;
    }
    final BackendConnection conn=session.getTarget(node);
    LOGGER.debug("rrs.getRunOnSlave() " + rrs.getRunOnSlaveDebugInfo());
    node.setRunOnSlave(rrs.getRunOnSlave());
    LOGGER.debug("node.getRunOnSlave() " + node.getRunOnSlaveDebugInfo());
    try {
      if (session.tryExistsCon(conn,node)) {
        _execute(conn);
      }
 else {
        MycatConfig conf=MycatServer.getInstance().getConfig();
        LOGGER.debug("node.getRunOnSlave() " + node.getRunOnSlave());
        node.setRunOnSlave(rrs.getRunOnSlave());
        LOGGER.debug("node.getRunOnSlave() " + node.getRunOnSlave());
        PhysicalDBNode dn=conf.getDataNodes().get(node.getName());
        dn.getConnection(dn.getDatabase(),sc.isAutocommit(),node,this,node);
      }
    }
 catch (    Exception e) {
      ServerConnection source=session.getSource();
      LOGGER.warn(new StringBuilder().append(source).append(rrs).toString(),e);
      connectionError(e,null);
    }
  }
  @Override public void connectionAcquired(  final BackendConnection conn){
    session.bindConnection(node,conn);
    _execute(conn);
  }
  private void _execute(  BackendConnection conn){
    if (session.closed()) {
      endRunning();
      session.clearResources(true);
      return;
    }
    conn.setResponseHandler(this);
    try {
      conn.execute(node,session.getSource(),session.getSource().isAutocommit());
    }
 catch (    Exception e1) {
      executeException(conn,e1);
      return;
    }
  }
  private void executeException(  BackendConnection c,  Exception e){
    ErrorPacket err=new ErrorPacket();
    err.packetId=++packetId;
    err.errno=ErrorCode.ERR_FOUND_EXCEPTION;
    String message=e.toString();
    LOGGER.error(message);
    err.message=StringUtil.encode(message,session.getSource().getCharset());
    this.backConnectionErr(err,c);
  }
  @Override public void connectionError(  Throwable e,  BackendConnection conn){
    endRunning();
    ServerConnection source=session.getSource();
    if (errorRepsponsed.compareAndSet(false,true)) {
      source.writeErrMessage(ErrorCode.ER_NEW_ABORTING_CONNECTION,e.getMessage());
    }
    source.getListener().fireEvent(SqlExecuteStage.END);
  }
  @Override public void errorResponse(  byte[] data,  BackendConnection conn){
    ErrorPacket err=new ErrorPacket();
    err.read(data);
    err.packetId=++packetId;
    backConnectionErr(err,conn);
  }
  private void backConnectionErr(  ErrorPacket errPkg,  BackendConnection conn){
    endRunning();
    ServerConnection source=session.getSource();
    String errUser=source.getUser();
    String errHost=source.getHost();
    int errPort=source.getLocalPort();
    String errmgs=" errno:" + errPkg.errno + " "+ new String(errPkg.message);
    LOGGER.warn("execute  sql err :" + errmgs + " con:"+ conn+ " frontend host:"+ errHost+ "/"+ errPort+ "/"+ errUser);
    session.releaseConnectionIfSafe(conn,LOGGER.isDebugEnabled(),false);
    source.setTxInterrupt(errmgs);
    errPkg.packetId=1;
    if (errorRepsponsed.compareAndSet(false,true)) {
      source.writeErrMessage(errPkg.errno,new String(errPkg.message));
    }
    recycleResources();
    source.getListener().fireEvent(SqlExecuteStage.END);
  }
  /** 
 * insert/update/delete okResponse()：读取data字节数组，组成一个OKPacket，并调用ok.write(source)将结果写入前端连接FrontendConnection的写缓冲队列writeQueue中， 真正发送给应用是由对应的NIOSocketWR从写队列中读取ByteBuffer并返回的
 */
  @Override public void okResponse(  byte[] data,  BackendConnection conn){
    this.netOutBytes+=data.length;
    boolean executeResponse=conn.syncAndExcute();
    if (executeResponse) {
      ServerConnection source=session.getSource();
      OkPacket ok=new OkPacket();
      ok.read(data);
      this.affectedRows+=ok.affectedRows;
      if (ok.hasMoreResultsExists()) {
        return;
      }
      boolean isCanClose2Client=(!rrs.isCallStatement()) || (rrs.isCallStatement() && !rrs.getProcedure().isResultSimpleValue());
      if (rrs.isLoadData()) {
        ok.packetId=++packetId;
        source.getLoadDataInfileHandler().clear();
      }
 else       if (isCanClose2Client) {
        ok.packetId=++packetId;
      }
      if (isCanClose2Client) {
        session.releaseConnectionIfSafe(conn,LOGGER.isDebugEnabled(),false);
        endRunning();
      }
      ok.serverStatus=source.isAutocommit() ? 2 : 1;
      recycleResources();
      if (isCanClose2Client) {
        source.setLastInsertId(ok.insertId);
        if (!errorRepsponsed.get() && !session.closed() && source.canResponse()) {
          ok.write(source);
        }
      }
      source.setExecuteSql(null);
      source.getListener().fireEvent(SqlExecuteStage.END);
      QueryResult queryResult=new QueryResult(session.getSource().getSchema(),session.getSource().getUser(),rrs.getSqlType(),rrs.getStatement(),affectedRows,netInBytes,netOutBytes,startTime,System.currentTimeMillis(),0,source.getHost());
      QueryResultDispatcher.dispatchQuery(queryResult);
    }
  }
  /** 
 * select  行结束标志返回时触发，将EOF标志写入缓冲区，最后调用source.write(buffer)将缓冲区放入前端连接的写缓冲队列中，等待NIOSocketWR将其发送给应用
 */
  @Override public void rowEofResponse(  byte[] eof,  BackendConnection conn){
    this.netOutBytes+=eof.length;
    ServerConnection source=session.getSource();
    conn.recordSql(source.getHost(),source.getSchema(),node.getStatement());
    if (!rrs.isCallStatement() || (rrs.isCallStatement() && rrs.getProcedure().isResultSimpleValue())) {
      session.releaseConnectionIfSafe(conn,LOGGER.isDebugEnabled(),false);
      endRunning();
    }
    eof[3]=++packetId;
    buffer=source.writeToBuffer(eof,allocBuffer());
    int resultSize=source.getWriteQueue().size() * MycatServer.getInstance().getConfig().getSystem().getBufferPoolPageSize();
    resultSize=resultSize + buffer.position();
    MiddlerResultHandler middlerResultHandler=session.getMiddlerResultHandler();
    if (middlerResultHandler != null) {
      middlerResultHandler.secondEexcute();
    }
 else {
      if (!errorRepsponsed.get() && !session.closed() && source.canResponse()) {
        source.write(buffer);
      }
    }
    source.setExecuteSql(null);
    source.getListener().fireEvent(SqlExecuteStage.END);
    QueryResult queryResult=new QueryResult(session.getSource().getSchema(),session.getSource().getUser(),rrs.getSqlType(),rrs.getStatement(),affectedRows,netInBytes,netOutBytes,startTime,System.currentTimeMillis(),resultSize,source.getHost());
    QueryResultDispatcher.dispatchQuery(queryResult);
  }
  /** 
 * lazy create ByteBuffer only when needed
 * @return
 */
  protected ByteBuffer allocBuffer(){
    if (buffer == null) {
      buffer=session.getSource().allocate();
    }
    return buffer;
  }
  /** 
 * select 元数据返回时触发，将header和元数据内容依次写入缓冲区中
 */
  @Override public void fieldEofResponse(  byte[] header,  List<byte[]> fields,  byte[] eof,  BackendConnection conn){
    this.header=header;
    this.fields=fields;
    MiddlerResultHandler middlerResultHandler=session.getMiddlerResultHandler();
    if (null != middlerResultHandler) {
      return;
    }
    this.netOutBytes+=header.length;
    for (int i=0, len=fields.size(); i < len; ++i) {
      byte[] field=fields.get(i);
      this.netOutBytes+=field.length;
    }
    header[3]=++packetId;
    ServerConnection source=session.getSource();
    buffer=source.writeToBuffer(header,allocBuffer());
    for (int i=0, len=fields.size(); i < len; ++i) {
      byte[] field=fields.get(i);
      field[3]=++packetId;
      FieldPacket fieldPk=new FieldPacket();
      fieldPk.read(field);
      fieldPackets.add(fieldPk);
      buffer=source.writeToBuffer(field,buffer);
    }
    fieldCount=fieldPackets.size();
    eof[3]=++packetId;
    buffer=source.writeToBuffer(eof,buffer);
    if (isDefaultNodeShowTable) {
      for (      String name : shardingTablesSet) {
        RowDataPacket row=new RowDataPacket(1);
        row.add(StringUtil.encode(name.toLowerCase(),source.getCharset()));
        row.packetId=++packetId;
        buffer=row.write(buffer,source,true);
      }
    }
 else     if (isDefaultNodeShowFullTable) {
      for (      String name : shardingTablesSet) {
        RowDataPacket row=new RowDataPacket(1);
        row.add(StringUtil.encode(name.toLowerCase(),source.getCharset()));
        row.add(StringUtil.encode("BASE TABLE",source.getCharset()));
        row.packetId=++packetId;
        buffer=row.write(buffer,source,true);
      }
    }
  }
  /** 
 * select  行数据返回时触发，将行数据写入缓冲区中
 */
  @Override public void rowResponse(  byte[] row,  BackendConnection conn){
    if (errorRepsponsed.get()) {
      return;
    }
    this.netOutBytes+=row.length;
    this.selectRows++;
    if (isDefaultNodeShowTable || isDefaultNodeShowFullTable) {
      RowDataPacket rowDataPacket=new RowDataPacket(1);
      rowDataPacket.read(row);
      String table=StringUtil.decode(rowDataPacket.fieldValues.get(0),session.getSource().getCharset());
      if (shardingTablesSet.contains(table.toUpperCase())) {
        return;
      }
    }
    row[3]=++packetId;
    if (prepared) {
      RowDataPacket rowDataPk=new RowDataPacket(fieldCount);
      rowDataPk.read(row);
      BinaryRowDataPacket binRowDataPk=new BinaryRowDataPacket();
      binRowDataPk.read(fieldPackets,rowDataPk);
      binRowDataPk.packetId=rowDataPk.packetId;
      buffer=binRowDataPk.write(buffer,session.getSource(),true);
    }
 else {
      MiddlerResultHandler middlerResultHandler=session.getMiddlerResultHandler();
      if (null == middlerResultHandler) {
        buffer=session.getSource().writeToBuffer(row,allocBuffer());
      }
 else {
        if (middlerResultHandler instanceof MiddlerQueryResultHandler) {
          byte[] rv=ResultSetUtil.getColumnVal(row,fields,0);
          String rowValue=rv == null ? "" : new String(rv);
          middlerResultHandler.add(rowValue);
        }
      }
    }
  }
  @Override public void writeQueueAvailable(){
  }
  @Override public void connectionClose(  BackendConnection conn,  String reason){
    ErrorPacket err=new ErrorPacket();
    err.packetId=++packetId;
    err.errno=ErrorCode.ER_ERROR_ON_CLOSE;
    LOGGER.error(reason);
    err.message=StringUtil.encode(reason,session.getSource().getCharset());
    this.backConnectionErr(err,conn);
  }
  public void clearResources(){
  }
  @Override public void requestDataResponse(  byte[] data,  BackendConnection conn){
    LoadDataUtil.requestFileDataResponse(data,conn);
  }
  public boolean isPrepared(){
    return prepared;
  }
  public void setPrepared(  boolean prepared){
    this.prepared=prepared;
  }
  @Override public String toString(){
    return "SingleNodeHandler [node=" + node + ", packetId="+ packetId+ "]";
  }
}
