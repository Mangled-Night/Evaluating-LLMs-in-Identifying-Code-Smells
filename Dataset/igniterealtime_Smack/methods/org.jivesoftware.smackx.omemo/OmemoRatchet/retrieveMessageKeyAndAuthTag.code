/** 
 * Try to decrypt the transported message key using the double ratchet session.
 * @param element omemoElement
 * @return tuple of cipher generated from the unpacked message key and the auth-tag
 * @throws CryptoFailedException if decryption using the double ratchet fails
 * @throws NoRawSessionException if we have no session, but the element was NOT a PreKeyMessage
 * @throws IOException if an I/O error occurred.
 */
CipherAndAuthTag retrieveMessageKeyAndAuthTag(OmemoDevice sender,OmemoElement element) throws CryptoFailedException, NoRawSessionException, IOException {
  int keyId=omemoManager.getDeviceId();
  byte[] unpackedKey=null;
  List<CryptoFailedException> decryptExceptions=new ArrayList<>();
  List<OmemoKeyElement> keys=element.getHeader().getKeys();
  boolean preKey=false;
  for (  OmemoKeyElement k : keys) {
    if (k.getId() == keyId) {
      try {
        unpackedKey=doubleRatchetDecrypt(sender,k.getData());
        preKey=k.isPreKey();
        break;
      }
 catch (      CryptoFailedException e) {
        decryptExceptions.add(e);
      }
catch (      CorruptedOmemoKeyException e) {
        decryptExceptions.add(new CryptoFailedException(e));
      }
catch (      UntrustedOmemoIdentityException e) {
        LOGGER.log(Level.WARNING,"Received message from " + sender + " contained unknown identityKey. Ignore message.",e);
      }
    }
  }
  if (unpackedKey == null) {
    if (!decryptExceptions.isEmpty()) {
      throw MultipleCryptoFailedException.from(decryptExceptions);
    }
    throw new CryptoFailedException("Transported key could not be decrypted, since no suitable message key " + "was provided. Provides keys: " + keys);
  }
  byte[] messageKey=new byte[16];
  byte[] authTag=null;
  if (unpackedKey.length == 32) {
    authTag=new byte[16];
    System.arraycopy(unpackedKey,0,messageKey,0,16);
    System.arraycopy(unpackedKey,16,authTag,0,16);
  }
 else   if (element.isKeyTransportElement() && unpackedKey.length == 16) {
    messageKey=unpackedKey;
  }
 else {
    throw new CryptoFailedException("MessageKey has wrong length: " + unpackedKey.length + ". Probably legacy auth tag format.");
  }
  return new CipherAndAuthTag(messageKey,element.getHeader().getIv(),authTag,preKey);
}
