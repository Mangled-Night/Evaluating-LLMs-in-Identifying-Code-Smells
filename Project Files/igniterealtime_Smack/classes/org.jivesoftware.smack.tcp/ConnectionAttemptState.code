public final class ConnectionAttemptState {
  private final ModularXmppClientToServerConnectionInternal connectionInternal;
  private final XmppTcpTransportModule.XmppTcpNioTransport.DiscoveredTcpEndpoints discoveredEndpoints;
  private final EstablishingTcpConnectionState establishingTcpConnectionState;
  final SocketChannel socketChannel;
  final List<RemoteConnectionException<?>> connectionExceptions;
  EndpointConnectionException connectionException;
  boolean connected;
  long deadline;
  final Iterator<Rfc6120TcpRemoteConnectionEndpoint> connectionEndpointIterator;
  /** 
 * The current connection endpoint we are trying 
 */
  Rfc6120TcpRemoteConnectionEndpoint connectionEndpoint;
  Iterator<? extends InetAddress> inetAddressIterator;
  ConnectionAttemptState(  ModularXmppClientToServerConnectionInternal connectionInternal,  XmppTcpTransportModule.XmppTcpNioTransport.DiscoveredTcpEndpoints discoveredEndpoints,  EstablishingTcpConnectionState establishingTcpConnectionState) throws IOException {
    this.connectionInternal=connectionInternal;
    this.discoveredEndpoints=discoveredEndpoints;
    this.establishingTcpConnectionState=establishingTcpConnectionState;
    socketChannel=SocketChannel.open();
    socketChannel.configureBlocking(false);
    List<Rfc6120TcpRemoteConnectionEndpoint> endpoints=discoveredEndpoints.result.discoveredRemoteConnectionEndpoints;
    connectionEndpointIterator=endpoints.iterator();
    connectionExceptions=new ArrayList<>(endpoints.size());
  }
  StateTransitionResult.Failure establishTcpConnection() throws InterruptedException {
    RemoteConnectionEndpoint.InetSocketAddressCoupling<Rfc6120TcpRemoteConnectionEndpoint> address=nextAddress();
    establishTcpConnection(address);
synchronized (this) {
      while (!connected && connectionException == null) {
        final long now=System.currentTimeMillis();
        if (now >= deadline) {
          return new StateTransitionResult.FailureCausedByTimeout("Timeout waiting to establish connection");
        }
        wait(deadline - now);
      }
    }
    if (connected) {
      assert connectionException == null;
      return null;
    }
    return new StateTransitionResult.FailureCausedByException<Exception>(connectionException);
  }
  private void establishTcpConnection(  RemoteConnectionEndpoint.InetSocketAddressCoupling<Rfc6120TcpRemoteConnectionEndpoint> address){
    TcpHostEvent.ConnectingToHostEvent connectingToHostEvent=new TcpHostEvent.ConnectingToHostEvent(establishingTcpConnectionState,address);
    connectionInternal.invokeConnectionStateMachineListener(connectingToHostEvent);
    final InetSocketAddress inetSocketAddress=address.getInetSocketAddress();
    deadline=System.currentTimeMillis() + connectionInternal.connection.getReplyTimeout();
    try {
      connected=socketChannel.connect(inetSocketAddress);
    }
 catch (    IOException e) {
      onIOExceptionWhenEstablishingTcpConnection(e,address);
      return;
    }
    if (connected) {
      TcpHostEvent.ConnectedToHostEvent connectedToHostEvent=new TcpHostEvent.ConnectedToHostEvent(establishingTcpConnectionState,address,true);
      connectionInternal.invokeConnectionStateMachineListener(connectedToHostEvent);
synchronized (this) {
        notifyAll();
      }
      return;
    }
    try {
      connectionInternal.registerWithSelector(socketChannel,SelectionKey.OP_CONNECT,(selectedChannel,selectedSelectionKey) -> {
        SocketChannel selectedSocketChannel=(SocketChannel)selectedChannel;
        boolean finishConnected;
        try {
          finishConnected=selectedSocketChannel.finishConnect();
        }
 catch (        IOException e) {
          Async.go(() -> onIOExceptionWhenEstablishingTcpConnection(e,address));
          return;
        }
        if (!finishConnected) {
          Async.go(() -> onIOExceptionWhenEstablishingTcpConnection(new IOException("finishConnect() failed"),address));
          return;
        }
        TcpHostEvent.ConnectedToHostEvent connectedToHostEvent=new TcpHostEvent.ConnectedToHostEvent(establishingTcpConnectionState,address,false);
        connectionInternal.invokeConnectionStateMachineListener(connectedToHostEvent);
        connected=true;
synchronized (ConnectionAttemptState.this) {
          notifyAll();
        }
      }
);
    }
 catch (    ClosedChannelException e) {
      onIOExceptionWhenEstablishingTcpConnection(e,address);
    }
  }
  private void onIOExceptionWhenEstablishingTcpConnection(  IOException exception,  RemoteConnectionEndpoint.InetSocketAddressCoupling<Rfc6120TcpRemoteConnectionEndpoint> failedAddress){
    RemoteConnectionEndpoint.InetSocketAddressCoupling<Rfc6120TcpRemoteConnectionEndpoint> nextInetSocketAddress=nextAddress();
    if (nextInetSocketAddress == null) {
      connectionException=EndpointConnectionException.from(discoveredEndpoints.result.lookupFailures,connectionExceptions);
synchronized (this) {
        notifyAll();
      }
      return;
    }
    RemoteConnectionException<Rfc6120TcpRemoteConnectionEndpoint> rce=new RemoteConnectionException<>(failedAddress,exception);
    connectionExceptions.add(rce);
    TcpHostEvent.ConnectionToHostFailedEvent connectionToHostFailedEvent=new TcpHostEvent.ConnectionToHostFailedEvent(establishingTcpConnectionState,nextInetSocketAddress,exception);
    connectionInternal.invokeConnectionStateMachineListener(connectionToHostFailedEvent);
    establishTcpConnection(nextInetSocketAddress);
  }
  private RemoteConnectionEndpoint.InetSocketAddressCoupling<Rfc6120TcpRemoteConnectionEndpoint> nextAddress(){
    if (inetAddressIterator == null || !inetAddressIterator.hasNext()) {
      if (!connectionEndpointIterator.hasNext()) {
        return null;
      }
      connectionEndpoint=connectionEndpointIterator.next();
      inetAddressIterator=connectionEndpoint.getInetAddresses().iterator();
      assert inetAddressIterator.hasNext();
    }
    InetAddress inetAddress=inetAddressIterator.next();
    return new RemoteConnectionEndpoint.InetSocketAddressCoupling<>(connectionEndpoint,inetAddress);
  }
}
