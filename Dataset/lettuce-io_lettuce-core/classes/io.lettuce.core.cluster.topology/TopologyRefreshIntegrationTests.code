/** 
 * Test for topology refreshing.
 * @author Mark Paluch
 */
@SuppressWarnings({"unchecked"}) @SlowTests @ExtendWith(LettuceExtension.class) class TopologyRefreshIntegrationTests extends TestSupport {
  private static final String host=TestSettings.hostAddr();
  private final RedisClient client;
  private RedisClusterClient clusterClient;
  private RedisCommands<String,String> redis1;
  private RedisCommands<String,String> redis2;
  @Inject TopologyRefreshIntegrationTests(  RedisClient client){
    this.client=client;
  }
  @BeforeEach void openConnection(){
    clusterClient=RedisClusterClient.create(client.getResources(),RedisURI.Builder.redis(host,ClusterTestSettings.port1).build());
    redis1=client.connect(RedisURI.Builder.redis(ClusterTestSettings.host,ClusterTestSettings.port1).build()).sync();
    redis2=client.connect(RedisURI.Builder.redis(ClusterTestSettings.host,ClusterTestSettings.port2).build()).sync();
  }
  @AfterEach void closeConnection(){
    redis1.getStatefulConnection().close();
    redis2.getStatefulConnection().close();
    FastShutdown.shutdown(clusterClient);
  }
  @Test void changeTopologyWhileOperations(){
    ClusterTopologyRefreshOptions topologyRefreshOptions=ClusterTopologyRefreshOptions.builder().enablePeriodicRefresh(true).refreshPeriod(1,TimeUnit.SECONDS).build();
    clusterClient.setOptions(ClusterClientOptions.builder().topologyRefreshOptions(topologyRefreshOptions).build());
    RedisAdvancedClusterAsyncCommands<String,String> clusterConnection=clusterClient.connect().async();
    clusterClient.getPartitions().clear();
    Wait.untilTrue(() -> {
      return !clusterClient.getPartitions().isEmpty();
    }
).waitOrTimeout();
    clusterConnection.getStatefulConnection().close();
  }
  @Test void dynamicSourcesProvidesClientCountForAllNodes(){
    ClusterTopologyRefreshOptions topologyRefreshOptions=ClusterTopologyRefreshOptions.create();
    clusterClient.setOptions(ClusterClientOptions.builder().topologyRefreshOptions(topologyRefreshOptions).build());
    RedisAdvancedClusterAsyncCommands<String,String> clusterConnection=clusterClient.connect().async();
    for (    RedisClusterNode redisClusterNode : clusterClient.getPartitions()) {
      assertThat(redisClusterNode).isInstanceOf(RedisClusterNodeSnapshot.class);
      RedisClusterNodeSnapshot snapshot=(RedisClusterNodeSnapshot)redisClusterNode;
      assertThat(snapshot.getConnectedClients()).isNotNull().isGreaterThanOrEqualTo(0);
    }
    clusterConnection.getStatefulConnection().close();
  }
  @Test void staticSourcesProvidesClientCountForSeedNodes(){
    ClusterTopologyRefreshOptions topologyRefreshOptions=ClusterTopologyRefreshOptions.builder().dynamicRefreshSources(false).build();
    clusterClient.setOptions(ClusterClientOptions.builder().topologyRefreshOptions(topologyRefreshOptions).build());
    RedisAdvancedClusterAsyncCommands<String,String> clusterConnection=clusterClient.connect().async();
    Partitions partitions=clusterClient.getPartitions();
    RedisClusterNodeSnapshot node1=(RedisClusterNodeSnapshot)partitions.getPartitionBySlot(0);
    assertThat(node1.getConnectedClients()).isGreaterThanOrEqualTo(1);
    RedisClusterNodeSnapshot node2=(RedisClusterNodeSnapshot)partitions.getPartitionBySlot(15000);
    assertThat(node2.getConnectedClients()).isNull();
    clusterConnection.getStatefulConnection().close();
  }
  @Test void adaptiveTopologyUpdateOnDisconnectNodeIdConnection(){
    runReconnectTest((clusterConnection,node) -> {
      RedisClusterAsyncCommands<String,String> connection=clusterConnection.getConnection(node.getUri().getHost(),node.getUri().getPort());
      return connection;
    }
);
  }
  @Test void adaptiveTopologyUpdateOnDisconnectHostAndPortConnection(){
    runReconnectTest((clusterConnection,node) -> {
      RedisClusterAsyncCommands<String,String> connection=clusterConnection.getConnection(node.getUri().getHost(),node.getUri().getPort());
      return connection;
    }
);
  }
  @Test void adaptiveTopologyUpdateOnDisconnectDefaultConnection(){
    runReconnectTest((clusterConnection,node) -> {
      return clusterConnection;
    }
);
  }
  @Test void adaptiveTopologyUpdateIsRateLimited(){
    ClusterTopologyRefreshOptions topologyRefreshOptions=ClusterTopologyRefreshOptions.builder().adaptiveRefreshTriggersTimeout(1,TimeUnit.HOURS).refreshTriggersReconnectAttempts(0).enableAllAdaptiveRefreshTriggers().build();
    clusterClient.setOptions(ClusterClientOptions.builder().topologyRefreshOptions(topologyRefreshOptions).build());
    RedisAdvancedClusterAsyncCommands<String,String> clusterConnection=clusterClient.connect().async();
    clusterClient.getPartitions().clear();
    clusterConnection.quit();
    Wait.untilTrue(() -> {
      return !clusterClient.getPartitions().isEmpty();
    }
).waitOrTimeout();
    clusterClient.getPartitions().clear();
    clusterConnection.quit();
    Delay.delay(Duration.ofMillis(200));
    assertThat(clusterClient.getPartitions()).isEmpty();
    clusterConnection.getStatefulConnection().close();
  }
  @Test void adaptiveTopologyUpdateUsesTimeout(){
    ClusterTopologyRefreshOptions topologyRefreshOptions=ClusterTopologyRefreshOptions.builder().adaptiveRefreshTriggersTimeout(500,TimeUnit.MILLISECONDS).refreshTriggersReconnectAttempts(0).enableAllAdaptiveRefreshTriggers().build();
    clusterClient.setOptions(ClusterClientOptions.builder().topologyRefreshOptions(topologyRefreshOptions).build());
    RedisAdvancedClusterAsyncCommands<String,String> clusterConnection=clusterClient.connect().async();
    clusterConnection.quit();
    Delay.delay(Duration.ofMillis(700));
    Wait.untilTrue(() -> {
      return !clusterClient.getPartitions().isEmpty();
    }
).waitOrTimeout();
    clusterClient.getPartitions().clear();
    clusterConnection.quit();
    Wait.untilTrue(() -> {
      return !clusterClient.getPartitions().isEmpty();
    }
).waitOrTimeout();
    clusterConnection.getStatefulConnection().close();
  }
  @Test void adaptiveTriggerDoesNotFireOnSingleReconnect(){
    ClusterTopologyRefreshOptions topologyRefreshOptions=ClusterTopologyRefreshOptions.builder().enableAllAdaptiveRefreshTriggers().build();
    clusterClient.setOptions(ClusterClientOptions.builder().topologyRefreshOptions(topologyRefreshOptions).build());
    RedisAdvancedClusterAsyncCommands<String,String> clusterConnection=clusterClient.connect().async();
    clusterClient.getPartitions().clear();
    clusterConnection.quit();
    Delay.delay(Duration.ofMillis(500));
    assertThat(clusterClient.getPartitions()).isEmpty();
    clusterConnection.getStatefulConnection().close();
  }
  @Test void adaptiveTriggerOnMoveRedirection(){
    ClusterTopologyRefreshOptions topologyRefreshOptions=ClusterTopologyRefreshOptions.builder().enableAdaptiveRefreshTrigger(ClusterTopologyRefreshOptions.RefreshTrigger.MOVED_REDIRECT).build();
    clusterClient.setOptions(ClusterClientOptions.builder().topologyRefreshOptions(topologyRefreshOptions).build());
    StatefulRedisClusterConnection<String,String> connection=clusterClient.connect();
    RedisAdvancedClusterAsyncCommands<String,String> clusterConnection=connection.async();
    Partitions partitions=connection.getPartitions();
    RedisClusterNode node1=partitions.getPartitionBySlot(0);
    RedisClusterNode node2=partitions.getPartitionBySlot(12000);
    List<Integer> slots=node2.getSlots();
    slots.addAll(node1.getSlots());
    node2.setSlots(slots);
    node1.setSlots(Collections.emptyList());
    partitions.updateCache();
    assertThat(clusterClient.getPartitions().getPartitionByNodeId(node1.getNodeId()).getSlots()).hasSize(0);
    assertThat(clusterClient.getPartitions().getPartitionByNodeId(node2.getNodeId()).getSlots()).hasSize(16384);
    connection.reactive().set("b",value).toFuture();
    Wait.untilEquals(12000,() -> clusterClient.getPartitions().getPartitionByNodeId(node1.getNodeId()).getSlots().size()).waitOrTimeout();
    assertThat(clusterClient.getPartitions().getPartitionByNodeId(node1.getNodeId()).getSlots()).hasSize(12000);
    assertThat(clusterClient.getPartitions().getPartitionByNodeId(node2.getNodeId()).getSlots()).hasSize(4384);
    clusterConnection.getStatefulConnection().close();
  }
  private void runReconnectTest(  BiFunction<RedisAdvancedClusterAsyncCommands<String,String>,RedisClusterNode,BaseRedisAsyncCommands> function){
    ClusterTopologyRefreshOptions topologyRefreshOptions=ClusterTopologyRefreshOptions.builder().refreshTriggersReconnectAttempts(0).enableAllAdaptiveRefreshTriggers().build();
    clusterClient.setOptions(ClusterClientOptions.builder().topologyRefreshOptions(topologyRefreshOptions).build());
    RedisAdvancedClusterAsyncCommands<String,String> clusterConnection=clusterClient.connect().async();
    RedisClusterNode node=clusterClient.getPartitions().getPartition(0);
    BaseRedisAsyncCommands closeable=function.apply(clusterConnection,node);
    clusterClient.getPartitions().clear();
    closeable.quit();
    Wait.untilTrue(() -> {
      return !clusterClient.getPartitions().isEmpty();
    }
).waitOrTimeout();
    if (closeable instanceof RedisAdvancedClusterCommands) {
      ((RedisAdvancedClusterCommands)closeable).getStatefulConnection().close();
    }
    clusterConnection.getStatefulConnection().close();
  }
}
