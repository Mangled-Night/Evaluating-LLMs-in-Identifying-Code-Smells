public class DQLRouteTest {
  protected Map<String,SchemaConfig> schemaMap;
  protected LayerCachePool cachePool=new SimpleCachePool();
  protected RouteStrategy routeStrategy;
  private Map<String,String> tableAliasMap=new HashMap<String,String>();
  protected DruidShardingParseInfo ctx;
  public DQLRouteTest(){
    String schemaFile="/route/schema.xml";
    String ruleFile="/route/rule.xml";
    SchemaLoader schemaLoader=new XMLSchemaLoader(schemaFile,ruleFile);
    schemaMap=schemaLoader.getSchemas();
    MycatServer.getInstance().getConfig().getSchemas().putAll(schemaMap);
    RouteStrategyFactory.init();
    routeStrategy=RouteStrategyFactory.getRouteStrategy("druidparser");
  }
  @Test public void test() throws Exception {
    String stmt="select * from `offer` where id = 100";
    SchemaConfig schema=schemaMap.get("mysqldb");
    RouteResultset rrs=new RouteResultset(stmt,7);
    SQLStatementParser parser=null;
    if (schema.isNeedSupportMultiDBType()) {
      parser=new MycatStatementParser(stmt);
    }
 else {
      parser=new MySqlStatementParser(stmt);
    }
    SQLStatement statement;
    MycatSchemaStatVisitor visitor=null;
    try {
      statement=parser.parseStatement();
      visitor=new MycatSchemaStatVisitor();
    }
 catch (    Exception t) {
      throw new SQLSyntaxErrorException(t);
    }
    ctx=new DruidShardingParseInfo();
    ctx.setSql(stmt);
    List<RouteCalculateUnit> taskList=visitorParse(rrs,statement,visitor);
    Assert.assertEquals(true,!taskList.get(0).getTablesAndConditions().isEmpty());
  }
  @SuppressWarnings("unchecked") private List<RouteCalculateUnit> visitorParse(  RouteResultset rrs,  SQLStatement stmt,  MycatSchemaStatVisitor visitor) throws Exception {
    stmt.accept(visitor);
    List<List<Condition>> mergedConditionList=new ArrayList<List<Condition>>();
    if (visitor.hasOrCondition()) {
      mergedConditionList=visitor.splitConditions();
    }
 else {
      mergedConditionList.add(visitor.getConditions());
    }
    if (visitor.getAliasMap() != null) {
      for (      Map.Entry<String,String> entry : visitor.getAliasMap().entrySet()) {
        String key=entry.getKey();
        String value=entry.getValue();
        if (key != null && key.indexOf("`") >= 0) {
          key=key.replaceAll("`","");
        }
        if (value != null && value.indexOf("`") >= 0) {
          value=value.replaceAll("`","");
        }
        if (key != null) {
          int pos=key.indexOf(".");
          if (pos > 0) {
            key=key.substring(pos + 1);
          }
        }
        if (key.equals(value)) {
          ctx.addTable(key.toUpperCase());
        }
        tableAliasMap.put(key.toUpperCase(),value);
      }
      visitor.getAliasMap().putAll(tableAliasMap);
      ctx.setTableAliasMap(tableAliasMap);
    }
    Class<?> clazz=Class.forName("io.mycat.route.parser.druid.impl.DefaultDruidParser");
    Method buildRouteCalculateUnits=clazz.getDeclaredMethod("buildRouteCalculateUnits",new Class[]{MycatSchemaStatVisitor.class,List.class});
    Object newInstance=clazz.newInstance();
    buildRouteCalculateUnits.setAccessible(true);
    Object returnValue=buildRouteCalculateUnits.invoke(newInstance,new Object[]{visitor,mergedConditionList});
    List<RouteCalculateUnit> retList=new ArrayList<RouteCalculateUnit>();
    if (returnValue instanceof ArrayList<?>) {
      retList.add(((ArrayList<RouteCalculateUnit>)returnValue).get(0));
    }
    return retList;
  }
}
